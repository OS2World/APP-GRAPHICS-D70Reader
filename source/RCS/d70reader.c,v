head	1.31;
access;
symbols;
locks
	joman:1.31; strict;
comment	@ * @;


1.31
date	2005.04.14.17.38.53;	author joman;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.24.03.59.11;	author joman;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.22.17.15.28;	author joman;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.21.23.13.33;	author joman;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.04.17.45.35;	author joman;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.04.16.26.34;	author joman;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.04.16.16.03;	author joman;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.21.20.50.47;	author joman;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.19.19.15.37;	author joman;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.15.03.57.32;	author joman;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.28.17.22.04;	author joman;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.26.22.48.18;	author joman;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.22.21.03.18;	author joman;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.21.16.21.59;	author joman;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.21.16.13.33;	author joman;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.21.04.39.50;	author joman;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.19.21.24.43;	author joman;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.13.17.06.15;	author joman;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.13.02.16.30;	author joman;	state Exp;
branches;
next	1.12;

1.12
date	2005.01.13.01.55.32;	author joman;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.10.21.36.25;	author joman;	state Exp;
branches;
next	1.10;

1.10
date	2005.01.04.04.05.29;	author joman;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.04.04.00.15;	author joman;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.04.01.18.39;	author joman;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.01.17.08.34;	author joman;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.30.22.05.52;	author joman;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.30.21.33.40;	author joman;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.29.21.36.42;	author joman;	state Exp;
branches;
next	1.3;

1.3
date	2004.12.27.21.23.08;	author joman;	state Exp;
branches;
next	1.2;

1.2
date	2004.12.27.15.29.56;	author joman;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.27.15.21.24;	author joman;	state Exp;
branches;
next	;


desc
@First RCS version
@


1.31
log
@See the source change block.  Refer to Version 0.21.
@
text
@/************************************************************************/
/*	$Id: d70reader.c,v 1.30 2005/03/24 03:59:11 joman Exp joman $	*/
/*									*/
/*      Program name:   d70reader.c                                     */
/*                                                                      */
/*      This program will output image file EXIF data to the screen.    */
/*      This program was extended from my nefexif.c program. 		*/
/*      This may be compiled under Linux GCC like this:  cc d70reader.c */
/*      This can also be compiled within a Visual C++ project.          */
/************************************************************************/
/*	Revisions:							*/
/*									*/
/*	Version 0.01 - Sun Dec 12 12:11:21 EST 2004:			*/
/*		First coding to combine nefexif and jpgexif.		*/
/*	Version 0.02 - Thu Dec 23 14:13:18 EST 2004:			*/
/*		Added wildcard support.					*/
/*	Version 0.03 - Sun Dec 26 11:19:15 EST 2004:			*/
/*		Added edits for Format 7 tags.  Added the -v and -h	*/
/*		options.  Fixed a couple of Format 3 edits.		*/
/*	Version 0.04 - Mon Dec 27 16:19:25 EST 2004:			*/
/*		Added LensInfo.  Reformatted raw lens data to be	*/
/*		more presentable.  Truncated decimal part of 		*/
/*		focal length display.  Added to RCS revision system.	*/
/*	Version 0.05 - Wed Dec 29 16:01:24 EST 2004:			*/
/*		Added -w option.  This option will create an HTML	*/
/*		table of the EXIF data.  This can be then inserted	*/
/*		into an HTML document.					*/
/*	Version 0.06 - Thu Dec 30 16:20:39 EST 2004:			*/
/*		Added -x option.  This option outputs XML data.		*/
/*	Version 0.07 - Sat Jan  1 12:05:28 EST 2005:			*/
/*		Fixed UserComment.  Correct misspelling of 'seconds'.	*/
/*		Handled 'unknown' tag for D2H.				*/
/*	Version 0.08 - Mon Jan  3 23:03:38 EST 2005:			*/
/*		Added tag 8827 (ISO).  Modified to use right shift 	*/
/*		operators for selected formats that are less than 	*/
/*		4 bytes long.						*/
/*	Version 0.09 - Mon Jan 10 16:32:23 EST 2005:			*/
/*		Added -j option to extract JPG thumbnail image from	*/
/*		a NEF image.  Additional code cleanup.			*/
/*	Version 0.10 - Wed Jan 12 20:49:51 EST 2005:			*/
/*		Added -c option to generate CSV data.			*/
/*	Version 0.11 - Thu Jan 13 12:03:17 EST 2005:			*/
/*		Corrected a problem with the -c option.  Forgot to	*/
/*		include the image file name in the output! Also added	*/
/*		double quotes around the data elements.			*/
/*	Version 0.12 - Fri Jan 21 09:34:51 EST 2005:			*/
/*		When using option -j, to extract the JPG image from a	*/
/*		NEF image, write EXIF data to the new JPG file.  Also	*/
/*		modified the XML output to convert the tags to		*/
/*		lowercase.						*/
/*	Version 0.13 - Sat Jan 22 15:57:10 EST 2005:			*/
/*		Fixed a problem with wildcard processing, where the	*/
/*		program would stop on first error, instead of going	*/
/*		on to the next file in the list.  Also fixed, was the	*/
/*		JPEG marker scan logic.  Finally, changed the 'ifdef'	*/
/*		logic for the FreeBSD system compile.			*/
/*	Version 0.14 - Fri Jan 28 12:17:09 EST 2005:			*/
/*		Added logic to rotate the JPG image when the -j option	*/
/*		is used.  The source now uses the IJG JPEG library.	*/
/*		A configuration file called 'd70reader.conf' can be	*/
/*		used to select the tags that will be displayed.		*/
/*	Version 0.15 - Mon Feb 14 22:52:53 EST 2005:			*/
/*		Changed the default location for the config file.	*/
/*		The default is to create the file in the user space,	*/
/*		not the system space. (Not in /etc, or c:\windows)	*/
/*	Version 0.16 - Sat Feb 19 14:01:53 EST 2005:			*/
/*		Added 'assert' logic to prevent bad data processing.	*/
/*		Fixed a buffer overflow exception with format #1.	*/
/*		Cleaned out dead code.  Better control of iSystemType.	*/
/*		Only process MakerNotes for Nikon cameras.  Calculate	*/
/*		shutter speed, instead of if/else logic.  Added 'G-VR'	*/
/*		and 'D-VR' lens types.					*/
/*	Version 0.17 - Mon Feb 21 15:47:19 EST 2005:			*/
/*		JPG extraction now works for the D100 and D2H.  Added	*/
/*		WhiteBalance and Sharpening tags.  Fixed (hopefully)	*/
/*		the last buffer overflow problem.			*/
/*	Version 0.18 - Fri Mar  4 10:53:34 EST 2005:			*/
/*		Added option -js, to generate JavaScript arrays of the	*/
/*		EXIF data.  Added place holders for the missing tags	*/
/*		for the -c option.  Added the Adobe XMP SDK logic to	*/
/*		capture more EXIF data for Adobe modified files.  Fixed	*/
/*		a problem with the lens display, where the decimal	*/
/*		part was being truncated.  Allow the *.* wildcard,	*/
/*		ignoring non-image files.  Added support for the D2X	*/
/*		camera.							*/
/*	Version 0.19 - Mon Mar 21 17:38:33 EST 2005:			*/
/*		Added ImageWidth and ImageLength tags.  These are 	*/
/*		embedded in a NEF file.  Added a space before the 'mm'	*/
/*		output for focal length and lens.  Truncated FNumber to	*/
/*		two decimal places.  Added the -web option.  This 	*/
/*		allows the generation of image galleries that can be	*/
/*		copied as is to a web site for display.			*/
/*	Version 0.20 - Wed Mar 23 22:54:24 EST 2005:			*/
/*		Corrected a problem, where the program was not		*/
/*		rotating a JPG image with the -web option.		*/
/*	Version 0.21 - Thu Apr 14 13:17:57 EDT 2005:			*/
/*		Added the -rm option to allow complete removal of the	*/
/*		EXIF data from a JPG image.  Fixed a problem with the	*/
/*		-web option, where vertical images were not always	*/
/*		displayed properly.  Handle a situation where the image	*/
/*		file does not contain the orientation tag 0x112.	*/
/*		Fixed a problem where the -j option would fail with	*/
/*		certain Nikon Capture created files.  When using the	*/
/*		-j option, the EXIF data is now correctly formatted	*/
/*		into the proper buckets, instead of having it all at	*/
/*		the lowest level.  This means that other applications	*/
/*		will now correctly read it.  The original -j logic	*/
/*		from version 0.20 is kept as -jold.  There are still	*/
/*		some image processing software created images that	*/
/*		can not be handled correctly with the newer -j option.	*/
/*		The -jold option does work with some of these images.	*/
/*									*/
/************************************************************************/
#ifdef __OS2__
#define _TRUNCATE_DECLARED
#endif

#ifdef __FreeBSD__
#define _TRUNCATE_DECLARED
#endif

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <time.h>
#include <assert.h>

#ifdef WIN32
#include <direct.h>
#endif

#include "d70reader.h"
#include "d70config.h"
#include "d70inc1.h"
#include "d70inc2.h"

#ifndef __APPLE__
#ifndef __FreeBSD__
#include <malloc.h>
#endif
#endif

#ifdef MPATROL_DEBUG
#include "mpatrol.h"
#endif

#define D70_VERSION "0.21"
#define D70_DATE "Thu Apr 14 17:18:08 UTC 2005"
static char rcsid[] = "$Id: d70reader.c,v 1.30 2005/03/24 03:59:11 joman Exp joman $";

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int main(int argc, char *argv[], char* env[])
{
	int ctr1 = 0;
	int ctr2 = 0;
	int ctr3 = 0;
	int argn = 0;
	char *arg = NULL;
	struct stat buf;
	char *filename = NULL;
	char *temp_ptr = NULL;

#ifdef __OS2__
	_wildcard(&argc, &argv);
#endif

	if(argc < 2)
	{
		instruct();
		exit(1);
	}

	for(argn = 1; argn < argc; argn++)
	{
		arg = argv[argn];

		if(arg[0] != '-') 
			break; // Filenames have started.

		if(!strcmp(arg,"-v"))
		{
			iVerbos = 1;
		}
		else if(!strcmp(arg,"-w"))
		{
			iHtml = 1;
		}
		else if(!strcmp(arg,"-c"))
		{
			iCsv = 1;
		}
		else if(!strcmp(arg,"-web"))
		{
			iWeb = 1;
		}
		else if(!strcmp(arg,"-js"))
		{
			iJS = 1;
		}
		else if(!strcmp(arg,"-x"))
		{
			iXml = 1;
		}
		else if(!strcmp(arg,"-j"))
		{
			iThumbnail = 1;
		}
		else if(!strcmp(arg,"-jold"))
		{
			iThumbnailOld = 1;
		}
		else if(!strcmp(arg,"-rm"))
		{
			iRemoveEXIF = 1;
		}
		else if(!strcmp(arg,"-t"))
		{
			iTrace = 1;
		}
		else if(!strcmp(arg,"-h"))
		{
			instruct();
			exit(1);
		}
		else
		{
			instruct();
			exit(1);
		}

		ctr1++;
	}

	if(argc == argn)
	{
		instruct();
		exit(1);
	}

	do
	{
		temp_ptr = (char *) malloc(strlen(env[ctr3]) + 1);
		memset(temp_ptr, (int) NULL, strlen(env[ctr3]) + 1);
		memcpy(temp_ptr, env[ctr3], strlen(env[ctr3]));
		temp_ptr = upper_case(temp_ptr);

		if(iTrace)
			printf("\n%s", temp_ptr);

		if(strlen(temp_ptr) >= 5)
		{
			if(!memcmp(temp_ptr, "PATH=", 5))
			{
				if(memchr(temp_ptr,'\\', 20))
					iSystemType = 1;
				else
					iSystemType = 0;
			}
		}

		if(file_sys_dir_ptr == NULL)
		{
			if(strlen(temp_ptr) >= 12)
			{
				// if found, this should be windows:
				if(!memcmp(temp_ptr, "USERPROFILE=", 12))
				{
					file_sys_dir_ptr = (char *) my_malloc("file_sys_dir_ptr", strlen(temp_ptr) + 1);
					memset(file_sys_dir_ptr, (int) NULL, strlen(temp_ptr) + 1);
					memcpy(file_sys_dir_ptr, &env[ctr3][12], strlen(temp_ptr) - 12);
	
					if(iTrace)
						printf("\nfile_sys_dir_ptr: %s\n", file_sys_dir_ptr);
				}
			}

			if(strlen(temp_ptr) >= 5)
			{
				// if found, this should be linux/unix:
				if(!memcmp(temp_ptr, "HOME=", 5))
				{
					file_sys_dir_ptr = (char *) my_malloc("file_sys_dir_ptr", strlen(temp_ptr) + 1);
					memset(file_sys_dir_ptr, (int) NULL, strlen(temp_ptr) + 1);
					memcpy(file_sys_dir_ptr, &env[ctr3][5], strlen(temp_ptr) - 5);
	
					if(iTrace)
						printf("\nfile_sys_dir_ptr: %s\n", file_sys_dir_ptr);
				}
			}

			if(strlen(temp_ptr) >= 10)
			{
				// if found, this should be OS/2:
				if(!memcmp(temp_ptr, "OS2_SHELL=", 10))
				{
					file_sys_dir_ptr = (char *) my_malloc("file_sys_dir_ptr", strlen(temp_ptr) + 10);
					memset(file_sys_dir_ptr, (int) NULL, strlen(temp_ptr) + 10);
					memcpy(file_sys_dir_ptr, &env[ctr3][10], 2);
					memcpy(&file_sys_dir_ptr[2], "\\OS2\\APPS", 9);
	
					if(iTrace)
						printf("\nfile_sys_dir_ptr: %s\n", file_sys_dir_ptr);
				}
			}
		}

		ctr3++;
	}
	while(env[ctr3] != NULL);

	// Suggestion by BRN, in case nothing is set
	if(file_sys_dir_ptr == NULL)
	{
		file_sys_dir_ptr = (char *) my_malloc("file_sys_dir_ptr", 5);
		memset(file_sys_dir_ptr, (int) NULL, 5);
		//put the config file in the current directory
		strcpy (file_sys_dir_ptr, ".");
	}

	check_for_config();

	for(ctr2 = 0; ctr2 < ctr1; ctr2++)
		argv++;

	while(filename = *++argv)
	{
		if(iTrace)
			printf("\nfilename: %s---->", filename);

		if(stat(filename, &buf) == (-1))
		{
			perror(filename);
		}
		else
		{
			lFileSize = buf.st_size;

			if(iThumbnail || iThumbnailOld)
				ProcessFileJPG(argc, filename);
			else
				ProcessFile(argc, filename);

			ulGlobalOrientation = 0l;
			ulGlobalPosition = 0l;

			if(iTrace)
				printf("\nulGlobalPosition: %x", ulGlobalPosition);
		}
	}

	if(iJS)
		printf("var intExifDataArrayCount=%d\n", (js_ctr1 - 1));

	if(iWeb)
	{
		if(gallery_ofd != NULL)
		{
			fprintf(gallery_ofd, "var intExifDataArrayCount=%d\n", (iWeb_Image_count - 1));
			fclose(gallery_ofd);

			fprintf(root_ofd, "var intExifDataArrayCount=%d\n", (iRoot_Web_Image_count - 1));
			fclose(root_ofd);

			if(str_root_temp_dir != NULL)
			{
				my_rmdir(str_root_temp_dir);
				my_free("str_root_temp_dir", str_root_temp_dir);
			}
		}
	}

	if(file_sys_dir_ptr != NULL)
		my_free("file_sys_dir_ptr", file_sys_dir_ptr);

	if(iMemTrace)
	{
		printf("\nmalloc_count: %d", malloc_count);
		printf("\nfree_count: %d", free_count);
	}

	return(0);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void ProcessFile(int argc, char *filename)
{
    FILE *rfd = NULL;
	struct xmp_data *xmp_data_ptr = NULL;
	struct xmp_data *start_xmp_data_ptr = NULL;
	struct xmp_data *free_xmp_data_ptr = NULL;
	struct xmp_packet *xmp_packet_ptr = NULL;
	char buffer[256];
	char *temp_ptr = NULL;
	char *file_name_ptr = NULL;
	unsigned long offset_ifd = 0l;
	long old_position = 0l;
	int ctr1 = 0;
	struct data_header_ptr *temp_header_start_ptr = NULL;
	struct data_header_ptr *free_header_start_ptr = NULL;
	struct html_header *free_html_header_start_ptr = NULL;

	trace("\n+ProcessFile");
	mtrace("\n+ProcessFile");

	temp_ptr = get_extension(filename);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "\nFile Extension: %s", temp_ptr);
	trace(trace_buffer);

	if(!strncmp(upper_case(temp_ptr), "JPG", 3))
	{
		iFile_Type = 0;
	}
	else
	{
		if(!strncmp(upper_case(temp_ptr), "NEF", 3))
		{
			iJPG_Type = 99;
			iFile_Type = 1;
		}
		else
		{
			if((!iHtml) && (!iXml) && (!iCsv) && (!iJS))
				printf("\nFile not readable: %s\n\n", filename);

			return;
		}
	}

	if((rfd = fopen(filename, "rb")) == NULL)
	{
		printf("\nFile not opened: %s\n\n", filename);
		return;
	}

	if(iRemoveEXIF)
	{
		if(!iFile_Type)
			remove_exif(filename, rfd);
		else
			printf("\nCan't process NEF files\n\n");

		return;
	}

	if((!iHtml) && (!iXml) && (!iCsv) && (!iJS))
	{
		printf("\nD70ReaderProgramVersion    : %s", D70_VERSION);
		printf("\nFilename                   : %s", filename);
	}

	if(!iFile_Type)
	{
		if(!check_for_exif_data(rfd))
		{
			if((!iHtml) && (!iXml) && (!iCsv) && (!iJS))
				printf("\nNo EXIF data found\n");

			trace("\n-ProcessFile");
			mtrace("\n-ProcessFile");
			return;
		}
	}

	if((iHtml) || (iXml) || (iCsv) || (iJS) || (iWeb))
	{
		if(iWeb)
		{
			if(iFile_Type)
			{
				web_file_name_src_ptr = strdup(filename);

				file_name_ptr = (char *) my_malloc("file_name_ptr", (strlen(filename) + strlen(".JPG") + 1));
				memset(file_name_ptr, (int) NULL, (strlen(filename) + strlen(".JPG") + 1));
				sprintf(file_name_ptr, "%s.JPG", filename);

				web_file_name_tmp_ptr = strdup(file_name_ptr);
			}
			else
			{
				web_file_name_tmp_ptr = strdup(filename);

				file_name_ptr = (char *) my_malloc("file_name_ptr", (strlen(filename) + 1));
				memset(file_name_ptr, (int) NULL, (strlen(filename) + 1));
				sprintf(file_name_ptr, "%s", filename);
			}
		}
		else
		{
			file_name_ptr = (char *) my_malloc("file_name_ptr", (strlen(filename) + 1));
			memset(file_name_ptr, (int) NULL, (strlen(filename) + 1));
			sprintf(file_name_ptr, "%s", filename);
		}

		if(iTrace)
		{
			debug_printf("%x %s %s", 0xFFFD, "D70ReaderProgramVersion    ", D70_VERSION);
			debug_printf("%x %s %s", 0xFFFE, "Filename                   ", file_name_ptr);
		}
		else
		{
			my_printf("%s %s", 0xFFFD, "D70ReaderProgramVersion    ", D70_VERSION);
			my_printf("%s %s", 0xFFFE, "Filename                   ", file_name_ptr);
		}

	 	my_free("file_name_ptr", file_name_ptr);
	}

	memset(buffer, (int) NULL, 256);
	sprintf(buffer, "IFD%d", ctr1++);

	offset_ifd = inspect_image_file_header(rfd, iFile_Type);

	if(dump_image_file_directory(rfd, offset_ifd, jpg_type_offset(), get_new_data_header_ptr(), buffer))
	{
		free_html_header_start_ptr = html_header_start_ptr;

		free_memory(free_header_start_ptr, free_html_header_start_ptr);
		return;
	}

	old_position = ftell(rfd);

	fread(&offset_ifd, sizeof(unsigned long), 1, rfd);
	offset_ifd = Get32u(&offset_ifd);

#ifdef XMP_SDK
	if(jpg_type() == 0)
	{
		if((xmp_packet_ptr = chk_get_xmp_data(rfd)) != NULL)
		{
			xmp_data_ptr = xmp_display(filename, xmp_packet_ptr->length, xmp_packet_ptr->value, iVerbos);

			start_xmp_data_ptr = xmp_data_ptr;
			free_xmp_data_ptr = xmp_data_ptr;

			do
			{
				if(iTrace)
					printf("\n%d - \"%s\" - \"%s\"", xmp_data_ptr->tag, xmp_data_ptr->description, xmp_data_ptr->value);

				xmp_data_ptr = xmp_data_ptr->next;
			}
			while(xmp_data_ptr != NULL); 
		}
	}
#endif

	temp_header_start_ptr = main_header_start_ptr;
	free_header_start_ptr = main_header_start_ptr;

	if(iTrace || iVerbos)
	{
		printf("\n--------------START OF RAW DATA---------------\n");

		ctr1 = 0;

		while(main_header_start_ptr->next != NULL)
		{
			header_ptr = main_header_start_ptr->header_ptr;

			while(header_ptr->next != NULL)
			{
				if(header_ptr->Tag != 0)
					printf("\n(%d) - %s - FMT: %d - NUM: %ld - TAG: %#x: %s: %s", ctr1++, main_header_start_ptr->data_type, header_ptr->field_type, header_ptr->count, header_ptr->Tag, header_ptr->Desc, header_ptr->Value);
	
				header_ptr = header_ptr->next;
			}

			main_header_start_ptr = main_header_start_ptr->next;
		}

		header_ptr = main_header_start_ptr->header_ptr;

		//special case for XMP data
		if(header_ptr->Tag == 0xFFFF)
			printf("\n(%d) - %s - FMT: %d - NUM: %ld - TAG: %#x: %s: %s", ctr1++, main_header_start_ptr->data_type, header_ptr->field_type, header_ptr->count, header_ptr->Tag, header_ptr->Desc, header_ptr->Value);

		while(header_ptr->next != NULL)
		{
			if(header_ptr->Tag != 0)
					printf("\n(%d) - %s - FMT: %d - NUM: %ld - TAG: %#x: %s: %s", ctr1++, main_header_start_ptr->data_type, header_ptr->field_type, header_ptr->count, header_ptr->Tag, header_ptr->Desc, header_ptr->Value);

			header_ptr = header_ptr->next;
		}

		printf("\n--------------END OF RAW DATA---------------\n");
	}

	GlobalOrientationPtr = (char *) my_malloc("GlobalOrientationPtr", (strlen("xxx") + 1));
	memset(GlobalOrientationPtr, (int) NULL, (strlen("xxx") + 1));
	sprintf(GlobalOrientationPtr, "%s", "X");

	if(iTrace)
		printf("\n--------------START NEW DATA DISPLAY---------------\n");

	ctr1 = 0;

	while(temp_header_start_ptr->next != NULL)
	{
		display_data(temp_header_start_ptr->header_ptr, temp_header_start_ptr->data_type);

		temp_header_start_ptr = temp_header_start_ptr->next;
	}

	display_data(temp_header_start_ptr->header_ptr, temp_header_start_ptr->data_type);

	if(iTrace)
		printf("\n\n--------------END NEW DATA DISPLAY---------------\n");

#ifdef XMP_SDK
	if(jpg_type() == 0)
	{
		if(start_xmp_data_ptr != NULL)
		{
			do
			{
				if(iTrace)
					printf("\n%x - \"%s\" - \"%s\"", start_xmp_data_ptr->tag, get_description_label(start_xmp_data_ptr->tag, 0), start_xmp_data_ptr->value);

				if(iTrace)
					debug_printf("\n%#x: %s: %s seconds", start_xmp_data_ptr->tag, get_description_label(start_xmp_data_ptr->tag, 0), start_xmp_data_ptr->value);
				else
					my_printf("\n%s: %s", start_xmp_data_ptr->tag, get_description_label(start_xmp_data_ptr->tag, 0), start_xmp_data_ptr->value);

				start_xmp_data_ptr = start_xmp_data_ptr->next;
			}
			while(start_xmp_data_ptr != NULL); 
		}
	}
#endif

	free_html_header_start_ptr = html_header_start_ptr;

	if(iWeb)
		get_sof0_data(rfd);

	fclose(rfd);

	if(iHtml)
		output_html();

	if(iXml)
		output_xml();

	if(iCsv)
		output_csv();

	if(iJS)
	{
		if(iJS_First_Time)
		{
			iJS_First_Time = 0;
			output_js(stdout, 1, js_ctr1++);
		}
		else
			output_js(stdout, 0, js_ctr1++);
	}

	if(ALLOW_ROTATE)
	{
		if(iWeb)
			output_web();
	}

	if((!iHtml) && (!iXml) && (!iCsv) && (!iJS) && (!iWeb))
		printf("\n\n");

#ifdef XMP_SDK
	if(jpg_type() == 0)
		if(free_xmp_data_ptr != NULL)
			free_xmp_data_header_list(free_xmp_data_ptr);
#endif

	free_memory(free_header_start_ptr, free_html_header_start_ptr);

	trace("\n-ProcessFile");
	mtrace("\n-ProcessFile");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_xml()
{
	struct html_header *local_header_start_ptr = NULL;

	trace("\n+output_xml");
	//mtrace("\n+output_xml");

	local_header_start_ptr = html_header_start_ptr;

	printf("\n\n<?xml version=\"1.0\" standalone=\"yes\"?>\n");
	printf("<data>\n");

	while(local_header_start_ptr->next != NULL)
	{
		printf("<%s>%s</%s>\n", lower_case(strip(local_header_start_ptr->Desc)), local_header_start_ptr->Value, lower_case(strip(local_header_start_ptr->Desc)));

		local_header_start_ptr = local_header_start_ptr->next;
	}

	printf("<%s>%s</%s>\n", lower_case(strip(local_header_start_ptr->Desc)), local_header_start_ptr->Value, lower_case(strip(local_header_start_ptr->Desc)));
	printf("</data>\n");

	trace("\n-output_xml");
	//mtrace("\n-output_xml");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_csv()
{
	int ctr1 = 0;
	struct all_wanted_tags *local_header_all_ptr = NULL;
	struct html_header *local_header_start_ptr = NULL;

	trace("\n+output_csv");
	//mtrace("\n+output_csv");

	if(iCsv_First_Time)
	{
		printf("\"D70ReaderProgramVersion\",\"Filename\"");

		local_header_all_ptr = start_all_wanted_tags_ptr;

		do
		{
			if(is_tag_printed(local_header_all_ptr->tag))
			{
				if(iTrace)
					printf("\n%d - %x - \"%s\",", ctr1++, local_header_all_ptr->tag, get_description_label(local_header_all_ptr->tag, 1));

				printf(",\"%s\"", get_description_label(local_header_all_ptr->tag, 1));
			}

			local_header_all_ptr = local_header_all_ptr->next;
		}
		while(local_header_all_ptr != NULL); 

		printf("\n");

		iCsv_First_Time = 0;
	}

	printf("\"%s\",\"%s\"", D70_VERSION, get_description_value(0xFFFE));

	local_header_all_ptr = start_all_wanted_tags_ptr;

	do
	{
		if(is_tag_printed(local_header_all_ptr->tag))
		{
			if(iTrace)
				printf("\n%d - %x - \"%s\",", ctr1++, local_header_all_ptr->tag, get_description_value(local_header_all_ptr->tag));

			printf(",\"%s\"", get_description_value(local_header_all_ptr->tag));
		}

		local_header_all_ptr = local_header_all_ptr->next;
	}
	while(local_header_all_ptr != NULL); 

	printf("\n");

	trace("\n-output_csv");
	//mtrace("\n-output_csv");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char *strip(char *str_input)
{
	char *temp_ptr = NULL;
	char *token = NULL;

	//trace("\n+strip");
	//mtrace("\n+strip");

	temp_ptr = strdup(str_input);

	token = strtok(temp_ptr, " ");

	//trace("\n-strip");
	//mtrace("\n-strip");
	return(token);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_html()
{
	struct html_header *local_header_start_ptr = NULL;

	trace("\n+output_html");
	//mtrace("\n+output_html");

	local_header_start_ptr = html_header_start_ptr;

	printf("\n\n<table border=\"1\" width=\"450\" cellpadding=\"1\" align=\"center\">\n");

	while(local_header_start_ptr->next != NULL)
	{
		printf("<tr><td>%s</td><td>%s</td></tr>\n", local_header_start_ptr->Desc, local_header_start_ptr->Value);

		local_header_start_ptr = local_header_start_ptr->next;
	}

	printf("<tr><td>%s</td><td>%s</td></tr>\n", local_header_start_ptr->Desc, local_header_start_ptr->Value);

	printf("</table>\n");

	trace("\n-output_html");
	//mtrace("\n-output_html");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void free_memory(struct data_header_ptr *free_header_start_ptr, struct html_header *free_html_header_start_ptr)
{
	struct data_header_ptr *temp_header_start_ptr = NULL;
	struct data_header_ptr *tmp2_header_start_ptr = NULL;

	trace("\n+free_memory");
	mtrace("\n+free_memory");

	temp_header_start_ptr = free_header_start_ptr;

	if(temp_header_start_ptr != NULL)
	{
		while(temp_header_start_ptr->next != NULL)
		{
			tmp2_header_start_ptr = temp_header_start_ptr;
			free_data_header_list(temp_header_start_ptr->header_ptr);
			temp_header_start_ptr = temp_header_start_ptr->next;
			my_free("tmp2_header_start_ptr", tmp2_header_start_ptr);
		}

		my_free("temp_header_start_ptr", temp_header_start_ptr);
	}

	main_header_ptr = NULL;
	main_header_start_ptr = NULL;

	free_html_header_list(free_html_header_start_ptr);
	html_header_ptr = NULL;

	trace("\n-free_memory");
	mtrace("\n-free_memory");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void free_data_header_list(struct data_header *header_ptr)
{
	struct data_header *temp_header_ptr = NULL;

	trace("\n+free_data_header_list");
	mtrace("\n+free_data_header_list");

	while(header_ptr->next != NULL)
	{
		temp_header_ptr = header_ptr;
		header_ptr = header_ptr->next;

		if(temp_header_ptr != NULL)
			my_free("temp_header_ptr", temp_header_ptr);
	}

	if(header_ptr != NULL)
		my_free("header_ptr", header_ptr);

	trace("\n-free_data_header_list");
	mtrace("\n-free_data_header_list");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void free_html_header_list(struct html_header *header_ptr)
{
	struct html_header *temp_header_ptr = NULL;

	trace("\n+free_html_header_list");
	mtrace("\n+free_html_header_list");

	if(header_ptr != NULL)
	{
		while(header_ptr->next != NULL)
		{
			temp_header_ptr = header_ptr;
			header_ptr = header_ptr->next;
			my_free("temp_header_ptr", temp_header_ptr);
		}

		my_free("header_ptr", header_ptr);
	}

	trace("\n-free_html_header_list");
	mtrace("\n-free_html_header_list");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char *upper_case(char *local_ptr)
{
	int ctr1 = 0;
	int length = 0;
	char *temp_ptr = NULL;
	char *final_ptr = NULL;

	//trace("\n+upper_case");
	//mtrace("\n+upper_case");

	temp_ptr = strdup(local_ptr);
	final_ptr = temp_ptr;

	length = strlen(temp_ptr);

	for(ctr1 = 0; ctr1 < length; ctr1++)
	{
		*temp_ptr = toupper(*temp_ptr);
		temp_ptr++;
	}

	//trace("\n-upper_case");
	//mtrace("\n-upper_case");

	return(final_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char *lower_case(char *local_ptr)
{
	int ctr1 = 0;
	int length = 0;
	char *temp_ptr = NULL;
	char *final_ptr = NULL;

	//trace("\n+lower_case");
	//mtrace("\n+lower_case");

	temp_ptr = strdup(local_ptr);
	final_ptr = temp_ptr;

	length = strlen(temp_ptr);

	for(ctr1 = 0; ctr1 < length; ctr1++)
	{
		*temp_ptr = tolower(*temp_ptr);
		temp_ptr++;
	}

	//trace("\n-lower_case");
	//mtrace("\n-lower_case");

	return(final_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char *get_extension(char *string)
{
	char *temp_ptr = NULL;
	char *final_ptr = NULL;
	char *token = NULL;

	trace("\n+get_extension");
	//mtrace("\n+get_extension");

	temp_ptr = strdup(string);

	token = strtok(temp_ptr, ".");

	do
	{
		if(token != NULL)
			final_ptr = token;

		token = strtok(NULL, ".");
	}
	while(token != NULL);

	trace("\n-get_extension");
	//mtrace("\n-get_extension");
	return(final_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void get_xmp_data(FILE *rfd, struct data_header *local_ptr)
{
	int ctr1 = 0;
	int iFoundHTTP = 0;
	unsigned char *data_ptr = NULL;

	unsigned short length;
	long position;
	int oldMotorolaOrder;

	struct marker
	{
		unsigned char pad;
		unsigned char marker;
		unsigned short length;
		char test_data[6];
	};

	struct marker *temp_ptr;

	oldMotorolaOrder = MotorolaOrder;
	MotorolaOrder = 1;

	temp_ptr = (struct marker *) my_malloc("temp_ptr", sizeof(struct marker));
	memset(temp_ptr, (int) NULL, sizeof(struct marker));

	fseek(rfd, 2, 0);

	do
	{
		ctr1++;
		position = ftell(rfd);

		memset(temp_ptr, (int) NULL, sizeof(struct marker));
		fread(temp_ptr, sizeof(struct marker), 1, rfd);

		length = Get16u(&temp_ptr->length);

		if(!strncmp(temp_ptr->test_data, "http:", strlen("http:")))
		{
			iFoundHTTP = 1;
			break;
		}
		else
			fseek(rfd, Get16u(&temp_ptr->length) - sizeof(struct marker) + 2, 1);

		if(temp_ptr->marker == 0xda)
			break;
	}
	while(strncmp(temp_ptr->test_data, "http:", strlen("http:")));	

	if(iFoundHTTP)
	{
		data_ptr = (unsigned char *) my_malloc("data_ptr", (Get16u(&temp_ptr->length) + 1));
		memset(data_ptr, (int) NULL, (Get16u(&temp_ptr->length) + 1));

		fseek(rfd, position + 4, 0);
		fread(data_ptr, Get16u(&temp_ptr->length), 1, rfd);

		while(*data_ptr != (unsigned char) NULL)
			data_ptr++;

		data_ptr++;

		local_ptr->Tag = 0xFFFF;
		local_ptr->field_type = 2;
		local_ptr->count = Get16u(&temp_ptr->length);
		local_ptr->Desc = "XMP Data";
		local_ptr->Value = data_ptr;
		
		main_header_ptr->next = get_new_main_header_ptr();
		main_header_ptr->prev =  main_header_ptr;
		main_header_ptr =  main_header_ptr->next;
		main_header_ptr->header_ptr = local_ptr;
		main_header_ptr->data_type = (char *) my_malloc("main_header_ptr->data_type", (strlen("XMP") + 1));
		memset(main_header_ptr->data_type, (int) NULL, (strlen("XMP") + 1));
		strncpy(main_header_ptr->data_type, "XMP", strlen("XMP"));
	}

	MotorolaOrder = oldMotorolaOrder;

	my_free("temp_ptr", temp_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
unsigned char * pad_field(unsigned char *str_ptr, int length, char pad_char, int iPrePend)
{
	int ctr1 = 0;
	unsigned char *temp_ptr = NULL;
	unsigned char buffer[2];

	trace("\n+pad_field");
	mtrace("\n+pad_field");

	memset(buffer, (int) NULL, 2);
	buffer[0] = pad_char;

	temp_ptr = (unsigned char *) my_malloc("temp_ptr", (strlen(str_ptr) + length + 1));
	memset(temp_ptr, (int) NULL, (strlen(str_ptr) + length + 1));

	if(iPrePend)
	{
		for(ctr1 = 0; ctr1 < (length - (int) strlen(str_ptr)); ctr1++)
		{
			strcat(temp_ptr, buffer);
		}

		strcat(temp_ptr, str_ptr);
	}
	else
	{
		strcat(temp_ptr, str_ptr);

		for(ctr1 = 0; ctr1 < (length - (int) strlen(str_ptr)); ctr1++)
		{
			strcat(temp_ptr, buffer);
		}
	}

	trace("\n-pad_field");
	mtrace("\n-pad_field");

	return temp_ptr;
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void print_8bit_hex(unsigned char *byte_ptr, int ByteCount, struct data_header *local_ptr)
{
	int ctr1 = 0;
	char buffer[256];

	trace("\n+print_8bit_hex");
	mtrace("\n+print_8bit_hex");

	assert(ByteCount < 256);

	memset(buffer, (int) NULL, 256);

	for(ctr1 = 0; ctr1 < ByteCount; ctr1++)
	{
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "%x ", *byte_ptr);
		strcat(buffer, trace_buffer);
		byte_ptr++;
	}

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "%s ", buffer);
	trace_formatted(trace_buffer);

	local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(trace_buffer) + 1));
	memset(local_ptr->Value, (int) NULL, (strlen(trace_buffer) + 1));
	strcpy(local_ptr->Value, trace_buffer);

	trace("\n-print_8bit_hex");
	mtrace("\n-print_8bit_hex");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void print_8bit_bytes(unsigned char *byte_ptr, int ByteCount, struct data_header *local_ptr)
{
	trace("\n+print_8bit_bytes");
	mtrace("\n+print_8bit_bytes");

	if(iTrace)
		printf("byte_ptr: %s\n", byte_ptr);

	local_ptr->Value = (char *) my_malloc("local_ptr->Value", (ByteCount + 1));
	memset(local_ptr->Value, (int) NULL, (ByteCount + 1));
	memcpy(local_ptr->Value, byte_ptr, ByteCount);

	trace("\n-print_8bit_bytes");
	mtrace("\n-print_8bit_bytes");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void print_16bit_hex(unsigned char *byte_ptr, int components, int ByteCount, struct data_header *local_ptr)
{
	int ctr1 = 0;
	char * temp_1_ptr = NULL;
	char * temp_2_ptr = NULL;
	unsigned char *buffer_ptr = NULL;

	trace("\n+print_16bit_hex");
	mtrace("\n+print_16bit_hex");

	temp_1_ptr = strdup(byte_ptr);

	buffer_ptr = (unsigned char*) my_malloc("buffer_ptr", ((2 * components * ByteCount) + 1));
	memset(buffer_ptr, (int) NULL, ((2 * components * ByteCount) + 1));
	//memset(buffer_ptr, (int) ' ', (2 * components * ByteCount));
	temp_2_ptr = buffer_ptr;

	for(ctr1 = 0; ctr1 < components; ctr1++)
	{
		strncpy(temp_2_ptr, temp_1_ptr, ByteCount);
		strcat(temp_2_ptr, " ");

		temp_1_ptr += ByteCount;
		temp_2_ptr += (ByteCount + 1);
	}

	trace_formatted(buffer_ptr);

	local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(buffer_ptr) + 1));
	memset(local_ptr->Value, (int) NULL, (strlen(buffer_ptr) + 1));
	strcpy(local_ptr->Value, buffer_ptr);

	my_free("buffer_ptr", buffer_ptr);

	trace("\n-print_16bit_hex");
	mtrace("\n-print_16bit_hex");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void print_16bit_bytes(unsigned char *byte_ptr, int components, int ByteCount, struct data_header *local_ptr)
{
	int ctr1 = 0;
	char * temp_ptr = NULL;
	char buffer[256];

	trace("\n+print_16bit_bytes");
	mtrace("\n+print_16bit_bytes");

	assert(components < 256);

	temp_ptr = strdup(byte_ptr);

	memset(buffer, (int) NULL, 256);

	for(ctr1 = 0; ctr1 < components; ctr1++)
	{
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "%s ", temp_ptr);
		strcat(buffer, trace_buffer);

		temp_ptr += 2;
	}

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "%s ", buffer); 

	local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(trace_buffer) + 1));
	memset(local_ptr->Value, (int) NULL, (strlen(trace_buffer) + 1));
	strcpy(local_ptr->Value, trace_buffer);

	trace("\n-print_16bit_bytes");
	mtrace("\n-print_16bit_bytes");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void  instruct()                                /*give instructions for use     */
{
    printf("\nD70Reader - Version %s - %s\n", D70_VERSION, D70_DATE); 
    printf("\nThis is a Freeware program, use at your own risk.\n");

	printf("\nThis software makes use of \"The Independent JPEG Group's JPEG Software\"");
	printf("\nSpecifically, it uses their image rotation and resizing logic.");
	printf("\nPlease read their copyright information, found in the jpeglib/README file.\n");

	printf("\nThis software makes use of \"The Adobe XMP SDK Software\"");
	printf("\nPlease read their copyright information, found in the ");
	printf("\nXMP_SDK/Documentation/LICENSE.TXT file.\n");

    printf("\nThis program only works with Nikon D70/D100/D2H/D2X image files.");
    printf("\n(It will work with NEF/RAW and JPG files.)\n");

    printf("\nCheck here for latest version:");
    printf("\nhttp://www.gogebic-pc.com/d70/index.html\n");

    printf("\nFormat:");
    printf("\n\td70reader [-h|-v|-w|-x|-j|-rm|-c|-js|-web] image_file_name\n");
    printf("\n\td70reader [-h|-v|-w|-x|-j|-rm|-c|-js|-web] *.NEF *.JPG\n");
    printf("\n\t-h    = this screen");
    printf("\n\t-v    = verbose (raw data)");
    printf("\n\t-w    = generate HTML table");
    printf("\n\t-x    = generate XML tree");
    printf("\n\t-j    = extract JPG thumbnail image from NEF");
    printf("\n\t-jold = extract JPG thumbnail image from NEF (old)");
    printf("\n\t-rm   = remove all EXIF data from JPG file");
    printf("\n\t-c    = generate Comma Separated Values (CSV) data");
    printf("\n\t-js   = generate JavaScript Array data");
    printf("\n\t-web  = generate Photo Website\n\n");

/*
	printf("Press <Enter> to Continue\n\n");
	getchar();

	printf("I am trying to make sense out of the following EXIF tags:\n\n");

	printf("AF-S DX Zoom-Nikkor ED G IF:\n\n");
	printf("LensType : 6\n");
	printf("Lens : 18-70mm f/3.5-f/4.5\n");
	printf("LensInfo : 40 01 0c 00\n\n");

	printf("AF Zoom-Nikkor D:\n\n");
	printf("LensType : 2\n");
	printf("Lens : 70-300mm f/4.0-f/5.6\n");
	printf("LensInfo : 48 01 0c 00\n\n");

	printf("AF Nikkor D:\n\n");
	printf("LensType : 2\n");
	printf("Lens : 50mm f/1.8\n");
	printf("LensInfo : 58 01 0c 00\n\n");

	printf("AF Micro-Nikkor D:\n\n");
	printf("LensType : 2\n");
	printf("Lens : 60mm f/2.8\n");
	printf("LensInfo : 54 01 0c 00 \n\n");

	printf("I have identified the tag information for the above four lenses.\n");
	printf("If you would like to help me decode the lens information into\n");
	printf("something that makes sense (like my above lens descriptions),\n");
	printf("please send me the above three EXIF data tags for your lenses,\n");
	printf("to the following email address:\n\n");
*/
	printf("joman@@gogebic-pc.com\n\n");
}

//--------------------------------------------------------------------------
// Convert a 16 bit unsigned value from file's native byte order
//--------------------------------------------------------------------------
static void Put16u(void * Short, unsigned short PutValue)
{
	if (MotorolaOrder)
	{
		((uchar *)Short)[0] = (uchar)(PutValue>>8);
		((uchar *)Short)[1] = (uchar)PutValue;
	}
	else
	{
		((uchar *)Short)[0] = (uchar)PutValue;
		((uchar *)Short)[1] = (uchar)(PutValue>>8);
	}
}

//--------------------------------------------------------------------------
// Convert a 16 bit unsigned value from file's native byte order
//--------------------------------------------------------------------------
int Get16u(void * Short)
{
	if (MotorolaOrder)
	{
		return (((uchar *)Short)[0] << 8) | ((uchar *)Short)[1];
	}
	else
	{
		return (((uchar *)Short)[1] << 8) | ((uchar *)Short)[0];
	}
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
unsigned long rotate_right(unsigned long Long)
{

	unsigned long mByte0 = 0l;

	mByte0 = Long >> 16;

	return(mByte0);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
//static int Get32s(void * Long)
int Get32s(void * Long)
{
	if (MotorolaOrder)
	{
		return  ((( char *)Long)[0] << 24) | (((uchar *)Long)[1] << 16)
			| (((uchar *)Long)[2] << 8 ) | (((uchar *)Long)[3] << 0 );
	}
	else
	{
		return  ((( char *)Long)[3] << 24) | (((uchar *)Long)[2] << 16)
			| (((uchar *)Long)[1] << 8 ) | (((uchar *)Long)[0] << 0 );
	}
}

//--------------------------------------------------------------------------
// Convert a 32 bit unsigned value from file's native byte order
//--------------------------------------------------------------------------
unsigned Get32u(void * Long)
{
	return (unsigned)Get32s(Long) & 0xffffffff;
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int dump_image_file_directory(FILE *rfd, unsigned long offset_ifd, unsigned long offset_base, struct data_header *local_ptr, char *type_ptr)
{
	char *buff_ptr = NULL;
	char buffer[256];
	char type_buffer[256];
	struct image_file_directory_entry *ifde_ptr = NULL;
	unsigned short count = 0;
	unsigned short num_ifd = 0;
	int a = 0;
	unsigned long ctr1 = 0l;
	unsigned long ctr2 = 0l;
	unsigned long ctr3 = 0l;
	long old_position = 0l;
	long temp_position = 0l;
	int ByteCount = 0;
	unsigned long components = 0l;      		//count
	unsigned long value_offset = 0l;     	//value offset
	unsigned char *byte_ptr = NULL;
	unsigned short *short_byte_ptr;
	unsigned long *long_byte_ptr = 0l;

	unsigned long numirator = 0l;
	unsigned long denominator = 0l;
	unsigned long numirator_cnvtd = 0l;
	unsigned long denominator_cnvtd = 0l;

	long snumirator = 0l;
	long sdenominator = 0l;
	long snumirator_cnvtd = 0l;
	long sdenominator_cnvtd = 0l;

	double num = 0.0;
	double den = 0.0;

	unsigned long maker_note_header_offset = 0l;
	unsigned long ulLocalPosition = 0l;
	struct html_header *local_header_start_ptr = NULL;

	trace("\n+dump_image_file_directory");
	mtrace("\n+dump_image_file_directory");

	ifde_ptr = (struct image_file_directory_entry *) my_malloc("ifde_ptr", sizeof(struct image_file_directory_entry));
	memset(ifde_ptr, (int) NULL, sizeof(struct image_file_directory_entry));

	if(fseek(rfd, offset_ifd, 0) != -1)
	{
		fread(&count, sizeof(unsigned short), 1, rfd);
		num_ifd = Get16u(&count);

		//assert(num_ifd != 0x0000);
		if(num_ifd == 0x0000)
		{
			if(!iFile_Type)
			{
				if((!iHtml) && (!iXml) && (!iCsv) && (!iJS))
				{
					printf("\n\nIf the above file was created with the -j option,");
					printf("\ntry using the -jold option to re-create this JPG.\n");
					printf("\nIf this file was not created with the -j option, ");
					printf("\nthe EXIF data is corrupted.\n\n");
				}
			}
			else
			{
				if((!iHtml) && (!iXml) && (!iCsv) && (!iJS))
					printf("\nThe EXIF data for this NEF/RAW file is corrupted.\n\n");
			}

			if(iTrace)
			{
				local_header_start_ptr = html_header_start_ptr;

				do
				{
					printf("\nDesc: %s - Value: %s", local_header_start_ptr->Desc, local_header_start_ptr->Value);

					local_header_start_ptr = local_header_start_ptr->next;
				}
				while(local_header_start_ptr != NULL);
			}

			return(1);
		}

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nNumber of Image File Directories: %d", num_ifd);
		trace(trace_buffer);
	}
	else
	{
		my_error(rfd);
	}

	if(main_header_ptr == NULL)
	{
		main_header_ptr = get_new_main_header_ptr();
		main_header_ptr->header_ptr = local_ptr;
		main_header_ptr->data_type = (char *) my_malloc("main_header_ptr->data_type", (strlen(type_ptr) + 1));
		memset(main_header_ptr->data_type, (int) NULL, (strlen(type_ptr) + 1));
		strncpy(main_header_ptr->data_type, type_ptr, strlen(type_ptr));
		main_header_start_ptr = main_header_ptr;
	}
	else
	{
		main_header_ptr->next = get_new_main_header_ptr();
		main_header_ptr->prev =  main_header_ptr;
		main_header_ptr =  main_header_ptr->next;
		main_header_ptr->header_ptr = local_ptr;
		main_header_ptr->data_type = (char *) my_malloc("main_header_ptr->data_type", (strlen(type_ptr) + 1));
		memset(main_header_ptr->data_type, (int) NULL, (strlen(type_ptr) + 1));
		strncpy(main_header_ptr->data_type, type_ptr, strlen(type_ptr));
	}

	for(ctr1 = 0; ctr1 < num_ifd; ctr1++)
	{
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\n\nctr1: %d", ctr1);
		trace(trace_buffer);

		memset(ifde_ptr, (int) NULL, sizeof(struct image_file_directory_entry));
		fread(ifde_ptr, sizeof(struct image_file_directory_entry), 1, rfd);

		ulLocalPosition = ftell(rfd);

		if(ulLocalPosition > ulGlobalPosition)
			ulGlobalPosition = ulLocalPosition;

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nTag: %x", Get16u(&ifde_ptr->tag));
		trace(trace_buffer);

		local_ptr->Tag = Get16u(&ifde_ptr->tag);
		local_ptr->field_type = Get16u(&ifde_ptr->field_type);
		local_ptr->count = Get32u(&ifde_ptr->count);

		for (a = 0; ;a++)
		{
			if (a >= SizeTagTable )
			{
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "    Unknown Tag %04x Value = ", Get16u(&ifde_ptr->tag));
				trace(trace_buffer);

				local_ptr->Desc = (char *) my_malloc("local_ptr->Desc", (strlen(trace_buffer) + 1));
				memset(local_ptr->Desc, (int) NULL, (strlen(trace_buffer) + 1));
				strcpy(local_ptr->Desc, trace_buffer);
				break;
			}

			if (TagTable[a].Tag == Get16u(&ifde_ptr->tag))
			{
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "%s",TagTable[a].Desc); 

				local_ptr->Desc = (char *) my_malloc("local_ptr->Desc", (strlen(trace_buffer) + 1));
				memset(local_ptr->Desc, (int) NULL, (strlen(trace_buffer) + 1));
				strcpy(local_ptr->Desc, trace_buffer);

				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\n%s",TagTable[a].Desc); 
				trace(trace_buffer);
				break;
			}
		}

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nField Type: %x", Get16u(&ifde_ptr->field_type));
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nNumber of Values: %x", Get32u(&ifde_ptr->count));
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nValue Offset: %x", Get32u(&ifde_ptr->value_offset));
		trace(trace_buffer);

		components = Get32u(&ifde_ptr->count);
		value_offset = Get32u(&ifde_ptr->value_offset) + offset_base;

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\ncomponents: %d", components);
		trace(trace_buffer);

		old_position = ftell(rfd);

		switch(Get16u(&ifde_ptr->field_type))
		{
			case 1:
				ByteCount = components * 1;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);

				byte_ptr = (unsigned char *) my_malloc("byte_ptr", (ByteCount + 1));
				memset(byte_ptr, (int) NULL, (ByteCount + 1));

				if (ByteCount > 4)
				{
					fseek(rfd, Get32u(&ifde_ptr->value_offset), 0);
					fread(byte_ptr, ByteCount, 1, rfd);
				}
				else
				{
					extract_and_format_data(ifde_ptr, local_ptr, 0);
					break;
				}

				print_8bit_bytes(byte_ptr, ByteCount, local_ptr);
				my_free("byte_ptr", byte_ptr);

				break;
			case 2:
				ByteCount = components * 1;

				if (ByteCount > 4)
				{
					fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
					
					buff_ptr = (char *) my_malloc("buff_ptr", (components + 1));
					memset(buff_ptr, (int) NULL, (components + 1));

					fread(buff_ptr, components, 1, rfd);
					trace_formatted(buff_ptr);

					local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(buff_ptr) + 1));
					memset(local_ptr->Value, (int) NULL, (strlen(buff_ptr) + 1));
					strcpy(local_ptr->Value, buff_ptr);

					if(Get16u(&ifde_ptr->tag) == 0x10F)
					{
						make_ptr = (char *) my_malloc("make_ptr", (components + 1));
						memset(make_ptr, (int) NULL, (components + 1));
						strcpy(make_ptr, buff_ptr);
					}

					if(Get16u(&ifde_ptr->tag) == 0x110)
					{
						model_ptr = (char *) my_malloc("model_ptr", (components + 1));
						memset(model_ptr, (int) NULL, (components + 1));
						strcpy(model_ptr, buff_ptr);
					}

					if(Get16u(&ifde_ptr->tag) == 0x131)
					{
						software_ptr = (char *) my_malloc("software_ptr", (components + 1));
						memset(software_ptr, (int) NULL, (components + 1));
						strcpy(software_ptr, buff_ptr);
					}

					my_free("buff_ptr", buff_ptr);
				}
				else
				{
					extract_and_format_data(ifde_ptr, local_ptr, 0);
				}
				break;
			case 3:
			case 8:
				ByteCount = components * 2;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);

				if (ByteCount > 4)
				{
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nValue Offset: %x", Get32u(&ifde_ptr->value_offset));
					trace(trace_buffer);

					my_fseek(rfd, Get32u(&ifde_ptr->value_offset), 0);
					temp_position = ftell(rfd);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
					trace(trace_buffer);

					for(ctr3 = 0; ctr3 < components; ctr3++)
					{
						short_byte_ptr = (unsigned short *) my_malloc("short_byte_ptr", sizeof(unsigned short));
						*short_byte_ptr = 0;
						memset(buffer, (int) NULL, 256);
						fread(short_byte_ptr, sizeof(unsigned short), 1, rfd);
						sprintf(buffer, "%-02.2x", Get16u(short_byte_ptr));

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nget16u_short_byte_ptr: %x", Get16u(short_byte_ptr));
						trace(trace_buffer);
	
						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nbuffer: %s", buffer);
						trace(trace_buffer);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nshort_byte_ptr: %x", *short_byte_ptr);
						trace(trace_buffer);

						print_16bit_bytes(buffer, 1, 1, local_ptr);
						my_free("short_byte_ptr", short_byte_ptr);
					}
				}
				else
				{
					extract_and_format_data(ifde_ptr, local_ptr, 0);
				}
				break;
			case 4:
				ByteCount = components * 4;

				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);

				if (ByteCount > 4)
				{
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nValue Offset: %x", Get32u(&ifde_ptr->value_offset));
					trace(trace_buffer);

					my_fseek(rfd, Get32u(&ifde_ptr->value_offset), 0);

					temp_position = ftell(rfd);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
					trace(trace_buffer);

					for(ctr3 = 0; ctr3 < components; ctr3++)
					{
						long_byte_ptr = (unsigned long *) my_malloc("long_byte_ptr", sizeof(unsigned long));
						*long_byte_ptr = 0;
						memset(buffer, (int) NULL, 256);
						fread(long_byte_ptr, sizeof(unsigned long), 1, rfd);
						sprintf(buffer, "%-04.4x", Get32u(long_byte_ptr));

						if(Get16u(&ifde_ptr->tag) == TAG_SUBIFD_S)
						{
							trace("\n------Start SubIFD------");

							//save file ptr
							temp_position = ftell(rfd);
		
							memset(trace_buffer, (int) NULL, 256);
							sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
							trace(trace_buffer);

							memset(trace_buffer, (int) NULL, 256);
							sprintf(trace_buffer, "\noffset to count: %x", (Get32u(long_byte_ptr)));
							trace(trace_buffer);

							memset(type_buffer, (int) NULL, 256);
							sprintf(type_buffer, "SUB_IFD%d", ctr3);

							if(dump_image_file_directory(rfd, (Get32u(long_byte_ptr)), 0, get_new_data_header_ptr(), type_buffer))
								return(1);
		
							//restore file ptr
							fseek(rfd, temp_position, 0);

							trace("\n------End SubIFD------");
						}

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nget33u_long_byte_ptr: %x", Get32u(long_byte_ptr));
						trace(trace_buffer);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nbuffer: %s", buffer);
						trace(trace_buffer);
	
						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nlong_byte_ptr: %x", *long_byte_ptr);
						trace(trace_buffer);

						print_16bit_bytes(buffer, 1, 1, local_ptr);
						my_free("long_byte_ptr", long_byte_ptr);
					}
				}
				else
				{
					extract_and_format_data(ifde_ptr, local_ptr, 0);

					if(Get16u(&ifde_ptr->tag) == TAG_THUMBNAIL_IFD)
					{
						if(!strncmp(upper_case(model_ptr), "NIKON D100", strlen("NIKON D100")) ||
						   !strncmp(upper_case(model_ptr), "NIKON D2H", strlen("NIKON D2H")))
						{
							trace("\n------Start TAG_THUMBNAIL_IFD------");
							//save file ptr
							temp_position = ftell(rfd);

							memset(trace_buffer, (int) NULL, 256);
							sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
							trace(trace_buffer);

							memset(type_buffer, (int) NULL, 256);
							sprintf(type_buffer, "THUMBNAIL");

							//call dump_.... with offset
							if(dump_image_file_directory(rfd, Get32u(&ifde_ptr->value_offset) + calc_maker_note_header_offset, calc_maker_note_header_offset, get_new_data_header_ptr(), type_buffer))
								return(1);

							//restore file ptr
							fseek(rfd, temp_position, 0);
							trace("\n------End TAG_THUMBNAIL_IFD------");
						}
					}

					if(Get16u(&ifde_ptr->tag) == TAG_THUMBNAIL_OFFSET)
					{
						lThumbnailOffset = Get32u(&ifde_ptr->value_offset);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nlThumbnailOffset: %ld", lThumbnailOffset);
						trace(trace_buffer);
					}

					if(Get16u(&ifde_ptr->tag) == TAG_THUMBNAIL_LENGTH)
					{
						lThumbnailLength = Get32u(&ifde_ptr->value_offset);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nlThumbnailLength: %ld", lThumbnailLength);
						trace(trace_buffer);
					}

					if(Get16u(&ifde_ptr->tag) == TAG_EXIF_OFFSET)
					{
						trace("\n------Start EXIF------");
						//save file ptr
						temp_position = ftell(rfd);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
						trace(trace_buffer);

						memset(type_buffer, (int) NULL, 256);
						sprintf(type_buffer, "EXIF");

						//call dump_.... with offset
						if(dump_image_file_directory(rfd, Get32u(&ifde_ptr->value_offset) + jpg_type_offset(), jpg_type_offset(), get_new_data_header_ptr(), type_buffer))
							return(1);

						//restore file ptr
						fseek(rfd, temp_position, 0);
						trace("\n------End EXIF------");
					}
				}
				break;
			case 5:
				ByteCount = components * 8;

				memset(buffer, (int) NULL, 256);

				fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);

				for(ctr2 = 0; ctr2 < components; ctr2++)
				{
					fread(&numirator, sizeof(unsigned long), 1, rfd);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nnumirator: %x", numirator);
					trace(trace_buffer);

					fread(&denominator, sizeof(unsigned long), 1, rfd);
	
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\ndenominator: %x", denominator);
					trace(trace_buffer);
				
					numirator_cnvtd = Get32s(&numirator);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%ld,0", numirator_cnvtd);
					num = atof(trace_buffer);
				
					denominator_cnvtd = Get32s(&denominator);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%ld.0", denominator_cnvtd);
					den = atof(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%f ", num/den); 
					trace_formatted(trace_buffer);
					strcat(buffer, trace_buffer);
				}

				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "%s", buffer); 

				local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(trace_buffer) + 1));
				memset(local_ptr->Value, (int) NULL, (strlen(trace_buffer) + 1));
				strcpy(local_ptr->Value, trace_buffer);

				break;
			case 10:
				ByteCount = components * 8;

				memset(buffer, (int) NULL, 256);

				fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);

				for(ctr2 = 0; ctr2 < components; ctr2++)
				{
					fread(&snumirator, sizeof(long), 1, rfd);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nsnumirator: %x", snumirator);
					trace(trace_buffer);

					fread(&sdenominator, sizeof(long), 1, rfd);
	
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nsdenominator: %x", sdenominator);
					trace(trace_buffer);
				
					snumirator_cnvtd = Get32s(&snumirator);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%ld,0", snumirator_cnvtd);
					num = atof(trace_buffer);
				
					sdenominator_cnvtd = Get32s(&sdenominator);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%ld.0", sdenominator_cnvtd);
					den = atof(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%f ", num/den); 
					trace_formatted(trace_buffer);
					strcat(buffer, trace_buffer);
				}

				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "%s", buffer); 

				local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(trace_buffer) + 1));
				memset(local_ptr->Value, (int) NULL, (strlen(trace_buffer) + 1));
				strcpy(local_ptr->Value, trace_buffer);

				break;
			case 7:
				if(Get16u(&ifde_ptr->tag) == 0xA300 || 
                                   Get16u(&ifde_ptr->tag) == 0xA301)
				{
					trace("\n------Start FileSource/SceneType------");

					memset(buffer, (int) NULL, 256);
					sprintf(buffer, "%x", Get32u(&ifde_ptr->value_offset)); 

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nvalue_offset: %x", Get32u(&ifde_ptr->value_offset)); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\ncount: %d", Get32u(&ifde_ptr->count)); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%x", Get32u(&ifde_ptr->value_offset)); 
					trace(trace_buffer);

					byte_ptr = &buffer[0];

					print_8bit_bytes(byte_ptr, Get32u(&ifde_ptr->count), local_ptr);
					trace("\n------End FileSource/SceneType------");

					break;
				}

				if(Get16u(&ifde_ptr->tag) == 0x000D ||
                                   Get16u(&ifde_ptr->tag) == 0x000E ||
                                   Get16u(&ifde_ptr->tag) == 0x0012 ||
                                   Get16u(&ifde_ptr->tag) == 0x0017 ||
                                   Get16u(&ifde_ptr->tag) == 0x0018 ||
                                   Get16u(&ifde_ptr->tag) == 0x0088 ||
                                   Get16u(&ifde_ptr->tag) == 0x008B ||
                                   Get16u(&ifde_ptr->tag) == 0x00A4 ||
                                   Get16u(&ifde_ptr->tag) == 0x9000 ||
                                   Get16u(&ifde_ptr->tag) == 0x9101 ||
                                   Get16u(&ifde_ptr->tag) == 0xA000 ||
                                   Get16u(&ifde_ptr->tag) == 0x0001)
				{
					trace("\n------Start print_16bit_hex Tags------");

					memset(buffer, (int) NULL, 256);
					sprintf(buffer, "%x", Get32u(&ifde_ptr->value_offset)); 

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nvalue_offset: %x", Get32u(&ifde_ptr->value_offset)); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\ncount: %d", Get32u(&ifde_ptr->count)); 
					trace(trace_buffer);

					byte_ptr = &buffer[0];

					print_16bit_hex(pad_field(byte_ptr, 2 * Get32u(&ifde_ptr->count), '0', 1),Get32u(&ifde_ptr->count), 2, local_ptr);
					trace("\n------End print_16bit_hex Tags------");

					break;
				}

				if(Get16u(&ifde_ptr->tag) == 0xA302 ||
                                   Get16u(&ifde_ptr->tag) == 0x008C ||
                                   Get16u(&ifde_ptr->tag) == 0x0091 ||
                                   Get16u(&ifde_ptr->tag) == 0x0096 ||
                                   Get16u(&ifde_ptr->tag) == 0x0097 ||
                                   Get16u(&ifde_ptr->tag) == 0x00A8 ||
                                   Get16u(&ifde_ptr->tag) == 0x0098)
				{
					trace("\n------Start print_8bit_hex Tags------");

					fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
					
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nvalue_offset: %x", Get32u(&ifde_ptr->value_offset)); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\noffset_base: %x", offset_base); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\ncount: %d", Get32u(&ifde_ptr->count)); 
					trace(trace_buffer);

					byte_ptr = (char *) my_malloc("byte_ptr", (Get32u(&ifde_ptr->count) + 1));
					memset(byte_ptr, (int) NULL, (Get32u(&ifde_ptr->count) + 1));

					fread(byte_ptr, Get32u(&ifde_ptr->count), 1, rfd);

					if(Get32u(&ifde_ptr->count) > 10)
						print_8bit_hex(byte_ptr, 10, local_ptr);
					else
						print_8bit_hex(byte_ptr, Get32u(&ifde_ptr->count), local_ptr);

					my_free("byte_ptr", byte_ptr);

					trace("\n------End print_8bit_hex Tags------");

					break;
				}

				if(Get16u(&ifde_ptr->tag) == 0x9286)
				{
					trace("\n------Start UserComment------");

					fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base + ASCII_LABEL_SKIP_LENGTH, 0);
					
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nvalue_offset: %x", Get32u(&ifde_ptr->value_offset)); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\noffset_base: %x", offset_base); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\ncount: %d", Get32u(&ifde_ptr->count)); 
					trace(trace_buffer);

					byte_ptr = (char *) my_malloc("byte_ptr", (Get32u(&ifde_ptr->count) + 1));
					memset(byte_ptr, (int) NULL, (Get32u(&ifde_ptr->count) + 1));

					fread(byte_ptr, Get32u(&ifde_ptr->count), 1, rfd);

					if(iTrace)
						printf("\nbyte_ptr: %s\n", byte_ptr);

					local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(byte_ptr) + 1));
					memset(local_ptr->Value, (int) NULL, (strlen(byte_ptr) + 1));
					strcpy(local_ptr->Value, byte_ptr);

					my_free("byte_ptr", byte_ptr);

					trace("\n------End UserComment------");

					break;
				}

				if(Get16u(&ifde_ptr->tag) == TAG_MAKER_NOTE)
				{
					if(!strncmp(upper_case(make_ptr), "NIKON", 5))
					{
						trace("\n------Start Maker Notes------");

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "%x", Get32u(&ifde_ptr->value_offset));
						local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(trace_buffer) + 1));
						memset(local_ptr->Value, (int) NULL, (strlen(trace_buffer) + 1));
						strcpy(local_ptr->Value, trace_buffer);

						//save file ptr
						temp_position = ftell(rfd);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nold_file_position: %x", temp_position);
						trace(trace_buffer);

						old_byte_order = MotorolaOrder;

						maker_note_header_offset = Get32u(&ifde_ptr->value_offset) + MAKER_NOTE_PRE_HEADER_LENGTH + jpg_type_offset();
						calc_maker_note_header_offset = maker_note_header_offset;

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nmaker_note_header_offset: %x", maker_note_header_offset);
						trace(trace_buffer);

						fseek(rfd, maker_note_header_offset, 0);

						memset(type_buffer, (int) NULL, 256);
						sprintf(type_buffer, "MAKER_NOTES");

						//call dump_.... with offset
						if(dump_image_file_directory(rfd, (maker_note_header_offset + inspect_image_file_header(rfd, 1)), maker_note_header_offset, get_new_data_header_ptr(), type_buffer))
							return(1);

						MotorolaOrder = old_byte_order;

						//restore file ptr
						fseek(rfd, temp_position, 0);
						trace("\n------End Maker Notes------");
					}

#ifdef CANON
					if(!strncmp(upper_case(make_ptr), "CANON", 5))
					{
						trace("\n------Start Maker Notes------");

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "%x", Get32u(&ifde_ptr->value_offset));
						local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(trace_buffer) + 1));
						memset(local_ptr->Value, (int) NULL, (strlen(trace_buffer) + 1));
						strcpy(local_ptr->Value, trace_buffer);

						//save file ptr
						temp_position = ftell(rfd);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nold_file_position: %x", temp_position);
						trace(trace_buffer);

						old_byte_order = MotorolaOrder;

						maker_note_header_offset = Get32u(&ifde_ptr->value_offset) + MAKER_NOTE_PRE_HEADER_LENGTH + 2;

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nmaker_note_header_offset: %x", maker_note_header_offset);
						trace(trace_buffer);

						fseek(rfd, maker_note_header_offset, 0);

						memset(type_buffer, (int) NULL, 256);
						sprintf(type_buffer, "MAKER_NOTES");

						//call dump_.... with offset
						if(dump_image_file_directory(rfd, (maker_note_header_offset /*+ inspect_image_file_header(rfd, 1)*/), maker_note_header_offset, get_new_data_header_ptr(), type_buffer))
							return(1);

						MotorolaOrder = old_byte_order;

						//restore file ptr
						fseek(rfd, temp_position, 0);
						trace("\n------End Maker Notes------");
					}
#endif // CANON
				}

				break;
			default:
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nUnknown Format: %x", Get16u(&ifde_ptr->field_type));
				trace(trace_buffer);
				break;
		}

		local_ptr->next = (struct data_header *) my_malloc("local_ptr->next", sizeof(struct data_header));
		memset(local_ptr->next, (int) NULL, sizeof(struct data_header));
		local_ptr = local_ptr->next;
		memset(local_ptr, (int) NULL, sizeof(struct data_header));

		fseek(rfd, old_position, 0);
	}

	trace("\n-dump_image_file_directory");
	mtrace("\n-dump_image_file_directory");

	return(0);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
struct data_header_ptr * get_new_main_header_ptr()
{
	struct data_header_ptr *local_main_header_ptr = NULL;
	local_main_header_ptr = (struct data_header_ptr *) my_malloc("local_main_header_ptr", sizeof(struct data_header_ptr));
	memset(local_main_header_ptr, (int) NULL, sizeof(struct data_header_ptr));
	return(local_main_header_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
struct data_header * get_new_data_header_ptr()
{
	struct data_header *local_header_ptr = NULL;
	local_header_ptr = (struct data_header *) my_malloc("local_header_ptr", sizeof(struct data_header));
	memset(local_header_ptr, (int) NULL, sizeof(struct data_header));
	return(local_header_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
struct html_header * get_new_html_header_ptr()
{
	struct html_header *local_header_ptr = NULL;
	local_header_ptr = (struct html_header *) my_malloc("local_header_ptr", sizeof(struct html_header));
	memset(local_header_ptr, (int) NULL, sizeof(struct html_header));
	return(local_header_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
unsigned long inspect_image_file_header(FILE *rfd, int iType)
{
        char buffer[256];
        static unsigned char ExifHeader[] = "Exif\0\0";
	struct image_file_header *ifh_ptr = NULL;
	unsigned long offset_ifd = 0;

	struct jpg_indicator_header
	{
		unsigned char start;
		unsigned char soi;
		unsigned char pad;
		unsigned char exif_ind;
	};

	struct jpg_indicator_header *jpg_ind_hdr_ptr = NULL;

	trace("\n+inspect_image_file_header");
	mtrace("\n+inspect_image_file_header");

	if(iType)
	{
		ifh_ptr = (struct image_file_header *) my_malloc("ifh_ptr", sizeof(struct image_file_header));
		memset(ifh_ptr, (int) NULL, sizeof(struct image_file_header));

		if((fread(ifh_ptr, sizeof(struct image_file_header), 1, rfd)) != 0)
		{
			memset(buffer, (int) NULL, 256);
			memcpy(buffer, ifh_ptr->byte_order, 2);
	
			if(!strncmp(buffer, "MM", 2))
				MotorolaOrder = 1;
			else
				MotorolaOrder = 0;
	
			offset_ifd = Get32u(&ifh_ptr->offset_to_first_ifd);
	
			memset(trace_buffer, (int) NULL, 256);
			sprintf(trace_buffer, "\nByte Order: %s", buffer);
			trace(trace_buffer);
			memset(trace_buffer, (int) NULL, 256);
			sprintf(trace_buffer, "\nImage File Type: %x", Get16u(&ifh_ptr->image_file_type));
			trace(trace_buffer);
			memset(trace_buffer, (int) NULL, 256);
			sprintf(trace_buffer, "\nOffset To First IFD: %x", offset_ifd);
			trace(trace_buffer);
	
			if((!strncmp(buffer, "MM", 2)) && (Get16u(&ifh_ptr->image_file_type) == 42))
			{
			}
			else if((!strncmp(buffer, "II", 2)) && (Get16u(&ifh_ptr->image_file_type) == 42))
			{
			}
			else
			{
				printf("\nFile type is not NEF/Nikon RAW\n\n");
				exit(1);
			}
	
		}
		else
		{
			my_error(rfd);
		}

		my_free("ifh_ptr", ifh_ptr);
	}
	else
	{
		jpg_ind_hdr_ptr = (struct jpg_indicator_header *) my_malloc("jpg_ind_hdr_ptr", sizeof(struct jpg_indicator_header));
		memset(jpg_ind_hdr_ptr, (int) NULL, sizeof(struct jpg_indicator_header));

		if((fread(jpg_ind_hdr_ptr, sizeof(struct jpg_indicator_header), 1, rfd)) != 0)
		{
			if(jpg_ind_hdr_ptr->start != 0xff)
			{
				my_exit("First byte must be 0xFF");
			}

			if(jpg_ind_hdr_ptr->soi != 0xd8)
			{
				my_exit("Second byte must be 0xD8");
			}

			if(jpg_ind_hdr_ptr->pad != 0xff)
			{
				my_exit("Third byte must be 0xFF");
			}

			fseek(rfd, 0, 0);

			switch(jpg_ind_hdr_ptr->exif_ind)
			{
				case 0xe0:
					iJPG_Type = 0;
					fseek(rfd, 18, 0);
					offset_ifd = get_jpg_type_and_offset(rfd, jpg_type_offset());
					break;
				case 0xe1:
					iJPG_Type = 1;
					offset_ifd = get_jpg_type_and_offset(rfd, jpg_type_offset());
					break;
				default:
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "Fourth byte is unknown: %x", jpg_ind_hdr_ptr->exif_ind);
					my_exit(trace_buffer);
					break;
			}
		}

		my_free("jpg_ind_hdr_ptr", jpg_ind_hdr_ptr);
	}

	trace("\n-inspect_image_file_header");
	mtrace("\n-inspect_image_file_header");
	return(offset_ifd);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
unsigned long get_jpg_type_and_offset(FILE *rfd, unsigned long offset)
{
	char buffer[256];
	static unsigned char ExifHeader[] = "Exif\0\0";
	unsigned long offset_ifd = 0l;
	struct jpg_image_file_header *jpg_ifh_ptr = NULL;

	trace("\n+get_jpg_type_and_offset");
	mtrace("\n+get_jpg_type_and_offset");

	jpg_ifh_ptr = (struct jpg_image_file_header *) my_malloc("jpg_ifh_ptr", sizeof(struct jpg_image_file_header));
	memset(jpg_ifh_ptr, (int) NULL, sizeof(struct jpg_image_file_header));

	if((fread(jpg_ifh_ptr, sizeof(struct jpg_image_file_header), 1, rfd)) != 0)
	{
	        if (strncmp(jpg_ifh_ptr->exif_header_text, ExifHeader, 6))
		{
			my_exit("EXIF header text incorrect");
		}
			
		memset(buffer, (int) NULL, 256);
		memcpy(buffer, jpg_ifh_ptr->byte_order, 2);
				
		if(!strncmp(buffer, "MM", 2))
			MotorolaOrder = 1;
		else
			MotorolaOrder = 0;
				
		offset_ifd = Get32u(&jpg_ifh_ptr->offset_to_first_ifd) + offset;
				
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nByte Order: %s", buffer);
		trace(trace_buffer);
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nImage File Type: %x", Get16u(&jpg_ifh_ptr->image_file_type));
		trace(trace_buffer);
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nOffset To First IFD: %x", offset_ifd);
		trace(trace_buffer);

		if(iTrace)
		{
			printf("\nstart: %x", jpg_ifh_ptr->start);
			printf("\nsoi: %x", jpg_ifh_ptr->soi);
			printf("\npad: %x", jpg_ifh_ptr->pad);
			printf("\nexif_ind: %x", jpg_ifh_ptr->exif_ind);
			printf("\nlength: %x", jpg_ifh_ptr->length);
			printf("\nexif_header_text: %s", jpg_ifh_ptr->exif_header_text);
			printf("\nbyte_order: %s", jpg_ifh_ptr->byte_order);
			printf("\nimage_file_type: %x", jpg_ifh_ptr->image_file_type);
			printf("\noffset: %x\n", jpg_ifh_ptr->offset_to_first_ifd);
		}

		if((!strncmp(buffer, "MM", 2)) && (Get16u(&jpg_ifh_ptr->image_file_type) == 42))
		{
		}
		else if((!strncmp(buffer, "II", 2)) && (Get16u(&jpg_ifh_ptr->image_file_type) == 42))
		{
		}
		else
		{
			printf("\nFile type is not Nikon JPG\n\n");
			exit(1);
		}
				
	}
	else
	{
		my_error(rfd);
	}

	my_free("jpg_ifh_ptr", jpg_ifh_ptr);

	trace("\n-get_jpg_type_and_offset");
	mtrace("\n-get_jpg_type_and_offset");
	return(offset_ifd);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int jpg_type()
{
	return(iJPG_Type);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int jpg_type_offset()
{
	int iType = 0;

	switch(iJPG_Type)
	{
		case 0:
			iType = 30;
			break;
		case 1:
			iType = 12;
			break;
		case 99:
			iType = 0;
			break;
		default:
			iType = -1;
			break;
	}

	return(iType);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void display_data(struct data_header *local_ptr, char *data_type)
{
	int height = LARGE_IMAGE_HEIGHT;
	int width = LARGE_IMAGE_WIDTH;
	char buffer[256];

	while(local_ptr->next != NULL)
	{
		if(iTrace)
		{
			if(is_tag_printed((unsigned short) local_ptr->Tag))
			{
				switch(local_ptr->Tag)
				{
					case 0x829a:		// shutter speed

						if(atof(local_ptr->Value) <= 0.5)
							sprintf(buffer, "1/%d", (int) (0.5 + 1/atof(local_ptr->Value)));
						else
							sprintf(buffer, "%6.4f", (double) atof(local_ptr->Value));

						debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, buffer);
						break;
					case 0x9209:

						if(!strncmp(local_ptr->Value, "0", strlen("0")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "No Flash");
						}
						else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "1", strlen("1")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired");
						}
						else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "5", strlen("5")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Return not detected");
						}
						else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "7", strlen("7")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Return detected");
						}
						else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "9", strlen("9")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On");
						}
						else if(!strncmp(local_ptr->Value, "13", strlen("13")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "15", strlen("15")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Return detected");
						}
						else if(!strncmp(local_ptr->Value, "16", strlen("16")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Off");
						}
						else if(!strncmp(local_ptr->Value, "24", strlen("24")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Did not fire");
						}
						else if(!strncmp(local_ptr->Value, "25", strlen("25")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired");
						}
						else if(!strncmp(local_ptr->Value, "29", strlen("29")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "31", strlen("31")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Return detected");
						}
						else if(!strncmp(local_ptr->Value, "32", strlen("32")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "No flash function");
						}
						else if(!strncmp(local_ptr->Value, "65", strlen("65")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction");
						}
						else if(!strncmp(local_ptr->Value, "69", strlen("69")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "71", strlen("71")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction, Return detected");
						}
						else if(!strncmp(local_ptr->Value, "73", strlen("73")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction");
						}
						else if(!strncmp(local_ptr->Value, "77", strlen("77")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "79", strlen("79")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction, Return detected");
						}
						else if(!strncmp(local_ptr->Value, "89", strlen("89")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction");
						}
						else if(!strncmp(local_ptr->Value, "93", strlen("93")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "95", strlen("95")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return detected");
						}
						else
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0x8822:
						if(!strncmp(local_ptr->Value, "2", strlen("2")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Program AE");
						}
						else if(!strncmp(local_ptr->Value, "0", strlen("0")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto");
						}
						else if(!strncmp(local_ptr->Value, "4", strlen("4")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Shutter speed priority AE");
						}
						else if(!strncmp(local_ptr->Value, "3", strlen("3")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Aperture-priority AE");
						}
						else if(!strncmp(local_ptr->Value, "1", strlen("1")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Manual");
						}
						else
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0x9207:
						if(!strncmp(local_ptr->Value, "5", strlen("5")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Multi-segment");
						}
						else if(!strncmp(local_ptr->Value, "3", strlen("3")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Spot");
						}
						else if(!strncmp(local_ptr->Value, "2", strlen("2")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Center-weighted average");
						}
						else
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0xa002:
						debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0xa003:
						debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x0100:
						if(!strncmp(data_type, "IFD0", strlen("IFD0")))
							break;

						debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x0101:
						if(!strncmp(data_type, "IFD0", strlen("IFD0")))
							break;

						debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x0112:
//						if(!strncmp(data_type, "SUB_IFD1", strlen("SUB_IFD1")))
//						if(!strncmp(data_type, "IFD0", strlen("IFD0")))
						if(ulGlobalOrientation != 0)
							break;

						if(GlobalOrientationPtr != NULL)
							my_free("GlobalOrientationPtr", GlobalOrientationPtr);

						GlobalOrientationPtr = (char *) my_malloc("GlobalOrientationPtr", (strlen(local_ptr->Value) + 1));
						memset(GlobalOrientationPtr, (int) NULL, (strlen(local_ptr->Value) + 1));
						sprintf(GlobalOrientationPtr, "%s", local_ptr->Value);

						ulGlobalOrientation = (unsigned long) atoi(local_ptr->Value);

						if(!strncmp(local_ptr->Value, "1", strlen("1")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Horizontal (normal)");
						}
						else if(!strncmp(local_ptr->Value, "2", strlen("2")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal");
						}
						else if(!strncmp(local_ptr->Value, "3", strlen("3")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 180");
						}
						else if(!strncmp(local_ptr->Value, "4", strlen("4")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored vertical");
						}
						else if(!strncmp(local_ptr->Value, "5", strlen("5")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal then rotated 90 CCW");
						}
						else if(!strncmp(local_ptr->Value, "6", strlen("6")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 90 CW");
						}
						else if(!strncmp(local_ptr->Value, "7", strlen("7")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal then rotated 90 CW");
						}
						else if(!strncmp(local_ptr->Value, "8", strlen("8")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 90 CCW");
						}
						else
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0x0084:		// lens
						debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, convert_lens(local_ptr->Value));
						break;
					case 0x920a:		// FocalLength
						debug_printf("\n%#x: %s: %s mm", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, precision(local_ptr->Value)));
						break;
					case 0xa405:		// FocalLengthIn35mmFilm
						debug_printf("\n%#x: %s: %s mm", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x0083:
						if(!strncmp(local_ptr->Value, "2", strlen("2")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "D");
						}
						else if(!strncmp(local_ptr->Value, "6", strlen("6")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "G");
						}
						else if(!strncmp(local_ptr->Value, "e", strlen("e")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "G-VR");
						}
						else if(!strncmp(local_ptr->Value, "a", strlen("a")))
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "D-VR");
						}
						else
						{
							debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0x829d:
						debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, 3));
						break;
					case 0x0131:
						//software_ptr = (char *) my_malloc("software_ptr", (strlen(local_ptr->Value) + 1));
						//memset(software_ptr, (int) NULL, (strlen(local_ptr->Value) + 1));
						//strcpy(software_ptr, local_ptr->Value);

						debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x8827:
					case 0x010f:
					case 0x0110:
					case 0x9004:
					case 0x0002:
					case 0x0013:
					case 0x0004:
					case 0x0005:
					case 0x0006:
					case 0x00a7:
					case 0x0007:
					case 0x0008:
					case 0x0009:
					case 0x0081:
					case 0x008b:
					case 0x008d:
					case 0x0090:
					case 0x0095:
		//			case 0x00a0:
					case 0x00a9:
					case 0x00aa:
					case 0x00ab:
					case 0x9204:
					case 0x9286:
		//			case 0x010E:
					case 0xffff:
						debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					default:
						break;
				}	// end switch
			}		// end is_tag_printed
		}	// end if(iTrace)
		else	// not debug
		{
			if(is_tag_printed((unsigned short) local_ptr->Tag))
			{
				switch(local_ptr->Tag)
				{
					case 0x829a:		// shutter speed

						if(atof(local_ptr->Value) <= 0.5)
							sprintf(buffer, "1/%d", (int) (0.5 + 1/atof(local_ptr->Value)));
						else
							sprintf(buffer, "%6.4f", (double) atof(local_ptr->Value));

						my_printf("\n%s: %s seconds", local_ptr->Tag, local_ptr->Desc, buffer);
						break;
					case 0x9209:
						if(!strncmp(local_ptr->Value, "0", strlen("0")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "No Flash");
						}
						else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "1", strlen("1")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Fired");
						}
						else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "5", strlen("5")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Return not detected");
						}
						else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "7", strlen("7")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Return detected");
						}
						else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "9", strlen("9")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "On");
						}
						else if(!strncmp(local_ptr->Value, "13", strlen("13")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "On, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "15", strlen("15")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "On, Return detected");
						}
						else if(!strncmp(local_ptr->Value, "16", strlen("16")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Off");
						}
						else if(!strncmp(local_ptr->Value, "24", strlen("24")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Did not fire");
						}
						else if(!strncmp(local_ptr->Value, "25", strlen("25")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired");
						}
						else if(!strncmp(local_ptr->Value, "29", strlen("29")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "31", strlen("31")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Return detected");
						}
						else if(!strncmp(local_ptr->Value, "32", strlen("32")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "No flash function");
						}
						else if(!strncmp(local_ptr->Value, "65", strlen("65")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction");
						}
						else if(!strncmp(local_ptr->Value, "69", strlen("69")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "71", strlen("71")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction, Return detected");
						}
						else if(!strncmp(local_ptr->Value, "73", strlen("73")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction");
						}
						else if(!strncmp(local_ptr->Value, "77", strlen("77")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "79", strlen("79")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction, Return detected");
						}
						else if(!strncmp(local_ptr->Value, "89", strlen("89")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction");
						}
						else if(!strncmp(local_ptr->Value, "93", strlen("93")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return not detected");
						}
						else if(!strncmp(local_ptr->Value, "95", strlen("95")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return detected");
						}
						else
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0x8822:
						if(!strncmp(local_ptr->Value, "2", strlen("2")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Program AE");
						}
						else if(!strncmp(local_ptr->Value, "0", strlen("0")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Auto");
						}
						else if(!strncmp(local_ptr->Value, "4", strlen("4")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Shutter speed priority AE");
						}
						else if(!strncmp(local_ptr->Value, "3", strlen("3")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Aperture-priority AE");
						}
						else if(!strncmp(local_ptr->Value, "1", strlen("1")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Manual");
						}
						else
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0x9207:
						if(!strncmp(local_ptr->Value, "5", strlen("5")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Multi-segment");
						}
						else if(!strncmp(local_ptr->Value, "3", strlen("3")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Spot");
						}
						else if(!strncmp(local_ptr->Value, "2", strlen("2")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Center-weighted average");
						}
						else
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0xa002:
						my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0xa003:
						my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x0100:
						if(!strncmp(data_type, "IFD0", strlen("IFD0")))
							break;

						my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x0101:
						if(!strncmp(data_type, "IFD0", strlen("IFD0")))
							break;

						my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x0112:
//						if(!strncmp(data_type, "SUB_IFD1", strlen("SUB_IFD1")))
//						if(!strncmp(data_type, "IFD0", strlen("IFD0")))
						if(ulGlobalOrientation != 0)
							break;

						if(iTrace)
							printf("\nlocal_ptr->Value: %s", local_ptr->Value);

						if(GlobalOrientationPtr != NULL)
							my_free("GlobalOrientationPtr", GlobalOrientationPtr);

						GlobalOrientationPtr = (char *) my_malloc("GlobalOrientationPtr", (strlen(local_ptr->Value) + 1));
						memset(GlobalOrientationPtr, (int) NULL, (strlen(local_ptr->Value) + 1));
						sprintf(GlobalOrientationPtr, "%s", local_ptr->Value);

						ulGlobalOrientation = (unsigned long) atoi(local_ptr->Value);

						if(!strncmp(local_ptr->Value, "1", strlen("1")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Horizontal (normal)");
						}
						else if(!strncmp(local_ptr->Value, "2", strlen("2")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal");
						}
						else if(!strncmp(local_ptr->Value, "3", strlen("3")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 180");
						}
						else if(!strncmp(local_ptr->Value, "4", strlen("4")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored vertical");
						}
						else if(!strncmp(local_ptr->Value, "5", strlen("5")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal then rotated 90 CCW");
						}
						else if(!strncmp(local_ptr->Value, "6", strlen("6")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 90 CW");
						}
						else if(!strncmp(local_ptr->Value, "7", strlen("7")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal then rotated 90 CW");
						}
						else if(!strncmp(local_ptr->Value, "8", strlen("8")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 90 CCW");
						}
						else
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0x0084:		// lens
						my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, convert_lens(local_ptr->Value));
						break;
					case 0x920a:		// FocalLength
						my_printf("\n%s: %s mm", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, precision(local_ptr->Value)));
						break;
					case 0xa405:		// FocalLengthIn35mmFilm
						my_printf("\n%s: %s mm", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x0083:
						if(!strncmp(local_ptr->Value, "2", strlen("2")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "D");
						}
						else if(!strncmp(local_ptr->Value, "6", strlen("6")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "G");
						}
						else if(!strncmp(local_ptr->Value, "e", strlen("e")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "G-VR");
						}
						else if(!strncmp(local_ptr->Value, "a", strlen("a")))
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, "D-VR");
						}
						else
						{
							my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
						break;
					case 0x829d:
						my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, 3));
						break;
					case 0x0131:
						//software_ptr = (char *) my_malloc("software_ptr", (strlen(local_ptr->Value) + 1));
						//memset(software_ptr, (int) NULL, (strlen(local_ptr->Value) + 1));
						//strcpy(software_ptr, local_ptr->Value);

						my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					case 0x8827:
					case 0x010f:
					case 0x0110:
					case 0x9004:
					case 0x0002:
					case 0x0013:
					case 0x0004:
					case 0x0005:
					case 0x0006:
					case 0x00a7:
					case 0x0007:
					case 0x0008:
					case 0x0009:
					case 0x0081:
					case 0x008b:
					case 0x008d:
					case 0x0090:
					case 0x0095:
		//			case 0x00a0:
					case 0x00a9:
					case 0x00aa:
					case 0x00ab:
					case 0x9204:
					case 0x9286:
		//			case 0x010E:
					case 0xffff:
						my_printf("\n%s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						break;
					default:
						break;
				}	// end switch
			}	// end is_tag_printed
		}

		local_ptr = local_ptr->next;
	}
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char * convert_lens(char *str_lens)
{
	char *temp_ptr = NULL;
	char *final_ptr = "lens";
	char *token1 = NULL;
	char *token2 = NULL;
	char *token3 = NULL;
	char *token4 = NULL;
	char buffer[256];

	trace("\n+convert_lens");
	mtrace("\n+convert_lens");

	memset(buffer, (int) NULL, 256);

	temp_ptr = strdup(str_lens);

	token1 = strtok(temp_ptr, " ");
	token2 = strtok(NULL, " ");
	token3 = strtok(NULL, " ");
	token4 = strtok(NULL, " ");

	if((!strcmp(token1, token2)) && (!strcmp(token3, token4)))
	{
		sprintf(buffer, "%s mm f/%s", truncate(token1, precision(token1)), truncate(token3, 2));
	}
	else
	{
		if(!strcmp(token3, token4))
			sprintf(buffer, "%s-%s mm f/%s", truncate(token1, precision(token1)), truncate(token2, 0), truncate(token3, 2));
		else
			sprintf(buffer, "%s-%s mm f/%s-%s", truncate(token1, precision(token1)), truncate(token2, 0), truncate(token3, 2), truncate(token4, 2));
	}

	temp_ptr = (char *) my_malloc("temp_ptr", (strlen(buffer) + 1));
	memset(temp_ptr, (int) NULL, (strlen(buffer) + 1));
	strcpy(temp_ptr, buffer);

	final_ptr = strdup(temp_ptr);

	my_free("temp_ptr", temp_ptr);

	trace("\n-convert_lens");
	mtrace("\n-convert_lens");
	return(final_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char *truncate(char *str_token, int dec_len)
{
	char *temp_ptr = NULL;
	char *char_ptr = NULL;

	temp_ptr = strdup(str_token);

	char_ptr = strchr(temp_ptr, '.');

	char_ptr += dec_len;

	*char_ptr = (char) NULL;
	
	return(temp_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void debug_printf(char *str_format, unsigned short us_tag, char *str_desc, char *str_value)
{
	if(html_header_ptr == NULL)
	{
		html_header_ptr = get_new_html_header_ptr();

		html_header_ptr->Desc = (char *) my_malloc("html_header_ptr->Desc", (strlen(str_desc) + 1));
		memset(html_header_ptr->Desc, (int) NULL, (strlen(str_desc) + 1));
		strncpy(html_header_ptr->Desc, str_desc, strlen(str_desc));

		html_header_ptr->Value = (char *) my_malloc("html_header_ptr->Value", (strlen(str_value) + 1));
		memset(html_header_ptr->Value, (int) NULL, (strlen(str_value) + 1));
		strncpy(html_header_ptr->Value, str_value, strlen(str_value));

		html_header_ptr->Tag = us_tag;

		html_header_start_ptr = html_header_ptr;
	}
	else
	{
		html_header_ptr->next = get_new_html_header_ptr();
		html_header_ptr =  html_header_ptr->next;

		html_header_ptr->Desc = (char *) my_malloc("html_header_ptr->Desc", (strlen(str_desc) + 1));
		memset(html_header_ptr->Desc, (int) NULL, (strlen(str_desc) + 1));
		strncpy(html_header_ptr->Desc, str_desc, strlen(str_desc));

		html_header_ptr->Value = (char *) my_malloc("html_header_ptr->Value", (strlen(str_value) + 1));
		memset(html_header_ptr->Value, (int) NULL, (strlen(str_value) + 1));
		strncpy(html_header_ptr->Value, str_value, strlen(str_value));

		html_header_ptr->Tag = us_tag;
	}

	if((!iHtml) && (!iXml) && (!iCsv) && (!iJS) && (!iWeb))
		printf(str_format, us_tag, str_desc, str_value);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void my_printf(char *str_format, unsigned short us_tag, char *str_desc, char *str_value)
{
	if(html_header_ptr == NULL)
	{
		html_header_ptr = get_new_html_header_ptr();

		html_header_ptr->Desc = (char *) my_malloc("html_header_ptr->Desc", (strlen(str_desc) + 1));
		memset(html_header_ptr->Desc, (int) NULL, (strlen(str_desc) + 1));
		strncpy(html_header_ptr->Desc, str_desc, strlen(str_desc));

		html_header_ptr->Value = (char *) my_malloc("html_header_ptr->Value", (strlen(str_value) + 1));
		memset(html_header_ptr->Value, (int) NULL, (strlen(str_value) + 1));
		strncpy(html_header_ptr->Value, str_value, strlen(str_value));

		html_header_ptr->Tag = us_tag;

		html_header_start_ptr = html_header_ptr;
	}
	else
	{
		html_header_ptr->next = get_new_html_header_ptr();
		html_header_ptr =  html_header_ptr->next;

		html_header_ptr->Desc = (char *) my_malloc("html_header_ptr->Desc", (strlen(str_desc) + 1));
		memset(html_header_ptr->Desc, (int) NULL, (strlen(str_desc) + 1));
		strncpy(html_header_ptr->Desc, str_desc, strlen(str_desc));

		html_header_ptr->Value = (char *) my_malloc("html_header_ptr->Value", (strlen(str_value) + 1));
		memset(html_header_ptr->Value, (int) NULL, (strlen(str_value) + 1));
		strncpy(html_header_ptr->Value, str_value, strlen(str_value));

		html_header_ptr->Tag = us_tag;
	}

	if((!iHtml) && (!iXml) && (!iCsv) && (!iJS) && (!iWeb))
		printf(str_format, str_desc, str_value);
}

//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void extract_and_format_data(struct image_file_directory_entry *ifde_ptr, struct data_header *local_ptr, int iHex)
{
	int ibyte_count = 0;
	unsigned int ubyte1 = 0;
	unsigned int ubyte2 = 0;
	unsigned int ubyte3 = 0;
	unsigned int ubyte4 = 0;
	unsigned int ubyte5 = 0;
	unsigned int ubyte6 = 0;
	unsigned long ulong = 0l;

	trace("\n+extract_and_format_data");
	mtrace("\n+extract_and_format_data");

	ulong = Get32u(&ifde_ptr->value_offset);

	ubyte1 = (ulong & 0xff000000) >> 24;
	ubyte2 = (ulong & 0x00ff0000) >> 16;
	ubyte3 = (ulong & 0x0000ff00) >> 8;
	ubyte4 = (ulong & 0x000000ff) >> 0;
	ubyte5 = (ulong & 0xffff0000) >> 16;
	ubyte6 = (ulong & 0x0000ffff) >> 0;

/*
	if(iTrace)
	{
		if (MotorolaOrder)
			printf("\nMM\n");
		else
			printf("\nII\n");

		printf("\ntag: %x\n", Get16u(&ifde_ptr->tag));
		printf("field_type: %d\n", Get16u(&ifde_ptr->field_type));
		printf("count: %d\n", Get32u(&ifde_ptr->count));
		printf("value_offset: %x\n", Get32u(&ifde_ptr->value_offset));
		printf("value_offset(no-Get32u): %x\n", ifde_ptr->value_offset);

		printf("\nulong: %x\n", ulong);
		printf("ubyte1: %x\n", ubyte1);
		printf("ubyte2: %x\n", ubyte2);
		printf("ubyte3: %x\n", ubyte3);
		printf("ubyte4: %x\n", ubyte4);
		printf("ubyte5: %x\n", ubyte5);
		printf("ubyte6: %x\n\n", ubyte6);
	}
*/

	memset(trace_buffer, (int) NULL, 256);

	switch(Get16u(&ifde_ptr->field_type))
	{
		case 1:
			ibyte_count = Get32u(&ifde_ptr->count) * 1;

			if(MotorolaOrder)
			{
				if(ibyte_count == 1)
				{
					sprintf(trace_buffer, "%x", ubyte1);
				}
				else if(ibyte_count == 2)
				{
					sprintf(trace_buffer, "%x %x", ubyte1, ubyte2);
				}
				else if(ibyte_count == 3)
				{
					sprintf(trace_buffer, "%x %x %x", ubyte1, ubyte2, ubyte3);
				}
				else if(ibyte_count == 4)
				{
					sprintf(trace_buffer, "%x %x %x %x", ubyte1, ubyte2, ubyte3, ubyte4);
				}
			}
			else
			{
				if(ibyte_count == 1)
				{
					sprintf(trace_buffer, "%x", ubyte4);
				}
				else if(ibyte_count == 2)
				{
					sprintf(trace_buffer, "%x %x", ubyte4, ubyte3);
				}
				else if(ibyte_count == 3)
				{
					sprintf(trace_buffer, "%x %x %x", ubyte4, ubyte3, ubyte2);
				}
				else if(ibyte_count == 4)
				{
					sprintf(trace_buffer, "%x %x %x %x", ubyte4, ubyte3, ubyte2, ubyte1);
				}
			}
			break;
		case 2:
			ibyte_count = Get32u(&ifde_ptr->count) * 1;

			if(ibyte_count == 1)
			{
				sprintf(trace_buffer, "%c", ubyte1);
			}
			else if(ibyte_count == 2)
			{
				sprintf(trace_buffer, "%c%c", ubyte1, ubyte2);
			}
			else if(ibyte_count == 3)
			{
				if(MotorolaOrder)
					sprintf(trace_buffer, "%c%c%c", ubyte1, ubyte2, ubyte3);
				else
					sprintf(trace_buffer, "%c%c%c", ubyte4, ubyte3, ubyte2);
			}
			else if(ibyte_count == 4)
			{
				sprintf(trace_buffer, "%c%c%c%c", ubyte1, ubyte2, ubyte3, ubyte4);
			}
			break;
		case 6:
			ibyte_count = Get32u(&ifde_ptr->count) * 1;

			if(ibyte_count == 1)
			{
				sprintf(trace_buffer, "%d", ubyte1);
			}
			else if(ibyte_count == 2)
			{
				sprintf(trace_buffer, "%d %d", ubyte1, ubyte2);
			}
			else if(ibyte_count == 3)
			{
				sprintf(trace_buffer, "%d %d %d", ubyte1, ubyte2, ubyte3);
			}
			else if(ibyte_count == 4)
			{
				sprintf(trace_buffer, "%d %d %d %d", ubyte1, ubyte2, ubyte3, ubyte4);
			}
			break;
		case 3:
		case 8:
			ibyte_count = Get32u(&ifde_ptr->count) * 2;

			if((Get16u(&ifde_ptr->tag) == 0x0002) || (Get16u(&ifde_ptr->tag) == 0x0013))
			{
				if(ubyte6 != 0)
					sprintf(trace_buffer, "%d", ubyte6);
				else
					sprintf(trace_buffer, "%d", ubyte5);
			}
			else
			{
				if(ibyte_count == 2)
				{
					if(MotorolaOrder)
						sprintf(trace_buffer, "%d", ubyte5);
					else
						sprintf(trace_buffer, "%d", ubyte6);
				}
				else if(ibyte_count == 4)
				{
					sprintf(trace_buffer, "%d %d", ubyte5, ubyte6);
				}
			}
			break;
		case 4:
		case 9:
			ibyte_count = Get32u(&ifde_ptr->count) * 4;
			sprintf(trace_buffer, "%ld", ulong);
			break;
		default:
			my_exit("Unknown Field Type");
			break;
	}

    local_ptr->Value = (char *) my_malloc("local_ptr->Value", (strlen(trace_buffer) + 1));
    memset(local_ptr->Value, (int) NULL, (strlen(trace_buffer) + 1));
    strcpy(local_ptr->Value, trace_buffer);

	if(iTrace)
		printf("\nValue Stored: %s", trace_buffer);

	trace("\n-extract_and_format_data");
	mtrace("\n-extract_and_format_data");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void dump_jpg_image_file_directory(FILE *rfd, unsigned long offset_ifd, unsigned long offset_base, char *type_ptr)
{
	char *buff_ptr = NULL;
	char buffer[256];
	char type_buffer[256];
	struct image_file_directory_entry *ifde_ptr = NULL;
	unsigned short count = 0;
	unsigned short num_ifd = 0;
	unsigned int ubyte5 = 0l;
	unsigned long ulong = 0l;
	unsigned long ctr1 = 0l;
	unsigned long ctr3 = 0l;
	long old_position = 0l;
	long temp_position = 0l;
	int ByteCount = 0;
	unsigned long components = 0l;      		//count
	unsigned long value_offset = 0l;     	//value offset
	unsigned char *byte_ptr = NULL;
	unsigned long *long_byte_ptr = NULL;

	unsigned long maker_note_header_offset = 0l;
	unsigned long ulLocalPosition = 0l;

	trace("\n+dump_jpg_image_file_directory");
	mtrace("\n+dump_jpg_image_file_directory");

	if(iTrace)
		printf("\ntype_ptr: %s", type_ptr);

	ifde_ptr = (struct image_file_directory_entry *) my_malloc("ifde_ptr", sizeof(struct image_file_directory_entry));
	memset(ifde_ptr, (int) NULL, sizeof(struct image_file_directory_entry));

	if(fseek(rfd, offset_ifd, 0) != -1)
	{
		fread(&count, sizeof(unsigned short), 1, rfd);
		num_ifd = Get16u(&count);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nNumber of Image File Directories: %d", num_ifd);
		trace(trace_buffer);
	}
	else
	{
		my_error(rfd);
	}

	for(ctr1 = 0; ctr1 < num_ifd; ctr1++)
	{
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nctr1: %d", ctr1);
		trace(trace_buffer);

		memset(ifde_ptr, (int) NULL, sizeof(struct image_file_directory_entry));
		fread(ifde_ptr, sizeof(struct image_file_directory_entry), 1, rfd);

		ulLocalPosition = ftell(rfd);

		if(ulLocalPosition > ulGlobalPosition)
			ulGlobalPosition = ulLocalPosition;

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\ntag: %x", Get16u(&ifde_ptr->tag));
		trace(trace_buffer);

		jpg_header_ptr->tag = Get16u(&ifde_ptr->tag);
		jpg_header_ptr->field_type = Get16u(&ifde_ptr->field_type);
		jpg_header_ptr->count = Get32u(&ifde_ptr->count);
		jpg_header_ptr->value_offset = Get32u(&ifde_ptr->value_offset);

		if(!strncmp(type_ptr, "IFD0", 4))
			jpg_header_ptr->record_type = 1;
		else if(!strncmp(type_ptr, "SUB_IFD0", 8))
			jpg_header_ptr->record_type = 3;
		else if(!strncmp(type_ptr, "SUB_IFD1", 8))
			jpg_header_ptr->record_type = 4;
		else if(!strncmp(type_ptr, "EXIF", 4))
			jpg_header_ptr->record_type = 5;
		else if(!strncmp(type_ptr, "MAKER_NOTES", 11))
			jpg_header_ptr->record_type = 6;
		else if(!strncmp(type_ptr, "SUB_IFD2", 8))
			jpg_header_ptr->record_type = 7;
		else
			jpg_header_ptr->record_type = 99;

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nField Type: %x", Get16u(&ifde_ptr->field_type));
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nNumber of Values: %x", Get32u(&ifde_ptr->count));
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nValue Offset: %x", Get32u(&ifde_ptr->value_offset));
		trace(trace_buffer);

		components = Get32u(&ifde_ptr->count);
		value_offset = Get32u(&ifde_ptr->value_offset) + offset_base;

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\ncomponents: %d", components);
		trace(trace_buffer);

		old_position = ftell(rfd);

		switch(Get16u(&ifde_ptr->field_type))
		{
			case 1:
				ByteCount = components * 1;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;


				if (ByteCount > 4)
				{
					byte_ptr = (unsigned char *) my_malloc("byte_ptr", (ByteCount + 1));
					memset(byte_ptr, (int) NULL, (ByteCount + 1));
					fseek(rfd, Get32u(&ifde_ptr->value_offset), 0);
					fread(byte_ptr, ByteCount, 1, rfd);
					jpg_header_ptr->data_at_offset = byte_ptr;
				}

				break;
			case 2:
				ByteCount = components * 1;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				if (ByteCount > 4)
				{
					byte_ptr = (unsigned char *) my_malloc("byte_ptr", (ByteCount + 1));
					memset(byte_ptr, (int) NULL, (ByteCount + 1));
					fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
					fread(byte_ptr, ByteCount, 1, rfd);
					jpg_header_ptr->data_at_offset = byte_ptr;

					if(Get16u(&ifde_ptr->tag) == 0x10F)
					{
						make_ptr = (char *) my_malloc("make_ptr", (components + 1));
						memset(make_ptr, (int) NULL, (components + 1));
						strcpy(make_ptr, byte_ptr);
					}

					if(Get16u(&ifde_ptr->tag) == 0x110)
					{
						model_ptr = (char *) my_malloc("model_ptr", (components + 1));
						memset(model_ptr, (int) NULL, (components + 1));
						strcpy(model_ptr, byte_ptr);
					}

					if(Get16u(&ifde_ptr->tag) == 0x131)
					{
						software_ptr = (char *) my_malloc("software_ptr", (components + 1));
						memset(software_ptr, (int) NULL, (components + 1));
						strcpy(software_ptr, byte_ptr);
					}
				}

				break;
			case 3:
			case 8:
				ByteCount = components * 2;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				if(jpg_header_ptr->tag == 0x112)
				{
					ulong = jpg_header_ptr->value_offset;

					if(MotorolaOrder)
						ubyte5 = (ulong & 0xffff0000) >> 16;
					else
						ubyte5 = ulong;

					ulGlobalOrientation = ubyte5;
				}

				if (ByteCount > 4)
				{
					byte_ptr = (unsigned char *) my_malloc("byte_ptr", (ByteCount + 1));
					memset(byte_ptr, (int) NULL, (ByteCount + 1));
					fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
					fread(byte_ptr, ByteCount, 1, rfd);
					jpg_header_ptr->data_at_offset = byte_ptr;
				}

				break;
			case 4:
				ByteCount = components * 4;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				if (ByteCount > 4)
				{
					if(Get16u(&ifde_ptr->tag) == TAG_SUBIFD_S)
					{
						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nValue Offset: %x", Get32u(&ifde_ptr->value_offset));
						trace(trace_buffer);

						my_fseek(rfd, Get32u(&ifde_ptr->value_offset), 0);
						temp_position = ftell(rfd);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
						trace(trace_buffer);

						for(ctr3 = 0; ctr3 < components; ctr3++)
						{
							long_byte_ptr = (unsigned long *) my_malloc("long_byte_ptr", sizeof(unsigned long));
							*long_byte_ptr = 0;
							memset(buffer, (int) NULL, 256);
							fread(long_byte_ptr, sizeof(unsigned long), 1, rfd);
							sprintf(buffer, "%-04.4x", Get32u(long_byte_ptr));

							trace("\n------Start SubIFD------");

							//save file ptr
							temp_position = ftell(rfd);
		
							memset(trace_buffer, (int) NULL, 256);
							sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
							trace(trace_buffer);

							memset(trace_buffer, (int) NULL, 256);
							sprintf(trace_buffer, "\noffset to count: %x", (Get32u(long_byte_ptr)));
							trace(trace_buffer);

							memset(type_buffer, (int) NULL, 256);
							sprintf(type_buffer, "SUB_IFD%d", ctr3);

							ul_sub_ifd_array[ctr3] = Get32u(long_byte_ptr);

							if(iTrace)
							{
								printf("\nlong_byte_ptr: %x", Get32u(long_byte_ptr));
								printf("\nul_sub_ifd_array[%d]: %x", ctr3, ul_sub_ifd_array[ctr3]);
							}

							dump_jpg_image_file_directory(rfd, (Get32u(long_byte_ptr)), 0, type_buffer);
		
							//restore file ptr
							fseek(rfd, temp_position, 0);
							
							my_free("long_byte_ptr", long_byte_ptr);
							trace("\n------End SubIFD------");
						}

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nget33u_long_byte_ptr: %x", Get32u(long_byte_ptr));
						trace(trace_buffer);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nbuffer: %s", buffer);
						trace(trace_buffer);
	
						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nlong_byte_ptr: %x", *long_byte_ptr);
						trace(trace_buffer);

						//my_free("long_byte_ptr", long_byte_ptr);
					}
					else
					{
						byte_ptr = (unsigned char *) my_malloc("byte_ptr", (ByteCount + 1));
						memset(byte_ptr, (int) NULL, (ByteCount + 1));
						fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
						fread(byte_ptr, ByteCount, 1, rfd);
						jpg_header_ptr->data_at_offset = byte_ptr;
					}
				}
				else
				{
					if(Get16u(&ifde_ptr->tag) == TAG_THUMBNAIL_IFD)
					{
						tag_thumbnail_ifd_offset = Get32u(&ifde_ptr->value_offset) + calc_maker_note_header_offset;

						if(!strncmp(upper_case(model_ptr), "NIKON D100", strlen("NIKON D100")) ||
						   !strncmp(upper_case(model_ptr), "NIKON D2H", strlen("NIKON D2H")))
						{
							trace("\n------Start TAG_THUMBNAIL_IFD------");
							//save file ptr
							temp_position = ftell(rfd);

							memset(trace_buffer, (int) NULL, 256);
							sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
							trace(trace_buffer);

							memset(type_buffer, (int) NULL, 256);
							sprintf(type_buffer, "THUMBNAIL");

							//call dump_.... with offset - Why not JPG version of this? - JON JON JON
							dump_image_file_directory(rfd, Get32u(&ifde_ptr->value_offset) + calc_maker_note_header_offset, calc_maker_note_header_offset, get_new_data_header_ptr(), type_buffer);

							//restore file ptr
							fseek(rfd, temp_position, 0);
							trace("\n------End TAG_THUMBNAIL_IFD------");
						}
					}

					if(Get16u(&ifde_ptr->tag) == TAG_THUMBNAIL_OFFSET)
					{
						if(!strncmp(type_ptr, "SUB_IFD0", 8))
							tag_thumbnail_ifd_offset = Get32u(&ifde_ptr->value_offset) + calc_maker_note_header_offset; // JON JON JON

						lThumbnailOffset = Get32u(&ifde_ptr->value_offset);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nlThumbnailOffset: %ld", lThumbnailOffset);
						trace(trace_buffer);
					}

					if(Get16u(&ifde_ptr->tag) == TAG_THUMBNAIL_LENGTH)
					{
						lThumbnailLength = Get32u(&ifde_ptr->value_offset);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\nlThumbnailLength: %ld", lThumbnailLength);
						trace(trace_buffer);
					}

					if(Get16u(&ifde_ptr->tag) == TAG_EXIF_OFFSET)
					{
						trace("\n------Start EXIF------");
						//save file ptr
						temp_position = ftell(rfd);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "\ntemp_position: %x", temp_position);
						trace(trace_buffer);

						memset(type_buffer, (int) NULL, 256);
						sprintf(type_buffer, "EXIF");

						//call dump_.... with offset
						dump_jpg_image_file_directory(rfd, Get32u(&ifde_ptr->value_offset) + jpg_type_offset(), jpg_type_offset(), type_buffer);

						//restore file ptr
						fseek(rfd, temp_position, 0);
						trace("\n------End EXIF------");
					}
				}
				break;
			case 5:
				ByteCount = components * 8;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				byte_ptr = (unsigned char *) my_malloc("byte_ptr", (ByteCount + 1));
				memset(byte_ptr, (int) NULL, (ByteCount + 1));
				memset(byte_ptr, (int) 0xFF, ByteCount);
				fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
				fread(byte_ptr, ByteCount, 1, rfd);
				jpg_header_ptr->data_at_offset = byte_ptr;

				if(jpg_header_ptr->record_type == 1)
				{
					if(Get16u(&ifde_ptr->tag) == 0x11a)
					{
						ul_global_XResolution_offset = ifde_ptr->value_offset;
					}

					if(Get16u(&ifde_ptr->tag) == 0x11b)
					{
						ul_global_YResolution_offset = ifde_ptr->value_offset;
					}
				}

				break;
			case 10:
				ByteCount = components * 8;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				byte_ptr = (unsigned char *) my_malloc("byte_ptr", (ByteCount + 1));
				memset(byte_ptr, (int) NULL, (ByteCount + 1));
				fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
				fread(byte_ptr, ByteCount, 1, rfd);
				jpg_header_ptr->data_at_offset = byte_ptr;

				break;
			case 7:
				ByteCount = components * 1;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nByteCount: %d", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				byte_ptr = (unsigned char *) my_malloc("byte_ptr", (ByteCount + 1));
				memset(byte_ptr, (int) NULL, (ByteCount + 1));
				fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
				fread(byte_ptr, ByteCount, 1, rfd);
				jpg_header_ptr->data_at_offset = byte_ptr;

				if(Get16u(&ifde_ptr->tag) == TAG_MAKER_NOTE)
				{
					trace("\n------Start Maker Notes------");

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%x", Get32u(&ifde_ptr->value_offset));

					//save file ptr
					temp_position = ftell(rfd);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nold_file_position: %x", temp_position);
					trace(trace_buffer);

					old_byte_order = MotorolaOrder;

					maker_note_header_offset = Get32u(&ifde_ptr->value_offset) + MAKER_NOTE_PRE_HEADER_LENGTH + jpg_type_offset();
					calc_maker_note_header_offset = maker_note_header_offset;

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nmaker_note_header_offset: %x", maker_note_header_offset);
					trace(trace_buffer);

					fseek(rfd, maker_note_header_offset, 0);

					memset(type_buffer, (int) NULL, 256);
					sprintf(type_buffer, "MAKER_NOTES");

					//call dump_.... with offset
					dump_jpg_image_file_directory(rfd, (maker_note_header_offset + inspect_image_file_header(rfd, 1)), maker_note_header_offset, type_buffer);

					MotorolaOrder = old_byte_order;

					//restore file ptr
					fseek(rfd, temp_position, 0);
					trace("\n------End Maker Notes------");
				}

				break;
			default:
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "\nUnknown Format: %x", Get16u(&ifde_ptr->field_type));
				trace(trace_buffer);
				break;
		}

		jpg_header_ptr->next = (struct jpg_data_header *) my_malloc("jpg_header_ptr->next", sizeof(struct jpg_data_header));
		memset(jpg_header_ptr->next, (int) NULL, sizeof(struct jpg_data_header));
		jpg_header_ptr = jpg_header_ptr->next;
		memset(jpg_header_ptr, (int) NULL, sizeof(struct jpg_data_header));
		iTagCount++;

		fseek(rfd, old_position, 0);
	}

	trace("\n-dump_jpg_image_file_directory");
	mtrace("\n-dump_jpg_image_file_directory");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
struct jpg_data_header * get_new_jpg_data_header_ptr()
{
	struct jpg_data_header *local_header_ptr = NULL;
	local_header_ptr = (struct jpg_data_header *) my_malloc("local_header_ptr", sizeof(struct jpg_data_header));
	memset(local_header_ptr, (int) NULL, sizeof(struct jpg_data_header));
	return(local_header_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
unsigned short count_tags(struct jpg_data_header *local_ptr)
{
	unsigned short tag_count = 0;

	while(local_ptr->next != NULL)
	{
		switch(local_ptr->tag)
		{
			case 0x0100:
			case 0x0101:
			case 0x0112:
				if(local_ptr->record_type == 1)
					break;
			case 0x829a:
			case 0x9209:
			case 0x8822:
			case 0x9207:
			case 0x0084:
			case 0x920a:
			case 0xa405:
			case 0x0083:
			case 0x8827:
			case 0x010f:
			case 0x0110:
			case 0x0131:
			case 0x9004:
			case 0x829d:
			case 0x0002:
			case 0x0013:
			case 0x0004:
			case 0x0005:
			case 0x0006:
			case 0x00a7:
			case 0x0007:
			case 0x0008:
			case 0x0009:
			case 0x0081:
			case 0x008b:
			case 0x008d:
			case 0x0090:
			case 0x0095:
			case 0x00a9:
			case 0x00aa:
			case 0x00ab:
			case 0xa002:
			case 0xa003:
			case 0x9204:
			case 0x9286:
				tag_count++;
				break;
			default:
				break;
		}

		local_ptr = local_ptr->next;
	}

	return(tag_count);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_thumbnail_old(char *filename, FILE *rfd)
{
	FILE *ofd = NULL;
	char buffer[256];
	unsigned long size = 0l;
	unsigned char *byte_ptr = NULL;
	unsigned char *file_ptr = NULL;
	unsigned char *file_tmp_ptr = NULL;

	char *local_argv[10];

	struct image_file_directory_entry ifde;

	struct exif_header
	{
		unsigned char ff;
		unsigned char soi;
		unsigned char pad;
		unsigned char marker;
		unsigned short length;
		unsigned char exif[6];
		unsigned char byte_order[2];
		unsigned short flag;
		unsigned int offset;
		unsigned short dir_count;
	};

	struct type5
	{
		unsigned long numerator;
		unsigned long denominator;
	};

	struct type5 *type5_ptr;

	struct lens
	{
		struct type5 field_1;
		struct type5 field_2;
		struct type5 field_3;
		struct type5 field_4;
	};

	struct lens *lens_ptr;

	struct exif_header *exif_header_ptr = NULL;
	struct jpg_data_header *temp_start_ptr = NULL;
	unsigned char *dir_buffer_ptr = NULL;
	unsigned char *temp_dir_buffer_ptr = NULL;
	unsigned char *data_buffer_ptr = NULL;
	unsigned char *temp_data_buffer_ptr = NULL;

	unsigned short dir_count = 0;
	int iStructSize = 0;
	unsigned int data_offset = 0;
	unsigned short short_length = 0;
	unsigned int ubyte1;
	unsigned int ubyte5;
	unsigned long ulong;
	unsigned long ulOrientation;
	int iSpecialSoftware = 0;

	trace("\n+output_thumbnail");
	mtrace("\n+output_thumbnail");

	if(strlen(software_ptr) >= strlen("Nikon Capture"))
	{
		if(!strncmp(software_ptr, "Nikon Capture", strlen("Nikon Capture")))
			iSpecialSoftware = 1;
		else
			iSpecialSoftware = 0;
	}
	else
		iSpecialSoftware = 0;

	if(!iSpecialSoftware)
	{
		exif_header_ptr = (struct exif_header *) my_malloc("exif_header_ptr", sizeof(struct exif_header));
		memset(exif_header_ptr, (int) 0xFF, sizeof(struct exif_header));
		iStructSize = sizeof(struct exif_header);

		exif_header_ptr->ff = 0xFF;
		exif_header_ptr->soi = 0xD8;
		exif_header_ptr->pad = 0xFF;
		exif_header_ptr->marker = 0xE1;
		exif_header_ptr->length = 0x00;		//set this later
		memcpy(exif_header_ptr->exif,"Exif\0\0", 6);
		memcpy(exif_header_ptr->byte_order,"II", 2);
		exif_header_ptr->flag = 0x002A;
		exif_header_ptr->offset = 0x0008;

		temp_start_ptr = start_header_ptr;

		dir_count += count_tags(temp_start_ptr);

		if(iTrace)
		{
			printf("\nfilename: %s\n", filename);
			printf("\ndir_count: %d", dir_count);
			printf("\niTagCount: %d", iTagCount);
		}

		exif_header_ptr->dir_count = dir_count;

		dir_buffer_ptr = (unsigned char *) my_malloc("dir_buffer_ptr", (12 * dir_count) + 4);
		memset(dir_buffer_ptr, (int) NULL, (12 * dir_count) + 4);
		temp_dir_buffer_ptr = dir_buffer_ptr;
		data_buffer_ptr = (unsigned char *) my_malloc("data_buffer_ptr", 1024);
		memset(data_buffer_ptr, (int) NULL, 1024);

		data_offset = sizeof(struct exif_header) + ((12 * dir_count) + 4) - 14;

		memset(dir_buffer_ptr, (int) NULL, ((12 * dir_count) + 4));
		memset(data_buffer_ptr, (int) NULL, 1024);

		short_length = ((12 * dir_count) + 4) + sizeof(struct exif_header) + 1024 - 6;
		exif_header_ptr->length = Get16u(&short_length);

		temp_data_buffer_ptr = data_buffer_ptr;

		temp_start_ptr = start_header_ptr;

		while(temp_start_ptr->next != NULL)
		{
			switch(temp_start_ptr->tag)
			{
				case 0x0100:
				case 0x0101:
				case 0x0112:
					if(temp_start_ptr->record_type == 1)
						break;
				case 0x829a:
				case 0x9209:
				case 0x8822:
				case 0x9207:
				case 0x0084:
				case 0x920a:
				case 0xa405:
				case 0x0083:
				case 0x8827:
				case 0x010f:
				case 0x0110:
				case 0x0131:
				case 0x9004:
				case 0x829d:
				case 0x0002:
				case 0x0013:
				case 0x0004:
				case 0x0005:
				case 0x0006:
				case 0x00a7:
				case 0x0007:
				case 0x0008:
				case 0x0009:
				case 0x0081:
				case 0x008b:
				case 0x008d:
				case 0x0090:
				case 0x0095:
				case 0x00a9:
				case 0x00aa:
				case 0x00ab:
				case 0xa002:
				case 0xa003:
				case 0x9204:
				case 0x9286:
					if(iTrace)
					{
						printf("tag: %x\n", temp_start_ptr->tag);
						printf("Field_type: %d\n", temp_start_ptr->field_type);
						printf("count: %d\n", temp_start_ptr->count);
						printf("value_offset: %x\n", temp_start_ptr->value_offset);
						printf("record_type: %d\n", temp_start_ptr->record_type);
					}

					ifde.tag = temp_start_ptr->tag;
					ifde.field_type = temp_start_ptr->field_type;
					ifde.count = temp_start_ptr->count;

					if(temp_start_ptr->byte_count > 4)
					{
						if(temp_start_ptr->tag == 0x829a ||
							temp_start_ptr->tag == 0x829d ||
							temp_start_ptr->tag == 0x9204 ||
							temp_start_ptr->tag == 0x920a)
						{
							type5_ptr = (struct type5 *) my_malloc("type5_ptr", sizeof(struct type5));
							memset(type5_ptr, (int) NULL, sizeof(struct type5));

							type5_ptr->numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
							type5_ptr->denominator = (unsigned long) Get32u((temp_start_ptr->data_at_offset + 4));

							memcpy(temp_data_buffer_ptr, type5_ptr, temp_start_ptr->byte_count);
							my_free("type5_ptr", type5_ptr);
						}
						else if(temp_start_ptr->tag == 0x0084)
						{
							lens_ptr = (struct lens *) my_malloc("lens_ptr", sizeof(struct lens));
							memset(lens_ptr, (int) NULL, sizeof(struct lens));

							lens_ptr->field_1.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
							lens_ptr->field_1.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 4);
							lens_ptr->field_2.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 8);
							lens_ptr->field_2.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 12);
							lens_ptr->field_3.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 16);
							lens_ptr->field_3.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 20);
							lens_ptr->field_4.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 24);
							lens_ptr->field_4.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 28);

							memcpy(temp_data_buffer_ptr, lens_ptr, temp_start_ptr->byte_count);
							my_free("lens_ptr", lens_ptr);
						}
						else
						{
							if(temp_start_ptr->tag == 0x0004)
							{
								memcpy(temp_data_buffer_ptr, "BASIC\0", strlen("BASIC\0"));
								temp_start_ptr->byte_count = strlen("BASIC\0") + 1;
								ifde.count = strlen("BASIC\0") + 1;
							}
							else if(temp_start_ptr->tag == 0x0131)
							{
								memset(buffer, (int) NULL, 256);
								sprintf(buffer, "D70Reader - v%s\0", D70_VERSION);
								memcpy(temp_data_buffer_ptr, buffer, strlen(buffer));
								temp_start_ptr->byte_count = strlen(buffer) + 1;
								ifde.count = strlen(buffer) + 1;
							}
							else
								memcpy(temp_data_buffer_ptr, temp_start_ptr->data_at_offset, temp_start_ptr->byte_count);
						}

						temp_data_buffer_ptr += temp_start_ptr->byte_count;
						ifde.value_offset = data_offset;
						data_offset += temp_start_ptr->byte_count;
					}
					else
					{
						if(temp_start_ptr->tag == 0xa405 || 
							temp_start_ptr->tag == 0x0112 ||
							temp_start_ptr->tag == 0x8822 || 
							temp_start_ptr->tag == 0x9209 || 
							temp_start_ptr->tag == 0x9207)
						{
							ulong = temp_start_ptr->value_offset;

							if(MotorolaOrder)
								ubyte5 = (ulong & 0xffff0000) >> 16;
							else
								ubyte5 = ulong;

							ifde.value_offset = ubyte5;

							if(temp_start_ptr->tag == 0x0112)
							{
								ulOrientation = ubyte5;

								if(ALLOW_ROTATE)
									ifde.value_offset = 1;
							}
						}
						else if(temp_start_ptr->tag == 0x0083)
						{
							ulong = temp_start_ptr->value_offset;

							ubyte1 = (ulong & 0xff000000) >> 24;

							ifde.value_offset = ubyte1;
						}
						else
							ifde.value_offset = temp_start_ptr->value_offset;
					}

					memcpy(temp_dir_buffer_ptr, &ifde, 12);
					temp_dir_buffer_ptr += 12;
					break;
				default:
					break;
			}
		
			temp_start_ptr = temp_start_ptr->next;
		}

		switch(temp_start_ptr->tag)
		{
			case 0x0100:
			case 0x0101:
			case 0x0112:
				if(temp_start_ptr->record_type == 1)
					break;
			case 0x829a:
			case 0x9209:
			case 0x8822:
			case 0x9207:
			case 0x0084:
			case 0x920a:
			case 0xa405:
			case 0x0083:
			case 0x8827:
			case 0x010f:
			case 0x0110:
			case 0x0131:
			case 0x9004:
			case 0x829d:
			case 0x0002:
			case 0x0013:
			case 0x0004:
			case 0x0005:
			case 0x0006:
			case 0x00a7:
			case 0x0007:
			case 0x0008:
			case 0x0009:
			case 0x0081:
			case 0x008b:
			case 0x008d:
			case 0x0090:
			case 0x0095:
			case 0x00a9:
			case 0x00aa:
			case 0x00ab:
			case 0xa002:
			case 0xa003:
			case 0x9204:
			case 0x9286:
				if(iTrace)
				{
					printf("tag: %x\n", temp_start_ptr->tag);
					printf("Field_type: %d\n", temp_start_ptr->field_type);
					printf("count: %d\n", temp_start_ptr->count);
					printf("value_offset: %x\n", temp_start_ptr->value_offset);
					printf("record_type: %d\n", temp_start_ptr->record_type);
				}

				ifde.tag = temp_start_ptr->tag;
				ifde.field_type = temp_start_ptr->field_type;
				ifde.count = temp_start_ptr->count;

				if(temp_start_ptr->byte_count > 4)
				{
					if(temp_start_ptr->tag == 0x829a ||
						temp_start_ptr->tag == 0x829d ||
						temp_start_ptr->tag == 0x9204 ||
						temp_start_ptr->tag == 0x920a)
					{
						type5_ptr = (struct type5 *) my_malloc("type5_ptr", sizeof(struct type5));
						memset(type5_ptr, (int) NULL, sizeof(struct type5));

						type5_ptr->numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
						type5_ptr->denominator = (unsigned long) Get32u((temp_start_ptr->data_at_offset + 4));

						memcpy(temp_data_buffer_ptr, type5_ptr, temp_start_ptr->byte_count);
						my_free("type5_ptr", type5_ptr);
					}
					else if(temp_start_ptr->tag == 0x0084)
					{
						lens_ptr = (struct lens *) my_malloc("lens_ptr", sizeof(struct lens));
						memset(lens_ptr, (int) NULL, sizeof(struct lens));

						lens_ptr->field_1.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
						lens_ptr->field_1.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 4);
						lens_ptr->field_2.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 8);
						lens_ptr->field_2.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 12);
						lens_ptr->field_3.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 16);
						lens_ptr->field_3.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 20);
						lens_ptr->field_4.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 24);
						lens_ptr->field_4.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 28);

						memcpy(temp_data_buffer_ptr, lens_ptr, temp_start_ptr->byte_count);
						my_free("lens_ptr", lens_ptr);
					}
					else
					{
						if(temp_start_ptr->tag == 0x0004)
						{
							memcpy(temp_data_buffer_ptr, "BASIC\0", strlen("BASIC\0"));
							temp_start_ptr->byte_count = strlen("BASIC\0") + 1;
							ifde.count = strlen("BASIC\0") + 1;
						}
						else if(temp_start_ptr->tag == 0x0131)
						{
							memset(buffer, (int) NULL, 256);
							sprintf(buffer, "D70Reader - v%s\0", D70_VERSION);
							memcpy(temp_data_buffer_ptr, buffer, strlen(buffer));
							temp_start_ptr->byte_count = strlen(buffer) + 1;
							ifde.count = strlen(buffer) + 1;
						}
						else
							memcpy(temp_data_buffer_ptr, temp_start_ptr->data_at_offset, temp_start_ptr->byte_count);
					}

					temp_data_buffer_ptr += temp_start_ptr->byte_count;
					ifde.value_offset = data_offset;
					data_offset += temp_start_ptr->byte_count;
				}
				else
				{
					if(temp_start_ptr->tag == 0xa405 || 
						temp_start_ptr->tag == 0x0112 ||
						temp_start_ptr->tag == 0x8822 || 
						temp_start_ptr->tag == 0x9209 || 
						temp_start_ptr->tag == 0x9207)
					{
						ulong = temp_start_ptr->value_offset;

						if(MotorolaOrder)
							ubyte5 = (ulong & 0xffff0000) >> 16;
						else
							ubyte5 = ulong;

						ifde.value_offset = ubyte5;

						if(temp_start_ptr->tag == 0x0112)
						{
							ulOrientation = ubyte5;

							if(ALLOW_ROTATE)
								ifde.value_offset = 1;
						}
					}
					else if(temp_start_ptr->tag == 0x0083)
					{
						ulong = temp_start_ptr->value_offset;

						ubyte1 = (ulong & 0xff000000) >> 24;

						ifde.value_offset = ubyte1;
					}
					else
						ifde.value_offset = temp_start_ptr->value_offset;
				}

				memcpy(temp_dir_buffer_ptr, &ifde, 12);
				temp_dir_buffer_ptr += 12;
				break;
			default:
				break;
		}
	}

	if(ALLOW_ROTATE)
	{
		if(ulOrientation == 6 || ulOrientation == 8)
		{
			file_tmp_ptr = (char *) my_malloc("file_tmp_ptr", (strlen(filename) + strlen(".tmp") + strlen(".JPG") + 1));
			memset(file_tmp_ptr, (int) NULL, (strlen(filename) + strlen(".tmp") + strlen(".JPG") + 1));
			strcat(file_tmp_ptr, filename);
			strcat(file_tmp_ptr, ".tmp.JPG");

			if(iTrace)
				printf("\nfile_tmp_ptr: %s\n", file_tmp_ptr);
		}
	}

	file_ptr = (char *) my_malloc("file_ptr", (strlen(filename) + strlen(".JPG") + 1));
	memset(file_ptr, (int) NULL, (strlen(filename) + strlen(".JPG") + 1));
	strcat(file_ptr, filename);
	strcat(file_ptr, ".JPG");

	if(iTrace)
		printf("\nfile_ptr: %s\n", file_ptr);

	byte_ptr = (char *) my_malloc("byte_ptr", lThumbnailLength);
	memset(byte_ptr, (int) NULL, lThumbnailLength);

	if(!strncmp(upper_case(model_ptr), "NIKON D100", strlen("NIKON D100")) ||
	   !strncmp(upper_case(model_ptr), "NIKON D2H", strlen("NIKON D2H")))
	{
		if(!iSpecialSoftware)
			fseek(rfd, lThumbnailOffset + calc_maker_note_header_offset + 2, 0);
		else
			fseek(rfd, lThumbnailOffset + calc_maker_note_header_offset, 0);
	}
	else
	{
		if(!iSpecialSoftware)
			fseek(rfd, lThumbnailOffset + 2, 0);
		else
			fseek(rfd, lThumbnailOffset, 0);
	}

	fread(byte_ptr, lThumbnailLength, 1, rfd);

	if(ulOrientation == 6 || ulOrientation == 8)
	{
		if(ALLOW_ROTATE)
		{
			if((ofd = fopen(file_tmp_ptr, "wb")) == NULL)
			{
				printf("\nFile not created: %s\n\n", file_tmp_ptr);
				exit(1);
			}
		}
		else
		{
			if((ofd = fopen(file_ptr, "wb")) == NULL)
			{
				printf("\nFile not created: %s\n\n", file_ptr);
				exit(1);
			}
		}
	}
	else
	{
		if((ofd = fopen(file_ptr, "wb")) == NULL)
		{
			printf("\nFile not created: %s\n\n", file_ptr);
			exit(1);
		}
	}

	if(!iSpecialSoftware)
	{
		if((size = fwrite(exif_header_ptr, (sizeof(struct exif_header) - 2), 1, ofd)) == 0)
		{
			printf("\nFile not written: %s\n\n", file_ptr);
			exit(1);
		}


		if((size = fwrite(dir_buffer_ptr, ((12 * dir_count) + 4), 1, ofd)) == 0)
		{
			printf("\nFile not written: %s\n\n", file_ptr);
			exit(1);
		}

		if((size = fwrite(data_buffer_ptr, 1024, 1, ofd)) == 0)
		{
			printf("\nFile not written: %s\n\n", file_ptr);
			exit(1);
		}
	}

	if((size = fwrite(byte_ptr, lThumbnailLength, 1, ofd)) == 0)
	{
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
	}

	printf("Created file: %s\n", file_ptr);

	fclose(ofd);

	if(ALLOW_ROTATE)
	{
		if(ulOrientation == 6 || ulOrientation == 8)
		{
			local_argv[0] = "jpgtran";
			local_argv[1] = "-rot";
	
			if(ulOrientation == 6)
				local_argv[2] = "90";
			else
				local_argv[2] = "270";
	
			local_argv[3] = "-copy";
			local_argv[4] = "all";
			local_argv[5] = file_tmp_ptr;
			local_argv[6] = file_ptr;
			local_argv[7] = NULL;

			jpegtran(7, local_argv);

			if(remove(file_tmp_ptr))
				printf("File not deleted: %s\n", file_tmp_ptr);
		}
	}

	my_free("byte_ptr", byte_ptr);
	my_free("file_ptr", file_ptr);

	if(file_tmp_ptr != NULL)
		my_free("file_tmp_ptr", file_tmp_ptr);

	if(exif_header_ptr != NULL)
		my_free("exif_header_ptr", exif_header_ptr);

	if(dir_buffer_ptr != NULL)
		my_free("dir_buffer_ptr", dir_buffer_ptr);

	if(data_buffer_ptr != NULL)
		my_free("data_buffer_ptr", data_buffer_ptr);

	trace("\n-output_thumbnail");
	mtrace("\n-output_thumbnail");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void free_jpg_data_header_list(struct jpg_data_header *header_ptr)
{
	struct jpg_data_header *temp_header_ptr = NULL;

	trace("\n+free_jpg_data_header_list");
	mtrace("\n+free_jpg_data_header_list");

	while(header_ptr->next != NULL)
	{
		temp_header_ptr = header_ptr;
		header_ptr = header_ptr->next;
		my_free("temp_header_ptr", temp_header_ptr);
	}

	my_free("header_ptr", header_ptr);
	trace("\n-free_jpg_data_header_list");
	mtrace("\n-free_jpg_data_header_list");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void ProcessFileJPG(int argc, char *filename)
{
	FILE *rfd = NULL;
	char buffer[256];
	char *temp_ptr = NULL;
	unsigned long offset_ifd = 0l;
	int ctr1 = 0;
	struct data_header_ptr *temp_header_start_ptr = NULL;
	struct data_header_ptr *free_header_start_ptr = NULL;
	struct html_header *free_html_header_start_ptr = NULL;

	trace("\n+ProcessFileJPG");
	//mtrace("\n+ProcessFileJPG");

	temp_ptr = get_extension(filename);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "\nFile Extension: %s", temp_ptr);
	trace(trace_buffer);

	if(!strncmp(upper_case(temp_ptr), "JPG", 3))
	{
		iFile_Type = 0;
		my_jpg_exit("Only files of type NEF can be processed using opton -j");
	}
	else
	{
		iJPG_Type = 99;
		iFile_Type = 1;
	}

	if((rfd = fopen(filename, "rb")) == NULL)
	{
		printf("\nFile not opened: %s\n\n", filename);
		return;
	}

	memset(buffer, (int) NULL, 256);
	sprintf(buffer, "IFD%d", ctr1++);

	offset_ifd = inspect_image_file_header(rfd, iFile_Type);
	jpg_header_ptr = get_new_jpg_data_header_ptr();
	start_header_ptr = jpg_header_ptr;
	dump_jpg_image_file_directory(rfd, offset_ifd, jpg_type_offset(), buffer);

	if(iThumbnail || iThumbnailOld)
	{
		if(iFile_Type)
		{
			if(iThumbnail)
				output_thumbnail(filename, rfd);
			else
				output_thumbnail_old(filename, rfd);
		}
	}

	fclose(rfd);

	free_jpg_data_header_list(start_header_ptr);

	trace("\n-ProcessFileJPG");
	//mtrace("\n-ProcessFileJPG");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int check_for_exif_data(FILE *rfd)
{
	int ctr1 = 0;
	int iFoundEXIF = 0;

	long position = 0l;
	long old_position = 0l;
	int oldMotorolaOrder = 0;

	struct marker
	{
		unsigned char pad;
		unsigned char marker;
		unsigned short length;
		char test_data[6];
	};

	struct marker *temp_ptr;

	oldMotorolaOrder = MotorolaOrder;
	MotorolaOrder = 1;

	old_position = ftell(rfd);

	temp_ptr = (struct marker *) my_malloc("temp_ptr", sizeof(struct marker));
	memset(temp_ptr, (int) NULL, sizeof(struct marker));

	fseek(rfd, 2, 0);

	do
	{
		ctr1++;
		position = ftell(rfd);

		memset(temp_ptr, (int) NULL, sizeof(struct marker));
		fread(temp_ptr, sizeof(struct marker), 1, rfd);

		if(!strncmp(temp_ptr->test_data, "Exif\0\0", 6))
		{
			iFoundEXIF = 1;
			break;
		}
		else
			fseek(rfd, Get16u(&temp_ptr->length) - sizeof(struct marker) + 2, 1);

		if(temp_ptr->marker == 0xda)
			break;
	}
	while(strncmp(temp_ptr->test_data, "Exif\0\0", 6));	

	fseek(rfd, old_position, 0);

	MotorolaOrder = oldMotorolaOrder;

	my_free("temp_ptr", temp_ptr);

	return(iFoundEXIF);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void check_for_config()
{
	int ctr1 = 0;
	unsigned long size = 0l;
	struct stat buf;
	char buffer[256];
	char *file_ptr = NULL;
	char *data_buffer_ptr = NULL;
	FILE *ofd = NULL;
	FILE *rfd = NULL;
	struct wanted_tags *local_header_ptr = NULL;
	struct all_wanted_tags *local_header_all_ptr = NULL;

	trace("\n+check_for_config");
	mtrace("\n+check_for_config");

	if(iSystemType)
	{
		file_ptr = (char *) my_malloc("file_ptr", (strlen(file_sys_dir_ptr) + strlen("\\d70reader.conf") + 1));
		memset(file_ptr, (int) NULL, (strlen(file_sys_dir_ptr) + strlen("\\d70reader.conf") + 1));
		strcat(file_ptr, file_sys_dir_ptr);
		strcat(file_ptr, "\\d70reader.conf");
	}
	else
	{
		file_ptr = (char *) my_malloc("file_ptr", (strlen(file_sys_dir_ptr) + strlen("/d70reader.conf") + 1));
		memset(file_ptr, (int) NULL, (strlen(file_sys_dir_ptr) + strlen("/d70reader.conf") + 1));
		strcat(file_ptr, file_sys_dir_ptr);
		strcat(file_ptr, "/d70reader.conf");
	}

	if(stat(file_ptr, &buf) == (-1))
	{
		if((ofd = fopen(file_ptr, "w")) == NULL)
		{
			printf("\nFile not created: %s\n", file_ptr);
			printf("\nThis must be done by the 'root' user.\n\n");
			exit(0);
		}

		//fputs("D70ReaderProgramVersion=yes", ofd);
		//fputs("Filename=yes", ofd);

		for(ctr1 = 0; ctr1 < SizeTagTable; ctr1++)
		{
			switch(TagTable[ctr1].Tag)
			{
				case 0x0112:
				case 0x829a:
				case 0x9209:
				case 0x8822:
				case 0x9207:
				case 0x0084:
				case 0x920a:
				case 0xa405:
				case 0x0083:
				case 0x8827:
				case 0x010f:
				case 0x0110:
				case 0x0131:
				case 0x9004:
				case 0x829d:
				case 0x0002:
				case 0x0013:
				case 0x0004:
				case 0x0005:
				case 0x0006:
				case 0x00a7:
				case 0x0007:
				case 0x0008:
				case 0x0009:
				case 0x0081:
				case 0x008b:
				case 0x008d:
				case 0x0090:
				case 0x0095:
				case 0x00a9:
				case 0x00aa:
				case 0x00ab:
				case 0x0100:
				case 0x0101:
				case 0xa002:
				case 0xa003:
				case 0x9204:
				case 0x9286:

					data_buffer_ptr = (char *) my_malloc("data_buffer_ptr", (strlen(strip(TagTable[ctr1].Desc)) + 6));
					memset(data_buffer_ptr, (int) NULL, (strlen(strip(TagTable[ctr1].Desc)) + 6));
					sprintf(data_buffer_ptr, "%s=yes\n", strip(TagTable[ctr1].Desc));

					if((size = fwrite(data_buffer_ptr, (strlen(strip(TagTable[ctr1].Desc)) + 5), 1, ofd)) == 0)
					{
						printf("\nFile not written: %s\n\n", file_ptr);
						return;
					}

					store_tags(data_buffer_ptr);
					store_all_tags(data_buffer_ptr);
					my_free("data_buffer_ptr", data_buffer_ptr);

					break;
				default:
					break;
			}
		}

		fclose(ofd);

#ifdef __UNIX_ONLY__
		chmod(file_ptr, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
#endif
	}
	else
	{
		if((rfd = fopen(file_ptr, "r")) == NULL)
		{
			printf("\nFile not opened: %s\n\n", file_ptr);
			return;
		}

		do
		{
			memset(buffer, (int) NULL, 256);
			data_buffer_ptr = fgets(buffer, 256, rfd);

			if(data_buffer_ptr == NULL)
				break;

			store_tags(buffer);
			store_all_tags(buffer);
		}
		while(data_buffer_ptr != NULL);

		if(iTrace)
		{
			ctr1 = 0;

			printf("\nDumping wanted_tags list\n");

			local_header_ptr = start_wanted_tags_ptr;

			do
			{
				printf("\n%d - Tag: %x", ctr1++, local_header_ptr->tag);
				local_header_ptr = local_header_ptr->next;
			}
			while(local_header_ptr != NULL); 

			ctr1 = 0;

			printf("\nDumping all_wanted_tags list\n");

			local_header_all_ptr = start_all_wanted_tags_ptr;

			do
			{
				printf("\n%d - Tag: %x", ctr1++, local_header_all_ptr->tag);
				local_header_all_ptr = local_header_all_ptr->next;
			}
			while(local_header_all_ptr != NULL); 
		}
	}

	my_free("file_ptr", file_ptr);

	trace("\n-check_for_config");
	mtrace("\n-check_for_config");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void store_tags(char *local_ptr)
{
	int ctr1 = 0;
	char *temp_ptr = NULL;
	
	trace("\n+store_tags");
	//mtrace("\n+store_tags");

	temp_ptr = strdup(local_ptr);

	temp_ptr = get_description(temp_ptr);

	for(ctr1 = 0; ctr1 < SizeTagTable; ctr1++)
	{
		if(!strncmp(TagTable[ctr1].Desc, temp_ptr, strlen(temp_ptr)) && (strlen(strip(TagTable[ctr1].Desc)) == strlen(temp_ptr)))
		{
			if(tag_is_yes(local_ptr))
			{
				if(main_wanted_tags_ptr == NULL)
				{
					main_wanted_tags_ptr = get_new_main_wanted_tags_ptr();
					main_wanted_tags_ptr->next = NULL;
					main_wanted_tags_ptr->tag = TagTable[ctr1].Tag;
					start_wanted_tags_ptr = main_wanted_tags_ptr;
				}
				else
				{
					main_wanted_tags_ptr->next = get_new_main_wanted_tags_ptr();
					main_wanted_tags_ptr =  main_wanted_tags_ptr->next;
					main_wanted_tags_ptr->next = NULL;
					main_wanted_tags_ptr->tag = TagTable[ctr1].Tag;
				}

				trace("\n-store_tags");
				//mtrace("\n-store_tags");
				return;
			}
		}
	}

	trace("\n-store_tags");
	//mtrace("\n-store_tags");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void store_all_tags(char *local_ptr)
{
	int ctr1 = 0;
	char *temp_ptr = NULL;
	
	trace("\n+store_all_tags");
	//mtrace("\n+store_all_tags");

	temp_ptr = strdup(local_ptr);

	temp_ptr = get_description(temp_ptr);

	for(ctr1 = 0; ctr1 < SizeTagTable; ctr1++)
	{
		if(!strncmp(TagTable[ctr1].Desc, temp_ptr, strlen(temp_ptr)) && (strlen(strip(TagTable[ctr1].Desc)) == strlen(temp_ptr)))
		{
			if(main_all_wanted_tags_ptr == NULL)
			{
				main_all_wanted_tags_ptr = get_new_main_all_wanted_tags_ptr();
				main_all_wanted_tags_ptr->next = NULL;
				main_all_wanted_tags_ptr->tag = TagTable[ctr1].Tag;
				start_all_wanted_tags_ptr = main_all_wanted_tags_ptr;
			}
			else
			{
				main_all_wanted_tags_ptr->next = get_new_main_all_wanted_tags_ptr();
				main_all_wanted_tags_ptr =  main_all_wanted_tags_ptr->next;
				main_all_wanted_tags_ptr->next = NULL;
				main_all_wanted_tags_ptr->tag = TagTable[ctr1].Tag;
			}

			trace("\n-store_all_tags");
			//mtrace("\n-store_all_tags");
			return;
		}
	}

	trace("\n-store_all_tags");
	//mtrace("\n-store_all_tags");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
struct all_wanted_tags *get_new_main_all_wanted_tags_ptr()
{
	struct all_wanted_tags *local_header_ptr = NULL;
	local_header_ptr = (struct all_wanted_tags *) my_malloc("local_header_ptr", sizeof(struct all_wanted_tags));
	memset(local_header_ptr, (int) NULL, sizeof(struct all_wanted_tags));
	return(local_header_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
struct wanted_tags *get_new_main_wanted_tags_ptr()
{
	struct wanted_tags *local_header_ptr = NULL;
	local_header_ptr = (struct wanted_tags *) my_malloc("local_header_ptr", sizeof(struct wanted_tags));
	memset(local_header_ptr, (int) NULL, sizeof(struct wanted_tags));
	return(local_header_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int tag_is_yes(char *local_ptr)
{
	int iWanted = 0;
	char *temp_ptr = NULL;
	char *final_ptr = NULL;
	char *token = NULL;

	trace("\n+tag_is_yes");
	//mtrace("\n+tag_is_yes");

	temp_ptr = strdup(local_ptr);

	token = strtok(temp_ptr, "=");

	do
	{
		if(token != NULL)
			final_ptr = token;

		token = strtok(NULL, "=");
	}
	while(token != NULL);

	if(!strncmp(upper_case(final_ptr), "YES", strlen("YES")))
		iWanted = 1;
	else
		iWanted = 0;

	trace("\n-tag_is_yes");
	//mtrace("\n-tag_is_yes");
	return(iWanted);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int is_tag_printed(unsigned short tag)
{
	int iWanted = 0;

	struct wanted_tags *local_header_ptr = NULL;

	trace("\n+is_tag_printed");
	//mtrace("\n+is_tag_printed");

	local_header_ptr = start_wanted_tags_ptr;

	if(iTrace)
		printf("\ntag: %x", tag);

	if(local_header_ptr != NULL)
	{
		do
		{
			if(local_header_ptr->tag == tag)
			{
				iWanted = 1;
				break;
			}
			else
				iWanted = 0;

			local_header_ptr = local_header_ptr->next;
		}
		while(local_header_ptr != NULL); 
	}

	if(iTrace)
		printf("\niWanted: %d", iWanted);

	trace("\n-is_tag_printed");
	//mtrace("\n-is_tag_printed");
	return(iWanted);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char *get_description(char *str_input)
{
	char *temp_ptr = NULL;
	char *token = NULL;

	trace("\n+get_description");
	//mtrace("\n+get_description");

	temp_ptr = strdup(str_input);

	token = strtok(temp_ptr, "=");

	trace("\n-get_description");
	//mtrace("\n-get_description");
	return(token);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_js(FILE *ofd, int iFirstTime, int iIndex)
{
	int ctr1 = 0;
	struct all_wanted_tags *local_header_all_ptr = NULL;
	struct html_header *local_header_start_ptr = NULL;

	trace("\n+output_js");
	//mtrace("\n+output_js");

	if(iFirstTime)
	{
		fprintf(ofd, "aExifData = new Array()");
		fprintf(ofd, "\naExifDataHeader = new Array()");
		fprintf(ofd, "\naExifDataHeader[0] = new Array(\"D70ReaderProgramVersion\",\"Filename\"");

		local_header_all_ptr = start_all_wanted_tags_ptr;

		do
		{
			if(is_tag_printed(local_header_all_ptr->tag))
			{
				if(iTrace)
					fprintf(ofd, "\n%d - %x - \"%s\",", ctr1++, local_header_all_ptr->tag, get_description_label(local_header_all_ptr->tag, 1));

				fprintf(ofd, ",\"%s\"", get_description_label(local_header_all_ptr->tag, 1));
			}

			local_header_all_ptr = local_header_all_ptr->next;
		}
		while(local_header_all_ptr != NULL); 

		fprintf(ofd, ")\n");

		iFirstTime = 0;
	}

	fprintf(ofd, "aExifData[%d] = new Array(\"%s\",\"%s\"", iIndex, D70_VERSION, get_description_value(0xFFFE));

	local_header_all_ptr = start_all_wanted_tags_ptr;

	do
	{
		if(is_tag_printed(local_header_all_ptr->tag))
		{
			if(iTrace)
				fprintf(ofd, "\n%d - %x - \"%s\",", ctr1++, local_header_all_ptr->tag, get_description_value(local_header_all_ptr->tag));

			fprintf(ofd, ",\"%s\"", get_description_value(local_header_all_ptr->tag));
		}

		local_header_all_ptr = local_header_all_ptr->next;
	}
	while(local_header_all_ptr != NULL); 

	fprintf(ofd, ")\n");

	trace("\n-output_js");
	//mtrace("\n-output_js");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char *get_description_label(unsigned short Tag, int iStrip)
{
	int ctr1 = 0;
	char *local_ptr = NULL;
	char *final_ptr = NULL;

	for (ctr1 = 0; ;ctr1++)
	{
		if (ctr1 >= SizeTagTable )
		{
			memset(trace_buffer, (int) NULL, 256);
			sprintf(trace_buffer, "    Unknown Tag %04x Value = ", Tag);
			trace(trace_buffer);

			local_ptr = (char *) my_malloc("local_ptr", (strlen(trace_buffer) + 1));
			memset(local_ptr, (int) NULL, (strlen(trace_buffer) + 1));
			strcpy(local_ptr, trace_buffer);
			break;
		}

		if (TagTable[ctr1].Tag == Tag)
		{
			memset(trace_buffer, (int) NULL, 256);
			sprintf(trace_buffer, "%s", TagTable[ctr1].Desc); 

			local_ptr = (char *) my_malloc("local_ptr", (strlen(trace_buffer) + 1));
			memset(local_ptr, (int) NULL, (strlen(trace_buffer) + 1));
			strcpy(local_ptr, trace_buffer);

			memset(trace_buffer, (int) NULL, 256);
			sprintf(trace_buffer, "\n%s",TagTable[ctr1].Desc); 
			trace(trace_buffer);
			break;
		}
	}

	if(iStrip)
		final_ptr = strdup(strip(local_ptr));
	else
		final_ptr = strdup(local_ptr);

	my_free("local_ptr", local_ptr);

	return(final_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char * get_description_value(unsigned short Tag)
{
	char *local_ptr = NULL;
	char *final_ptr = NULL;
	struct html_header *local_header_start_ptr = NULL;

	trace("\n+get_description_value");
	mtrace("\n+get_description_value");

	local_header_start_ptr = html_header_start_ptr;

	while(local_header_start_ptr->next != NULL)
	{
		if(iTrace)
		{
			printf("\nlocal_header_start_ptr Tag: %x", local_header_start_ptr->Tag);
			printf("\nlocal_header_start_ptr Value: %s", local_header_start_ptr->Value);
		}

		if(local_header_start_ptr->Tag == Tag)
		{
			if(local_header_start_ptr->Value == NULL)
			{
				local_ptr = (char *) my_malloc("local_ptr", 3);
				memset(local_ptr, (int) NULL, 3);
				//strcpy(local_ptr, " ");
			}
			else
			{
				local_ptr = (char *) my_malloc("local_ptr", (strlen(local_header_start_ptr->Value) + 1));
				memset(local_ptr, (int) NULL, (strlen(local_header_start_ptr->Value) + 1));
				strcpy(local_ptr, local_header_start_ptr->Value);
			}

			break;
		}

		local_header_start_ptr = local_header_start_ptr->next;
	}

	if(local_header_start_ptr->Tag == Tag)
	{
		if(local_header_start_ptr->Value == NULL)
		{
			local_ptr = (char *) my_malloc("local_ptr", 3);
			memset(local_ptr, (int) NULL, 3);
			//strcpy(local_ptr, " ");
		}
		else
		{
			local_ptr = (char *) my_malloc("local_ptr", (strlen(local_header_start_ptr->Value) + 1));
			memset(local_ptr, (int) NULL, (strlen(local_header_start_ptr->Value) + 1));
			strcpy(local_ptr, local_header_start_ptr->Value);
		}
	}

	if(local_ptr == NULL)
	{
		local_ptr = (char *) my_malloc("local_ptr", 3);
		memset(local_ptr, (int) NULL, 3);
		//strcpy(local_ptr, " ");
	}

	final_ptr = strdup(local_ptr);

	my_free("local_ptr", local_ptr);

	trace("\n-get_description_value");
	mtrace("\n-get_description_value");
	return(final_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int precision(char *str_value)
{
	int iPercision = 0;
	char *temp_ptr = NULL;
	char *token1 = NULL;
	char *token2 = NULL;

	trace("\n+precision");
	//mtrace("\n+precision");

	temp_ptr = strdup(str_value);

	token1 = strtok(temp_ptr, ".");
	token2 = strtok(NULL, ".");

	if(token2[0] == '0')
		iPercision = 0;
	else
		iPercision = 2;

	trace("\n-precision");
	//mtrace("\n-precision");

	return(iPercision);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
struct xmp_packet *chk_get_xmp_data(FILE *rfd)
{
	int ctr1 = 0;
	int iFoundHTTP = 0;
	char * data_ptr = NULL;
	struct xmp_packet *xmp_ptr = NULL;
	
	unsigned short length = 0;
	long position = 0l;
	long old_position = 0l;
	int oldMotorolaOrder = 0;

	struct marker
	{
		unsigned char pad;
		unsigned char marker;
		unsigned short length;
		char test_data[6];
	};

	struct marker *temp_ptr = NULL;

	old_position = ftell(rfd);

	oldMotorolaOrder = MotorolaOrder;
	MotorolaOrder = 1;

	temp_ptr = (struct marker *) my_malloc("temp_ptr", sizeof(struct marker));
	memset(temp_ptr, (int) NULL, sizeof(struct marker));

	fseek(rfd, 2, 0);

	do
	{
		ctr1++;
		position = ftell(rfd);

		memset(temp_ptr, (int) NULL, sizeof(struct marker));
		fread(temp_ptr, sizeof(struct marker), 1, rfd);

		length = Get16u(&temp_ptr->length);

		if(!strncmp(temp_ptr->test_data, "http:", strlen("http:")))
		{
			iFoundHTTP = 1;
			break;
		}
		else
			fseek(rfd, Get16u(&temp_ptr->length) - sizeof(struct marker) + 2, 1);

		if(temp_ptr->marker == 0xda)
			break;
	}
	while(strncmp(temp_ptr->test_data, "http:", strlen("http:")));	

	if(iFoundHTTP)
	{
		data_ptr = (unsigned char *) my_malloc("data_ptr", (Get16u(&temp_ptr->length) + 1));
		memset(data_ptr, (int) NULL, (Get16u(&temp_ptr->length) + 1));

		fseek(rfd, position + 4, 0);
		fread(data_ptr, Get16u(&temp_ptr->length), 1, rfd);

		xmp_ptr = (struct xmp_packet *) my_malloc("xmp_ptr", sizeof(struct xmp_packet));
		memset(xmp_ptr, (int) NULL, sizeof(struct xmp_packet));
		xmp_ptr->length = Get16u(&temp_ptr->length);
		xmp_ptr->value = data_ptr;
	}

	MotorolaOrder = oldMotorolaOrder;
	fseek(rfd, old_position, 0);

	return(xmp_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void replace_description_value(unsigned short Tag, char *text_ptr, char *val_ptr)
{
	int iFoundIt = 0;
	char *local_ptr = NULL;
	struct html_header *local_header_start_ptr = NULL;

	trace("\n+replace_description_value");
	mtrace("\n+replace_description_value");

	local_header_start_ptr = html_header_start_ptr;

	while(local_header_start_ptr->next != NULL)
	{
		if(iTrace)
		{
			printf("\nlocal_header_start_ptr Tag: %x", local_header_start_ptr->Tag);
			printf("\nlocal_header_start_ptr Value: %s", local_header_start_ptr->Value);
		}

		if(local_header_start_ptr->Tag == Tag)
		{
			if(local_header_start_ptr->Value != NULL)
			{
				my_free("local_header_start_ptr->Value)", local_header_start_ptr->Value);

				local_ptr = (char *) my_malloc("local_ptr", (strlen(val_ptr) + 1));
				memset(local_ptr, (int) NULL, (strlen(val_ptr) + 1));
				strcpy(local_ptr, val_ptr);
				iFoundIt = 1;
			}

			break;
		}

		local_header_start_ptr = local_header_start_ptr->next;
	}

	if(!iFoundIt)
	{
		if(local_header_start_ptr->Tag == Tag)
		{
			if(local_header_start_ptr->Value != NULL)
			{
				my_free("local_header_start_ptr->Value", local_header_start_ptr->Value);

				local_ptr = (char *) my_malloc("local_ptr", (strlen(val_ptr) + 1));
				memset(local_ptr, (int) NULL, (strlen(val_ptr) + 1));
				strcpy(local_ptr, val_ptr);
				iFoundIt = 1;
			}
		}
	}

	if(!iFoundIt)
	{
		if(iTrace)
			debug_printf("%x %s %s", Tag, text_ptr, val_ptr);
		else
			my_printf("%s %s", Tag, text_ptr, val_ptr);
	}

	trace("\n-replace_description_value");
	mtrace("\n-replace_description_value");
	return;
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int get_sof0_data(FILE *rfd)
{
	int ctr1 = 0;
	int iFoundEXIF = 0;

	long position = 0l;
	long old_position = 0l;
	int oldMotorolaOrder = 0;
	int height = LARGE_IMAGE_HEIGHT;
	int width = LARGE_IMAGE_WIDTH;
	char str_width[10];
	char str_height[10];

	unsigned char m_percision;
	unsigned short m_height;
	unsigned short m_width;

	struct marker
	{
		unsigned char pad;
		unsigned char marker;
		unsigned short length;
	};

	struct marker *temp_ptr;

	oldMotorolaOrder = MotorolaOrder;
	MotorolaOrder = 1;

	old_position = ftell(rfd);

	temp_ptr = (struct marker *) my_malloc("temp_ptr", sizeof(struct marker));
	memset(temp_ptr, (int) NULL, sizeof(struct marker));

	if(!iFile_Type)
		fseek(rfd, 2, 0);
	else
	{
		if(!strncmp(upper_case(model_ptr), "NIKON D100", strlen("NIKON D100")) ||
		   !strncmp(upper_case(model_ptr), "NIKON D2H", strlen("NIKON D2H")))
		{
			fseek(rfd, lThumbnailOffset + calc_maker_note_header_offset + 2, 0);
		}
		else
		{
			fseek(rfd, lThumbnailOffset + 2, 0);
		}
	}

	do
	{
		ctr1++;
		position = ftell(rfd);

		memset(temp_ptr, (int) NULL, sizeof(struct marker));
		fread(temp_ptr, sizeof(struct marker), 1, rfd);

		if(temp_ptr->marker == 0xc0)
		{
			fread(&m_percision, sizeof(unsigned char), 1, rfd);
			fread(&m_height, sizeof(unsigned short), 1, rfd);
			fread(&m_width, sizeof(unsigned short), 1, rfd);
			iFoundEXIF = 1;
			break;
		}
		else
			fseek(rfd, Get16u(&temp_ptr->length) - sizeof(struct marker) + 2, 1);

		if(temp_ptr->marker == 0xda)
			break;
	}
	while(temp_ptr->marker != 0xc0);	

	fseek(rfd, old_position, 0);

	if(iFoundEXIF)
	{
		iGlobalImageWidth = Get16u(&m_width);
		iGlobalImageHeight = Get16u(&m_height);

		if(iWeb)
		{
			if((iGlobalImageWidth != 0) && (iGlobalImageHeight != 0))
			{
				if(iTrace)
					printf("\nGlobalOrientationPtr: %s", GlobalOrientationPtr);

				if((!strcmp(GlobalOrientationPtr, "6") || !strcmp(GlobalOrientationPtr, "8")) || 
					(!strcmp(GlobalOrientationPtr, "1") && (iGlobalImageHeight > iGlobalImageWidth)) ||
					(!strcmp(GlobalOrientationPtr, "X") && (iGlobalImageHeight > iGlobalImageWidth)))
				{
					if(iTrace)
						printf("\ndisplay_data - vertical");

					height = LARGE_IMAGE_LENGTH;

					if(!strcmp(GlobalOrientationPtr, "1") || !strcmp(GlobalOrientationPtr, "X"))
						width = (height * iGlobalImageWidth) / iGlobalImageHeight;
					else
					{
						if(iGlobalImageHeight > iGlobalImageWidth)
							width = (height * iGlobalImageWidth) / iGlobalImageHeight;
						else
							width = (height * iGlobalImageHeight) / iGlobalImageWidth;
					}				}
				else
				{
					if(iTrace)
						printf("\ndisplay_data - horizontal");

					width = LARGE_IMAGE_LENGTH;
					height = (width * iGlobalImageHeight) / iGlobalImageWidth;
				}

				memset(str_width, (int) NULL, 10);
				memset(str_height, (int) NULL, 10);

				sprintf(str_width, "%d", width);
				sprintf(str_height, "%d", height);

				if(iTrace)
				{
					printf("\nwidth: %s", str_width);
					printf("\nheight: %s", str_height);
				}

				replace_description_value(0xA002, "ExifImageWidth             ", str_width);
				replace_description_value(0xA003, "ExifImageLength            ", str_height);
			}
		}
	}

	MotorolaOrder = oldMotorolaOrder;

	my_free("temp_ptr", temp_ptr);

	return(iFoundEXIF);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
long get_marker_offset(FILE *rfd, unsigned short us_marker)
{
	int ctr1 = 0;
	int iFoundDB = 0;

	long position = 0l;
	long old_position = 0l;
	int oldMotorolaOrder = 0;

	struct marker
	{
		unsigned char pad;
		unsigned char marker;
		unsigned short length;
	};

	struct marker *temp_ptr;

	oldMotorolaOrder = MotorolaOrder;
	MotorolaOrder = 1;

	old_position = ftell(rfd);

	temp_ptr = (struct marker *) my_malloc("temp_ptr", sizeof(struct marker));
	memset(temp_ptr, (int) NULL, sizeof(struct marker));

	if(!iFile_Type)
		fseek(rfd, 2, 0);
	else
	{
		if(!strncmp(upper_case(model_ptr), "NIKON D100", strlen("NIKON D100")) ||
		   !strncmp(upper_case(model_ptr), "NIKON D2H", strlen("NIKON D2H")))
		{
			fseek(rfd, lThumbnailOffset + calc_maker_note_header_offset + 2, 0);
		}
		else
		{
			fseek(rfd, lThumbnailOffset + 2, 0);
		}
	}

	do
	{
		ctr1++;
		position = ftell(rfd);

		memset(temp_ptr, (int) NULL, sizeof(struct marker));
		fread(temp_ptr, sizeof(struct marker), 1, rfd);

		if(temp_ptr->marker == us_marker)
		{
			iFoundDB = 1;
			break;
		}
		else
			fseek(rfd, Get16u(&temp_ptr->length) - sizeof(struct marker) + 2, 1);

		if(temp_ptr->marker == 0xda)
			break;
	}
	while(temp_ptr->marker != us_marker);

	fseek(rfd, old_position, 0);

	if(iFoundDB)
		return(position);
	else
		return(0);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void remove_exif(char *filename, FILE *rfd)
{
	unsigned long size = 0l;
	FILE *ofd = NULL;
	char *buf_ptr = NULL;
	char *file_ptr = NULL;
	long position = 0l;
	long db_position = 0l;
	long c0_position = 0l;

	db_position = get_marker_offset(rfd, 0x00db);
	c0_position = get_marker_offset(rfd, 0x00c0);

	if((c0_position != 0) && (c0_position < db_position))
		position = c0_position;
	else
		position = db_position;

	if(position)
	{
		fseek(rfd, position, 1);

		buf_ptr = (char *) my_malloc("buf_ptr", (lFileSize - position + 1));
		memset(buf_ptr, (int) NULL, (lFileSize - position + 1));
		fread(buf_ptr, (lFileSize - position), 1, rfd);

		file_ptr = (char *) my_malloc("file_ptr", (strlen(filename) + strlen("NOEXIF_") + 1));
		memset(file_ptr, (int) NULL, (strlen(filename) + strlen("NOEXIF_") + 1));
		sprintf(file_ptr, "%s%s", "NOEXIF_", filename);

		if((ofd = fopen(file_ptr, "wb")) == NULL)
		{
			printf("\nFile not opened: %s\n\n", file_ptr);
			return;
		}

		fputc(0xff, ofd);
		fputc(0xd8, ofd);

		if((size = fwrite(buf_ptr, (lFileSize - position), 1, ofd)) == 0)
		{
			printf("\nFailed to write to file: %s", file_ptr);
			return;
		}

		fclose(ofd);

		printf("\nCreated file: %s", file_ptr);

		my_free("buf_ptr", buf_ptr);
		my_free("file_ptr", file_ptr);
	}
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_thumbnail(char *filename, FILE *rfd)
{
	FILE *ofd = NULL;
	long position = 0l;
	unsigned long size = 0l;
	unsigned char *byte_ptr = NULL;
	unsigned char *file_ptr = NULL;
	unsigned char *file_tmp_ptr = NULL;
	int ctr1 = 0;

	char *local_argv[10];

	struct exif_header
	{
		unsigned char ff;
		unsigned char soi;
		unsigned char pad;
		unsigned char marker;
		unsigned short length;
		unsigned char exif[6];
		unsigned char byte_order[2];
		unsigned short flag;
		unsigned int offset;
	};

	struct exif_header *exif_header_ptr = NULL;
	unsigned char *dir_buffer_ptr = NULL;
	unsigned char *temp_dir_buffer_ptr = NULL;
	unsigned char *data_buffer_ptr = NULL;
	unsigned char *temp_data_buffer_ptr = NULL;

	unsigned short dir_count = 0;
	int iStructSize = 0;
	unsigned int data_offset = 0;
	unsigned short short_length = 0;
	unsigned long ulOrientation = ulGlobalOrientation;
	int iSpecialSoftware = 0;
	long lHeaderEndOffset = 0;
	long lLength = 0;
	unsigned long ul_local_sub_ifd_array[4] = { 0,0,0,0 };

	trace("\n+output_thumbnail");
	mtrace("\n+output_thumbnail");

	//output_values();

	exif_header_ptr = (struct exif_header *) my_malloc("exif_header_ptr", sizeof(struct exif_header));
	memset(exif_header_ptr, (int) 0xFF, sizeof(struct exif_header));
	iStructSize = sizeof(struct exif_header);

	if(strlen(software_ptr) >= strlen("Nikon Capture"))
	{
		if(!strncmp(software_ptr, "Nikon Capture", strlen("Nikon Capture")))
		{
			lHeaderEndOffset = tag_thumbnail_ifd_offset;

			// I hate to do this, but I don't know how the Nikon Capture NEF file is structured! - JON JON JON
			// The header length MUST fit in two bytes (unsigned short), in MotorolaOrder!
			if(lHeaderEndOffset > 0xEFFF)
				lHeaderEndOffset = 0xEFFF;
		}
		else
			lHeaderEndOffset = get_header_end_offset(rfd);
	}
	else
		lHeaderEndOffset = get_header_end_offset(rfd);


	lLength = lHeaderEndOffset + 0x0008;

	exif_header_ptr->ff = 0xFF;
	exif_header_ptr->soi = 0xD8;
	exif_header_ptr->pad = 0xFF;
	exif_header_ptr->marker = 0xE1;
	exif_header_ptr->length = (unsigned short) Get16u(&lLength);
	memcpy(exif_header_ptr->exif,"Exif\0\0", 6);

	if(MotorolaOrder)
	{
		memcpy(exif_header_ptr->byte_order,"MM", 2);

		exif_header_ptr->flag = 0x2A00;
		exif_header_ptr->offset = 0x08000000;
	}
	else
	{
		memcpy(exif_header_ptr->byte_order,"II", 2);

		exif_header_ptr->flag = 0x002A;
		exif_header_ptr->offset = 0x00000008;
	}

	if(ALLOW_ROTATE)
	{
		if(ulOrientation == 6 || ulOrientation == 8)
		{
			file_tmp_ptr = (char *) my_malloc("file_tmp_ptr", (strlen(filename) + strlen(".tmp") + strlen(".JPG") + 1));
			memset(file_tmp_ptr, (int) NULL, (strlen(filename) + strlen(".tmp") + strlen(".JPG") + 1));
			strcat(file_tmp_ptr, filename);
			strcat(file_tmp_ptr, ".tmp.JPG");

			if(iTrace)
				printf("\nfile_tmp_ptr: %s\n", file_tmp_ptr);
		}
	}

	file_ptr = (char *) my_malloc("file_ptr", (strlen(filename) + strlen(".JPG") + 1));
	memset(file_ptr, (int) NULL, (strlen(filename) + strlen(".JPG") + 1));
	strcat(file_ptr, filename);
	strcat(file_ptr, ".JPG");

	if(iTrace)
		printf("\nfile_ptr: %s\n", file_ptr);

	data_buffer_ptr = (unsigned char *) my_malloc("data_buffer_ptr", (lHeaderEndOffset + 1));
	memset(data_buffer_ptr, (int) NULL, (lHeaderEndOffset + 1));
	fseek(rfd, 8, 0);
	fread(data_buffer_ptr, lHeaderEndOffset, 1, rfd);

	byte_ptr = (char *) my_malloc("byte_ptr", lThumbnailLength);
	memset(byte_ptr, (int) NULL, lThumbnailLength);

	if(!strncmp(upper_case(model_ptr), "NIKON D100", strlen("NIKON D100")) ||
	   !strncmp(upper_case(model_ptr), "NIKON D2H", strlen("NIKON D2H")))
	{
			fseek(rfd, lThumbnailOffset + calc_maker_note_header_offset + 2, 0);
	}
	else
	{
			fseek(rfd, lThumbnailOffset + 2, 0);
	}

	fread(byte_ptr, lThumbnailLength, 1, rfd);

	if(ulOrientation == 6 || ulOrientation == 8)
	{
		if(ALLOW_ROTATE)
		{
			if((ofd = fopen(file_tmp_ptr, "wb")) == NULL)
			{
				printf("\nFile not created: %s\n\n", file_tmp_ptr);
				exit(1);
			}
		}
		else
		{
			if((ofd = fopen(file_ptr, "wb")) == NULL)
			{
				printf("\nFile not created: %s\n\n", file_ptr);
				exit(1);
			}
		}
	}
	else
	{
		if((ofd = fopen(file_ptr, "wb")) == NULL)
		{
			printf("\nFile not created: %s\n\n", file_ptr);
			exit(1);
		}
	}

	if((size = fwrite(exif_header_ptr, sizeof(struct exif_header), 1, ofd)) == 0)
	{
		if(ulOrientation == 6 || ulOrientation == 8)
		{
			if(ALLOW_ROTATE)
				printf("\nFile not written[1]: %s\n\n", file_tmp_ptr);
			else
				printf("\nFile not written[1]: %s\n\n", file_ptr);
		}
		else
			printf("\nFile not written[1]: %s\n\n", file_ptr);

		exit(1);
	}

	if((size = fwrite(data_buffer_ptr, lHeaderEndOffset - 8, 1, ofd)) == 0)
	{
		if(ulOrientation == 6 || ulOrientation == 8)
		{
			if(ALLOW_ROTATE)
				printf("\nFile not written[2]: %s\n\n", file_tmp_ptr);
			else
				printf("\nFile not written[2]: %s\n\n", file_ptr);
		}
		else
			printf("\nFile not written[2]: %s\n\n", file_ptr);

		exit(1);
	}

	for(ctr1 = 0; ctr1 < 4; ctr1++)
	{
		if(ul_sub_ifd_array[ctr1])
			ul_local_sub_ifd_array[ctr1] = output_sub_ifd(ul_sub_ifd_array[ctr1], rfd, ofd);
	}

	ul_gobal_software_postion = output_software_version(ofd);

	position = ftell(ofd);

	if((size = fwrite(byte_ptr, lThumbnailLength, 1, ofd)) == 0)
	{
		if(ulOrientation == 6 || ulOrientation == 8)
		{
			if(ALLOW_ROTATE)
				printf("\nFile not written[3]: %s\n\n", file_tmp_ptr);
			else
				printf("\nFile not written[3]: %s\n\n", file_ptr);
		}
		else
			printf("\nFile not written[3]: %s\n\n", file_ptr);

		exit(1);
	}

	printf("\nCreated file: %s", file_ptr);

	fclose(ofd);

	if(ulOrientation == 6 || ulOrientation == 8)
	{
		if(ALLOW_ROTATE)
			update_header_length(file_tmp_ptr, position);
		else
			update_header_length(file_ptr, position);
	}
	else
		update_header_length(file_ptr, position);

	for(ctr1 = 0; ctr1 < 4; ctr1++)
	{
		if(ul_local_sub_ifd_array[ctr1])
		{

			if(ulOrientation == 6 || ulOrientation == 8)
				update_sub_ifd_offset(file_tmp_ptr, ul_local_sub_ifd_array[ctr1], ctr1);
			else
				update_sub_ifd_offset(file_ptr, ul_local_sub_ifd_array[ctr1], ctr1);

		}
	}

	if(ALLOW_ROTATE)
	{
		if(ulOrientation == 6 || ulOrientation == 8)
		{
			local_argv[0] = "jpgtran";
			local_argv[1] = "-rot";
	
			if(ulOrientation == 6)
				local_argv[2] = "90";
			else
				local_argv[2] = "270";
	
			local_argv[3] = "-copy";
			local_argv[4] = "all";
			local_argv[5] = file_tmp_ptr;
			local_argv[6] = file_ptr;
			local_argv[7] = NULL;

			jpegtran(7, local_argv);

			if(remove(file_tmp_ptr))
				printf("File not deleted: %s\n", file_tmp_ptr);
		}
	}

	for(ctr1 = 0; ctr1 < 4; ctr1++)
	{
		ul_sub_ifd_array[ctr1] = 0l;
	}

	my_free("byte_ptr", byte_ptr);
	my_free("file_ptr", file_ptr);

	if(file_tmp_ptr != NULL)
		my_free("file_tmp_ptr", file_tmp_ptr);

	if(exif_header_ptr != NULL)
		my_free("exif_header_ptr", exif_header_ptr);

	if(dir_buffer_ptr != NULL)
		my_free("dir_buffer_ptr", dir_buffer_ptr);

	if(data_buffer_ptr != NULL)
		my_free("data_buffer_ptr", data_buffer_ptr);

	trace("\n-output_thumbnail");
	mtrace("\n-output_thumbnail");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
long get_header_end_offset(FILE *rfd)
{
	long position = 0l;
	long thumbnail_offset = 0l;
	long final_offset = 0l;
	unsigned short ctr1 = 0;
	unsigned short us_dir_num = 0;

	struct image_file_directory_entry ifde;

	position = ftell(rfd);

	fseek(rfd, tag_thumbnail_ifd_offset, 0);

	fread(&us_dir_num, sizeof(unsigned short), 1, rfd);

	do
	{
		if(ctr1 > Get16u(&us_dir_num))
			break;

		fread(&ifde, sizeof(struct image_file_directory_entry), 1, rfd);

		ctr1++;

		if(Get16u(&ifde.tag) == 0x201)
		{
			thumbnail_offset = (long) Get32u(&ifde.value_offset);
			break;
		}
	}
	while(Get16u(&ifde.tag) != 0x201);

	if(thumbnail_offset)
		final_offset = thumbnail_offset + calc_maker_note_header_offset;

	fseek(rfd, position, 0);

	return(final_offset);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
unsigned long output_sub_ifd(unsigned long ul_sub_ifd, FILE *rfd, FILE *ofd)
{
	int ctr1 = 0;
	long ifd_offset = 0l;
	long position = 0l;
	unsigned short us_dir_num = 0;
	unsigned short us_max_dir = 0;
	unsigned long size = 0l;
	char *buf_ptr = NULL;
	struct image_file_directory_entry ifde;
	unsigned long ul_temp = 0l;

/*
struct image_file_directory_entry
{
    unsigned short tag;         	//tag
    unsigned short field_type;      //field type
    unsigned long count;      		//count
    unsigned long value_offset;     //value offset
};
*/
	
	ifd_offset = ftell(ofd);
	position = ftell(rfd);

	fseek(rfd, ul_sub_ifd, 0);

	fread(&us_dir_num, sizeof(unsigned short), 1, rfd);

	if((size = fwrite(&us_dir_num, sizeof(unsigned short), 1, ofd)) == 0)
	{
		printf("\nDirectory Number not Writen\n\n");
		exit(1);
	}

	us_max_dir = Get16u(&us_dir_num);

	for(ctr1 = 0; ctr1 < us_max_dir; ctr1++)
	{
		fread(&ifde, sizeof(struct image_file_directory_entry), 1, rfd);

		if(Get16u(&ifde.tag) == 0x11a)
		{
			if((ulGlobalOrientation == 6) || (ulGlobalOrientation == 8))
				ul_temp = Get32u(&ul_global_XResolution_offset) + 0x0012 + 0x000c;
			else
				ul_temp = Get32u(&ul_global_XResolution_offset) + 0x000c;

			ifde.value_offset = Get32u(&ul_temp);
		}

		if(Get16u(&ifde.tag) == 0x11b)
		{
			if((ulGlobalOrientation == 6) || (ulGlobalOrientation == 8))
				ul_temp = Get32u(&ul_global_YResolution_offset) + 0x0012 + 0x000c;
			else
				ul_temp = Get32u(&ul_global_YResolution_offset) + 0x000c;

			ifde.value_offset = Get32u(&ul_temp);
		}

		if((size = fwrite(&ifde, sizeof(struct image_file_directory_entry), 1, ofd)) == 0)
		{
			printf("\nSub-IFD not Writen\n\n");
			exit(1);
		}
	}

	if((size = fwrite("\0\0", 2, 1, ofd)) == 0)
	{
		printf("\nEnd-Block not Writen\n\n");
		exit(1);
	}

	fseek(rfd, position, 0);
	return(ifd_offset);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void update_sub_ifd_offset(char *file_ptr, unsigned long ul_sub_ifd, int i_sub_ifd_num)
{
	FILE *iofd = NULL;
	int iFoundTag = 0;

	long position = 0l;
	unsigned long ifd_offset = 0l;
	unsigned long tag_offset = 0l;
	unsigned long final_offset = 0l;
	unsigned short ctr1 = 0;
	unsigned short us_dir_num = 0;
	unsigned long ulOrientation = ulGlobalOrientation;

	struct image_file_directory_entry ifde;

	if(ulOrientation == 6 || ulOrientation == 8)
		ul_sub_ifd += 0x12;

	if((iofd = fopen(file_ptr, "r+b")) == NULL)
	{
		printf("\nFile not opened: %s\n\n", file_ptr);
		exit(1);
	}

	fseek(iofd, 0x14, 0);

	fread(&us_dir_num, sizeof(unsigned short), 1, iofd);

	do
	{
		if(ctr1 > Get16u(&us_dir_num))
			break;

		position = ftell(iofd);
		fread(&ifde, sizeof(struct image_file_directory_entry), 1, iofd);

		ctr1++;

		if(Get16u(&ifde.tag) == 0x14a)
		{
			iFoundTag = 1;
			break;
		}
	}
	while(Get16u(&ifde.tag) != 0x14a);

	if(iFoundTag)
	{
		fseek(iofd, position + 8, 0);
		fread(&tag_offset, sizeof(unsigned long), 1, iofd);


		if(i_sub_ifd_num == 0)
		{
			if(ulOrientation == 6 || ulOrientation == 8)
				final_offset = Get32u(&tag_offset) + 0xc + 0x12;
			else
				final_offset = Get32u(&tag_offset) + 0xc;

			tag_offset = Get32u(&final_offset);
			fseek(iofd, position + 8, 0);
			fwrite(&tag_offset, sizeof(unsigned long), 1, iofd);
		}
		else
		{
			final_offset = Get32u(&tag_offset);
		}

		if(ulOrientation == 6 || ulOrientation == 8)
			final_offset = Get32u(&tag_offset) - 0x12;

		switch(i_sub_ifd_num)
		{
			case 0:
				fseek(iofd, final_offset, 0);
				break;
			case 1:
				fseek(iofd, (final_offset + 4), 0);
				break;
			case 2:
				fseek(iofd, (final_offset + 8), 0);
				break;
			case 3:
				fseek(iofd, (final_offset + 12), 0);
				break;
			default:
				break;
		}

		ifd_offset = Get32u(&ul_sub_ifd);
		fwrite(&ifd_offset, sizeof(unsigned long), 1, iofd);
	}

	fclose(iofd);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void update_header_length(char *file_ptr, unsigned long ul_offset)
{
	int iFoundTag = 0;
	FILE *iofd = NULL;
	int oldMotorolaOrder = 0;
	long position = 0l;
	unsigned long ulOrientation = ulGlobalOrientation;
	unsigned long final_offset = 0l;
	unsigned long ul_count = 0l;
	unsigned long tag_offset = 0l;
	unsigned short ctr1 = 0;
	unsigned short ul_local_offset = 0;
	unsigned short ul_temp_offset = 0;
	unsigned short us_dir_num = 0;
	struct image_file_directory_entry ifde;
	char *byte_ptr = NULL;

	oldMotorolaOrder = MotorolaOrder;

	if((iofd = fopen(file_ptr, "r+b")) == NULL)
	{
		printf("\nFile not opened: %s\n\n", file_ptr);
		exit(1);
	}

	fseek(iofd, 0x4, 0);

	ul_offset-=4;

	// The following header length MUST be written in MotorolaOrder! - JON JON JON
	MotorolaOrder = 1;

	ul_temp_offset = (unsigned short) ul_offset;
	ul_local_offset = Get16u(&ul_temp_offset);

	fwrite(&ul_local_offset, sizeof(unsigned short), 1, iofd);

	MotorolaOrder = oldMotorolaOrder;

/*
struct image_file_directory_entry
{
    unsigned short tag;         	//tag
    unsigned short field_type;      //field type
    unsigned long count;      		//count
    unsigned long value_offset;     //value offset
};
*/

	// fix some additional tag offsets:

	fseek(iofd, 0x14, 0);

	fread(&us_dir_num, sizeof(unsigned short), 1, iofd);

	do
	{
		if(ctr1 > Get16u(&us_dir_num))
			break;

		position = ftell(iofd);
		fread(&ifde, sizeof(struct image_file_directory_entry), 1, iofd);

		ctr1++;

		if(Get16u(&ifde.tag) == 0x102)
		{
			fseek(iofd, position + 8, 0);
			fread(&tag_offset, sizeof(unsigned long), 1, iofd);

			if(ulOrientation == 6 || ulOrientation == 8)
				final_offset = Get32u(&tag_offset) + 0xc + 0x12;
			else
				final_offset = Get32u(&tag_offset) + 0xc;

			tag_offset = Get32u(&final_offset);
			fseek(iofd, position + 8, 0);
			fwrite(&tag_offset, sizeof(unsigned long), 1, iofd);
		}
	}
	while(Get16u(&ifde.tag) != 0x102);

	fseek(iofd, 0x16, 0);

	ctr1 = 0;

	do
	{
		if(ctr1 > Get16u(&us_dir_num))
			break;

		position = ftell(iofd);
		fread(&ifde, sizeof(struct image_file_directory_entry), 1, iofd);

		ctr1++;

		if(Get16u(&ifde.tag) == 0x131)
		{
			if(ulOrientation == 6 || ulOrientation == 8)
				final_offset = ul_gobal_software_postion - 0xc;
			else
				final_offset = ul_gobal_software_postion - 0xc;

			ul_count = 0x20;
			ifde.count = Get32u(&ul_count);
			ifde.value_offset = Get32u(&final_offset);

			fseek(iofd, position, 0);
			fwrite(&ifde, sizeof(struct image_file_directory_entry), 1, iofd);
		}
	}
	while(Get16u(&ifde.tag) != 0x131);

	fclose(iofd);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_values()
{
	struct jpg_data_header *temp_start_ptr = NULL;

	temp_start_ptr = start_header_ptr;

	printf("RecordType, Tag, FieldType, Count, Offset, Data");

	do
	{
		printf("\n%d,%x,%x,%x,%x, %s", temp_start_ptr->record_type,
			temp_start_ptr->tag,
			temp_start_ptr->field_type,
			temp_start_ptr->count,
			temp_start_ptr->value_offset, temp_start_ptr->data_at_offset);

		temp_start_ptr = temp_start_ptr->next;
	}
	while(temp_start_ptr->next != NULL);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
unsigned long output_software_version(FILE *ofd)
{
	char buffer[64];
	char *buf_ptr = NULL;
	unsigned long position = 0;

	position = ftell(ofd);

	buf_ptr = (char *) my_malloc("buf_ptr", 128);
	memset(buf_ptr, (int) NULL, 128);

	memset(buffer, (int) NULL, 64);
	sprintf(buffer, "D70Reader - v%s\0", D70_VERSION);
	memcpy(buf_ptr, buffer, strlen(buffer));

	fwrite(buf_ptr, 128, 1, ofd);

	my_free("buf_ptr", buf_ptr);

	return(position);
}
@


1.30
log
@See change block for version 0.20.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.29 2005/03/22 17:15:28 joman Exp joman $	*/
d96 16
d150 3
a152 3
#define D70_VERSION "0.20"
#define D70_DATE "Thu Mar 24 03:54:58 UTC 2005"
static char rcsid[] = "$Id: d70reader.c,v 1.29 2005/03/22 17:15:28 joman Exp joman $";
d213 8
d332 3
d341 3
a343 1
			if(iThumbnail)
d347 6
d444 10
d521 8
a528 1
	dump_image_file_directory(rfd, offset_ifd, jpg_type_offset(), get_new_data_header_ptr(), buffer);
a556 2
	fclose(rfd);

d643 5
d841 1
a841 1
	while(temp_header_start_ptr->next != NULL)
d843 9
a851 4
		tmp2_header_start_ptr = temp_header_start_ptr;
		free_data_header_list(temp_header_start_ptr->header_ptr);
		temp_header_start_ptr = temp_header_start_ptr->next;
		my_free("tmp2_header_start_ptr", tmp2_header_start_ptr);
a853 2
	my_free("temp_header_start_ptr", temp_header_start_ptr);

d1278 1
a1278 1
	printf("\nSpecifically, it uses their image rotation logic.");
d1282 2
a1283 1
	printf("\nPlease read their copyright information, found in the XMP_SDK/Documentation/LICENSE.TXT file.\n");
d1292 12
a1303 10
    printf("\n\td70reader [-h|-v|-w|-x|-j|-c|-js|-web] image_file_name\n");
    printf("\n\td70reader [-h|-v|-w|-x|-j|-c|-js|-web] *.NEF *.JPG\n");
    printf("\n\t-h   = this screen");
    printf("\n\t-v   = verbose (raw data)");
    printf("\n\t-w   = generate HTML table");
    printf("\n\t-x   = generate XML tree");
    printf("\n\t-j   = extract JPG thumbnail image from NEF");
    printf("\n\t-c   = generate Comma Separated Values (CSV) data");
    printf("\n\t-js  = generate JavaScript Array data");
    printf("\n\t-web = generate Photo Website\n\n");
d1305 1
d1336 1
d1414 1
a1414 1
void dump_image_file_directory(FILE *rfd, unsigned long offset_ifd, unsigned long offset_base, struct data_header *local_ptr, char *type_ptr)
d1449 2
d1455 52
a1526 17
	ifde_ptr = (struct image_file_directory_entry *) my_malloc("ifde_ptr", sizeof(struct image_file_directory_entry));
	memset(ifde_ptr, (int) NULL, sizeof(struct image_file_directory_entry));

	if(fseek(rfd, offset_ifd, 0) != -1)
	{
		fread(&count, sizeof(unsigned short), 1, rfd);
		num_ifd = Get16u(&count);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nNumber of Image File Directories: %d", num_ifd);
		trace(trace_buffer);
	}
	else
	{
		my_error(rfd);
	}

d1536 5
d1657 7
d1734 1
d1767 2
a1768 1
							dump_image_file_directory(rfd, (Get32u(long_byte_ptr)), 0, get_new_data_header_ptr(), type_buffer);
d1813 2
a1814 1
							dump_image_file_directory(rfd, Get32u(&ifde_ptr->value_offset) + calc_maker_note_header_offset, calc_maker_note_header_offset, get_new_data_header_ptr(), type_buffer);
d1854 2
a1855 1
						dump_image_file_directory(rfd, Get32u(&ifde_ptr->value_offset) + jpg_type_offset(), jpg_type_offset(), get_new_data_header_ptr(), type_buffer);
d2132 2
a2133 1
						dump_image_file_directory(rfd, (maker_note_header_offset + inspect_image_file_header(rfd, 1)), maker_note_header_offset, get_new_data_header_ptr(), type_buffer);
d2174 2
a2175 1
						dump_image_file_directory(rfd, (maker_note_header_offset /*+ inspect_image_file_header(rfd, 1)*/), maker_note_header_offset, get_new_data_header_ptr(), type_buffer);
d2204 2
a2483 2
	char str_width[10];
	char str_height[10];
a2642 1
						iGlobalImageWidth = atoi(local_ptr->Value);
a2645 1
						iGlobalImageHeight = atoi(local_ptr->Value);
a2651 1
						iGlobalImageWidth = atoi(local_ptr->Value);
a2657 1
						iGlobalImageHeight = atoi(local_ptr->Value);
d2661 3
a2663 1
						if(!strncmp(data_type, "SUB_IFD1", strlen("SUB_IFD1")))
d2673 2
d2746 7
a2755 1
					case 0x0131:
a2939 1
						iGlobalImageWidth = atoi(local_ptr->Value);
a2942 1
						iGlobalImageHeight = atoi(local_ptr->Value);
a2948 1
						iGlobalImageWidth = atoi(local_ptr->Value);
a2954 1
						iGlobalImageHeight = atoi(local_ptr->Value);
d2958 3
a2960 1
						if(!strncmp(data_type, "SUB_IFD1", strlen("SUB_IFD1")))
d2973 2
d3046 7
a3055 1
					case 0x0131:
a3088 57

	if(iWeb)
	{
		if(!iSizeTestCompleted)
		{
//			if((iGlobalImageWidth != 0) && (iGlobalImageHeight != 0) && (GlobalOrientationPtr != NULL))
			if((iGlobalImageWidth != 0) && (iGlobalImageHeight != 0))
			{
				iSizeTestCompleted = 1;

//				if(GlobalOrientationPtr == NULL)
//					GlobalOrientationPtr = strdup("6");

				if(iTrace)
					printf("\nGlobalOrientationPtr: %s", GlobalOrientationPtr);

				if(!strcmp(GlobalOrientationPtr, "6") || !strcmp(GlobalOrientationPtr, "8"))
				{
					if(iTrace)
						printf("\ndisplay_data - vertical");

					height = LARGE_IMAGE_LENGTH;

					if(iFile_Type)
						width = (height * iGlobalImageHeight) / iGlobalImageWidth;
					else
						width = (height * iGlobalImageWidth) / iGlobalImageHeight;

					if(width > height)
						width = (height * iGlobalImageHeight) / iGlobalImageWidth;
				}
				else
				{
					if(iTrace)
						printf("\ndisplay_data - horizontal");

					width = LARGE_IMAGE_LENGTH;
					height = (width * iGlobalImageHeight) / iGlobalImageWidth;
				}

				memset(str_width, (int) NULL, 10);
				memset(str_height, (int) NULL, 10);

				sprintf(str_width, "%d", width);
				sprintf(str_height, "%d", height);

				if(iTrace)
				{
					printf("\nwidth: %s", str_width);
					printf("\nheight: %s", str_height);
				}

				replace_description_value(0xA002, "ExifImageWidth             ", str_width);
				replace_description_value(0xA003, "ExifImageLength            ", str_height);
			}
		}
	}
d3439 2
d3452 1
d3486 5
d3510 2
d3584 7
d3602 12
d3670 8
d3714 2
d3730 1
a3730 1
							//call dump_.... with offset
d3741 3
d3796 13
d3973 1
a3973 1
void output_thumbnail(char *filename, FILE *rfd)
d4018 1
a4018 1
	struct exif_header *exif_header_ptr;
d4033 1
d4038 9
a4046 3
	exif_header_ptr = (struct exif_header *) my_malloc("exif_header_ptr", sizeof(struct exif_header));
	memset(exif_header_ptr, (int) 0xFF, sizeof(struct exif_header));
	iStructSize = sizeof(struct exif_header);
d4048 15
a4062 9
	exif_header_ptr->ff = 0xFF;
	exif_header_ptr->soi = 0xD8;
	exif_header_ptr->pad = 0xFF;
	exif_header_ptr->marker = 0xE1;
	exif_header_ptr->length = 0x00;		//set this later
	memcpy(exif_header_ptr->exif,"Exif\0\0", 6);
	memcpy(exif_header_ptr->byte_order,"II", 2);
	exif_header_ptr->flag = 0x002A;
	exif_header_ptr->offset = 0x0008;
d4064 1
a4064 1
	temp_start_ptr = start_header_ptr;
d4066 1
a4066 1
	dir_count += count_tags(temp_start_ptr);
d4068 6
a4073 6
	if(iTrace)
	{
		printf("\nfilename: %s\n", filename);
		printf("\ndir_count: %d", dir_count);
		printf("\niTagCount: %d", iTagCount);
	}
d4075 1
a4075 1
	exif_header_ptr->dir_count = dir_count;
d4077 5
a4081 5
	dir_buffer_ptr = (unsigned char *) my_malloc("dir_buffer_ptr", (12 * dir_count) + 4);
	memset(dir_buffer_ptr, (int) NULL, (12 * dir_count) + 4);
	temp_dir_buffer_ptr = dir_buffer_ptr;
	data_buffer_ptr = (unsigned char *) my_malloc("data_buffer_ptr", 1024);
	memset(data_buffer_ptr, (int) NULL, 1024);
d4083 1
a4083 1
	data_offset = sizeof(struct exif_header) + ((12 * dir_count) + 4) - 14;
d4085 2
a4086 2
	memset(dir_buffer_ptr, (int) NULL, ((12 * dir_count) + 4));
	memset(data_buffer_ptr, (int) NULL, 1024);
d4088 2
a4089 2
	short_length = ((12 * dir_count) + 4) + sizeof(struct exif_header) + 1024 - 6;
	exif_header_ptr->length = Get16u(&short_length);
d4091 1
a4091 1
	temp_data_buffer_ptr = data_buffer_ptr;
d4093 1
a4093 1
	temp_start_ptr = start_header_ptr;
d4095 162
a4256 3
	while(temp_start_ptr->next != NULL)
	{
		switch(temp_start_ptr->tag)
d4378 4
a4381 1
						ubyte5 = (ulong & 0xffff0000) >> 16;
a4410 155
	
		temp_start_ptr = temp_start_ptr->next;
	}

	switch(temp_start_ptr->tag)
	{
		case 0x0100:
		case 0x0101:
		case 0x0112:
			if(temp_start_ptr->record_type == 1)
				break;
		case 0x829a:
		case 0x9209:
		case 0x8822:
		case 0x9207:
		case 0x0084:
		case 0x920a:
		case 0xa405:
		case 0x0083:
		case 0x8827:
		case 0x010f:
		case 0x0110:
		case 0x0131:
		case 0x9004:
		case 0x829d:
		case 0x0002:
		case 0x0013:
		case 0x0004:
		case 0x0005:
		case 0x0006:
		case 0x00a7:
		case 0x0007:
		case 0x0008:
		case 0x0009:
		case 0x0081:
		case 0x008b:
		case 0x008d:
		case 0x0090:
		case 0x0095:
		case 0x00a9:
		case 0x00aa:
		case 0x00ab:
		case 0xa002:
		case 0xa003:
		case 0x9204:
		case 0x9286:
			if(iTrace)
			{
				printf("tag: %x\n", temp_start_ptr->tag);
				printf("Field_type: %d\n", temp_start_ptr->field_type);
				printf("count: %d\n", temp_start_ptr->count);
				printf("value_offset: %x\n", temp_start_ptr->value_offset);
				printf("record_type: %d\n", temp_start_ptr->record_type);
			}

			ifde.tag = temp_start_ptr->tag;
			ifde.field_type = temp_start_ptr->field_type;
			ifde.count = temp_start_ptr->count;

			if(temp_start_ptr->byte_count > 4)
			{
				if(temp_start_ptr->tag == 0x829a ||
					temp_start_ptr->tag == 0x829d ||
					temp_start_ptr->tag == 0x9204 ||
					temp_start_ptr->tag == 0x920a)
				{
					type5_ptr = (struct type5 *) my_malloc("type5_ptr", sizeof(struct type5));
					memset(type5_ptr, (int) NULL, sizeof(struct type5));

					type5_ptr->numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
					type5_ptr->denominator = (unsigned long) Get32u((temp_start_ptr->data_at_offset + 4));

					memcpy(temp_data_buffer_ptr, type5_ptr, temp_start_ptr->byte_count);
					my_free("type5_ptr", type5_ptr);
				}
				else if(temp_start_ptr->tag == 0x0084)
				{
					lens_ptr = (struct lens *) my_malloc("lens_ptr", sizeof(struct lens));
					memset(lens_ptr, (int) NULL, sizeof(struct lens));

					lens_ptr->field_1.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
					lens_ptr->field_1.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 4);
					lens_ptr->field_2.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 8);
					lens_ptr->field_2.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 12);
					lens_ptr->field_3.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 16);
					lens_ptr->field_3.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 20);
					lens_ptr->field_4.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 24);
					lens_ptr->field_4.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 28);

					memcpy(temp_data_buffer_ptr, lens_ptr, temp_start_ptr->byte_count);
					my_free("lens_ptr", lens_ptr);
				}
				else
				{
					if(temp_start_ptr->tag == 0x0004)
					{
						memcpy(temp_data_buffer_ptr, "BASIC\0", strlen("BASIC\0"));
						temp_start_ptr->byte_count = strlen("BASIC\0") + 1;
						ifde.count = strlen("BASIC\0") + 1;
					}
					else if(temp_start_ptr->tag == 0x0131)
					{
						memset(buffer, (int) NULL, 256);
						sprintf(buffer, "D70Reader - v%s\0", D70_VERSION);
						memcpy(temp_data_buffer_ptr, buffer, strlen(buffer));
						temp_start_ptr->byte_count = strlen(buffer) + 1;
						ifde.count = strlen(buffer) + 1;
					}
					else
						memcpy(temp_data_buffer_ptr, temp_start_ptr->data_at_offset, temp_start_ptr->byte_count);
				}

				temp_data_buffer_ptr += temp_start_ptr->byte_count;
				ifde.value_offset = data_offset;
				data_offset += temp_start_ptr->byte_count;
			}
			else
			{
				if(temp_start_ptr->tag == 0xa405 || 
					temp_start_ptr->tag == 0x0112 ||
					temp_start_ptr->tag == 0x8822 || 
					temp_start_ptr->tag == 0x9209 || 
					temp_start_ptr->tag == 0x9207)
				{
					ulong = temp_start_ptr->value_offset;

					ubyte5 = (ulong & 0xffff0000) >> 16;

					ifde.value_offset = ubyte5;

					if(temp_start_ptr->tag == 0x0112)
					{
						ulOrientation = ubyte5;

						if(ALLOW_ROTATE)
							ifde.value_offset = 1;
					}
				}
				else if(temp_start_ptr->tag == 0x0083)
				{
					ulong = temp_start_ptr->value_offset;

					ubyte1 = (ulong & 0xff000000) >> 24;

					ifde.value_offset = ubyte1;
				}
				else
					ifde.value_offset = temp_start_ptr->value_offset;
			}

			memcpy(temp_dir_buffer_ptr, &ifde, 12);
			temp_dir_buffer_ptr += 12;
			break;
		default:
			break;
d4441 4
a4444 1
		fseek(rfd, lThumbnailOffset + calc_maker_note_header_offset + 2, 0);
d4448 4
a4451 1
		fseek(rfd, lThumbnailOffset + 2, 0);
d4484 1
a4484 1
	if((size = fwrite(exif_header_ptr, (sizeof(struct exif_header) - 2), 1, ofd)) == 0)
d4486 5
a4490 3
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
	}
d4493 5
a4497 5
	if((size = fwrite(dir_buffer_ptr, ((12 * dir_count) + 4), 1, ofd)) == 0)
	{
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
	}
d4499 5
a4503 4
	if((size = fwrite(data_buffer_ptr, 1024, 1, ofd)) == 0)
	{
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
d4547 8
a4554 3
	my_free("exif_header_ptr", exif_header_ptr);
	my_free("dir_buffer_ptr", dir_buffer_ptr);
	my_free("data_buffer_ptr", data_buffer_ptr);
d4630 1
a4630 1
	if(iThumbnail)
d4633 6
a4638 1
			output_thumbnail(filename, rfd);
d5456 960
@


1.29
log
@Changed contact information.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.28 2005/03/21 23:13:33 joman Exp joman $	*/
d93 3
d134 3
a136 3
#define D70_VERSION "0.19"
#define D70_DATE "Mon Mar 21 22:38:08 UTC 2005"
static char rcsid[] = "$Id: d70reader.c,v 1.28 2005/03/21 23:13:33 joman Exp joman $";
d550 1
a550 1
	sprintf(GlobalOrientationPtr, "%s", "6");
d2550 3
d2844 3
d2969 2
a2970 2
				if(GlobalOrientationPtr == NULL)
					GlobalOrientationPtr = strdup("6");
d2986 3
@


1.28
log
@See version block for Version 0.19.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.27 2005/03/04 17:45:35 joman Exp joman $	*/
d133 1
a133 1
static char rcsid[] = "$Id: d70reader.c,v 1.27 2005/03/04 17:45:35 joman Exp joman $";
d1213 2
a1214 2
        printf("\nD70Reader - Version %s - %s\n", D70_VERSION, D70_DATE); 
        printf("\nThis is a Freeware program, use at your own risk.\n");
d1223 2
a1224 2
        printf("\nThis program only works with Nikon D70/D100/D2H/D2X image files.");
        printf("\n(It will work with NEF/RAW and JPG files.)\n");
d1226 2
a1227 2
        printf("\nCheck here for latest version:");
        printf("\nhttp://home.comcast.net/~jonathan.oman/d70/index.html\n");
d1229 11
a1239 11
        printf("\nFormat:");
        printf("\n\td70reader [-h|-v|-w|-x|-j|-c|-js|-web] image_file_name\n");
        printf("\n\td70reader [-h|-v|-w|-x|-j|-c|-js|-web] *.NEF *.JPG\n");
        printf("\n\t-h   = this screen");
        printf("\n\t-v   = verbose (raw data)");
        printf("\n\t-w   = generate HTML table");
        printf("\n\t-x   = generate XML tree");
        printf("\n\t-j   = extract JPG thumbnail image from NEF");
        printf("\n\t-c   = generate Comma Separated Values (CSV) data");
        printf("\n\t-js  = generate JavaScript Array data");
        printf("\n\t-web = generate Photo Website\n\n");
d1271 1
a1271 3
	printf("jonathan.oman@@comcast.net\n\n");


@


1.27
log
@Check for invalid option, and complain.  Don't just
act on the listed file(s).
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.26 2005/03/04 16:26:34 joman Exp joman $	*/
d86 7
d112 4
d118 2
d127 3
d131 3
a133 2
#define D70_VERSION "0.18"
#define D70_DATE "Fri Mar  4 16:10:37 UTC 2005"
d135 4
a138 400
static char rcsid[] = "$Id: d70reader.c,v 1.26 2005/03/04 16:26:34 joman Exp joman $";

int iTrace = 0;		// set this with -t option 
int iVerbos = 0;	// set this with -v option
int iHtml = 0;		// set this with -w option
int iXml = 0;		// set this with -x option
int iThumbnail = 0;	// set this with -j option
int iCsv = 0;		// set this with -c option
int iJS = 0;		// set this with -js option

int MotorolaOrder = 1;	//All NEF files that I have seen are MotorolaOrder files
			//Correction, Nikon Capture saves in Intel order!
int old_byte_order;
int iJPG_Type;
int iFile_Type;
int iCsv_First_Time = 1;
int iJS_First_Time = 1;
int js_ctr1 = 0;
int iTagCount = 0;
int iSystemType = 0;

unsigned long calc_maker_note_header_offset;

char *make_ptr = NULL;
char *model_ptr = NULL;

struct html_header
{
	char * Desc;
	char * Value;
	unsigned short Tag;
	struct html_header *next;
};

struct data_header
{
	unsigned short Tag;
        unsigned short field_type;         	/*field type          */
        unsigned long count;      		/*count               */
	char * Desc;
	char * Value;
	struct data_header *next;
};

struct jpg_data_header
{
	unsigned short tag;                     
	unsigned short field_type;              
	unsigned long count;                    
	unsigned long value_offset;             
	unsigned char *data_at_offset;
	int record_type;
	int byte_count;
	struct jpg_data_header *next;
};

struct data_header_ptr
{
	char *data_type;
	struct data_header *header_ptr;
	struct data_header_ptr *prev;
	struct data_header_ptr *next;
};

struct image_file_header
{
        char byte_order[2];                     /*byte order indicator 'II' or 'MM' */
        unsigned short image_file_type;         /*image file type                   */
        unsigned long offset_to_first_ifd;      /*offset to first IFD               */
};

struct jpg_image_file_header
{
	unsigned char start;
	unsigned char soi;
	unsigned char pad;
	unsigned char exif_ind;
	unsigned short length;
	char exif_header_text[6];
        char byte_order[2];                     /*byte order indicator 'II' or 'MM' */
        unsigned short image_file_type;         /*image file type                   */
        unsigned long offset_to_first_ifd;      /*offset to first IFD               */
};

struct image_file_directory_entry
{
        unsigned short tag;         		/*tag                 */
        unsigned short field_type;         	/*field type          */
        unsigned long count;      		/*count               */
        unsigned long value_offset;     	/*value offset        */
};

unsigned long lThumbnailOffset;
unsigned long lThumbnailLength;

struct wanted_tags
{
	unsigned short tag;
	struct wanted_tags *next;
};

struct all_wanted_tags
{
	unsigned short tag;
	struct all_wanted_tags *next;
};

struct xmp_packet
{
	unsigned long length;
	char *value;
};

struct all_wanted_tags *main_all_wanted_tags_ptr;
struct all_wanted_tags *start_all_wanted_tags_ptr;
struct wanted_tags *main_wanted_tags_ptr;
struct wanted_tags *start_wanted_tags_ptr;

void free_xmp_data_header_list(struct xmp_data *header_ptr);
struct xmp_data *xmp_display(const char * fileName, unsigned long length, char *data_ptr, int iVerbos);
struct xmp_packet *chk_get_xmp_data(FILE *rfd);
int xmp_main(char *argv_filename);
int precision(char *str_value);
char * get_description_label(unsigned short Tag, int iStrip);
char * get_description_value(unsigned short Tag);
char *get_description(char *str_input);
int is_tag_printed(unsigned short tag);
int tag_is_yes(char *local_ptr);
struct all_wanted_tags *get_new_main_all_wanted_tags_ptr();
struct wanted_tags *get_new_main_wanted_tags_ptr();
void store_tags(char *local_ptr);
void store_all_tags(char *local_ptr);
void check_for_config();
int jpegtran(int argc, char **argv);
int check_for_exif_data(FILE *rfd);
void output_thumbnail(char *filename, FILE *rfd);
void extract_and_format_data(struct image_file_directory_entry *ifde_ptr, struct data_header *local_ptr, int iHex);
char *strip(char *str_input);
void free_html_header_list(struct html_header *header_ptr);
void output_html();
void output_xml();
void output_csv();
void output_js();
struct html_header * get_new_html_header_ptr();
void debug_printf(char *str_format, unsigned short us_tag, char *str_desc, char *str_value);
void my_printf(char *str_format, unsigned short us_tag, char *str_desc, char *str_value);
char *truncate(char *str_token, int dec_len);
char * convert_lens(char *str_lens);
void free_data_header_list(struct data_header *header_ptr);
void free_memory(struct data_header_ptr *free_header_start_ptr, struct html_header *free_html_header_start_ptr);
void ProcessFile(int argc, char *filename);
void ProcessFileJPG(int argc, char *filename);
char *upper_case(char *local_ptr);
char *lower_case(char *local_ptr);
char *get_extension(char *string);
void get_xmp_data(FILE *rfd, struct data_header *local_ptr);
int jpg_type();
int jpg_type_offset();
unsigned long get_jpg_type_and_offset(FILE *rfd, unsigned long offset);
void my_exit(char *text_ptr);
void my_jpg_exit(char *text_ptr);
void display_data(struct data_header *local_ptr, char *data_type);
struct data_header * get_new_data_header_ptr();
struct data_header_ptr * get_new_main_header_ptr();
unsigned long rotate_right(unsigned long Long);
void  instruct(void);
int Get16u(void * Short);
unsigned Get32u(void * Long);
static int Get32s(void * Long);
void my_error(FILE *rfd);
void print_8bit_bytes(unsigned char *byte_ptr, int ByteCount, struct data_header *local_ptr);
void print_8bit_hex(unsigned char *byte_ptr, int ByteCount, struct data_header *local_ptr);
void print_16bit_bytes(unsigned char *byte_ptr, int components, int ByteCount , struct data_header *local_ptr);
void print_16bit_hex(unsigned char *byte_ptr, int components, int ByteCount, struct data_header *local_ptr);
void my_fseek(FILE *rfd, long pos, int offset);
void dump_image_file_directory(FILE *rfd, unsigned long offset_ifd, unsigned long offset_base, struct data_header *local_ptr, char *type_ptr);
void dump_jpg_image_file_directory(FILE *rfd, unsigned long offset_ifd, unsigned long offset_base, char *type_ptr);
void trace(char *str);
void trace_formatted(char *str);
unsigned char * pad_field(unsigned char *temp_ptr, int length, char pad_char, int iPrePend);
unsigned long inspect_image_file_header(FILE *rfd, int iType);

#define NUM_FORMATS 12

#define FMT_BYTE       1
#define FMT_STRING     2
#define FMT_USHORT     3
#define FMT_ULONG      4
#define FMT_URATIONAL  5
#define FMT_SBYTE      6
#define FMT_UNDEFINED  7
#define FMT_SSHORT     8
#define FMT_SLONG      9
#define FMT_SRATIONAL 10
#define FMT_SINGLE    11
#define FMT_DOUBLE    12

#define TAG_EXIF_OFFSET		0x8769
#define TAG_MAKER_NOTE		0x927C
#define TAG_SUBIFD_S		0x014A
#define TAG_ORIENTATION		0x0112
#define TAG_THUMBNAIL_OFFSET	0x0201
#define TAG_THUMBNAIL_LENGTH	0x0202
#define TAG_THUMBNAIL_IFD	0x0011

#define MAKER_NOTE_PRE_HEADER_LENGTH	10
#define ASCII_LABEL_SKIP_LENGTH	8

struct data_header *header_ptr;
struct html_header *html_header_ptr = NULL;
struct html_header *html_header_start_ptr = NULL;

struct data_header_ptr main_header;
struct data_header_ptr *main_header_ptr = NULL;
struct data_header_ptr *main_header_start_ptr = NULL;

struct jpg_data_header *jpg_header_ptr;
struct jpg_data_header *start_header_ptr;
struct jpg_data_header *current_header_ptr;

typedef struct {
    unsigned short Tag;
    char * Desc;
}TagTable_t;

static TagTable_t TagTable[] = {
  { 0x001,   "FileSystemVersion          "},
  { 0x002,   "ISOUsed                    "},
  { 0x004,   "Quality                    "},
  { 0x005,   "WhiteBalance               "},
  { 0x006,   "Sharpening                 "},
  { 0x007,   "FocusMode                  "},
  { 0x008,   "FlashSetting               "},
  { 0x009,   "FlashMode                  "},
  { 0x00A,   "Unknown                    "},
  { 0x00B,   "WhiteBalanceFine           "},
  { 0x00C,   "WhiteBalanceRB             "},
  { 0x00D,   "Unknown                    "},
  { 0x00E,   "Unknown                    "},
  { 0x011,   "ThumbnailImageIFD          "},
  { 0x012,   "FlashCompensation          "},
  { 0x013,   "ISOSet                     "},
  { 0x016,   "Unknown                    "},
  { 0x017,   "Unknown                    "},
  { 0x018,   "Unknown                    "},
  { 0x019,   "Unknown                    "},
  { 0x081,   "ToneCompensation           "},
  { 0x083,   "LensType                   "},
  { 0x084,   "Lens                       "},
  { 0x087,   "FlashUsed                  "},
  { 0x088,   "AFPoint                    "},
  { 0x089,   "Unknown                    "},
  { 0x08A,   "Unknown                    "},
  { 0x08B,   "LensInfo                   "},
  { 0x08C,   "Curve                      "},
  { 0x08D,   "ColorMode                  "},
  { 0x08E,   "Unknown                    "},
  { 0x090,   "LightSource                "},
  { 0x091,   "Unknown                    "},
  { 0x092,   "HueAdjustment              "},
  { 0x093,   "Unknown                    "},
  { 0x095,   "NoiseReduction             "},
  { 0x096,   "NEFCurve2                  "},
  { 0x097,   "ColorBalanceD70            "},
  { 0x098,   "Unknown                    "},
  { 0x099,   "NEFThumbnailSize           "},
  { 0x09A,   "Unknown                    "},
  { 0x0A0,   "SerialNumber               "},
  { 0x0A1,   "Unknown                    "},
  { 0x0A2,   "Unknown                    "},
  { 0x0A3,   "Unknown                    "},
  { 0x0A4,   "Unknown                    "},
  { 0x0A5,   "Unknown                    "},
  { 0x0A6,   "Unknown                    "},
  { 0x0A7,   "ShutterCount               "},
  { 0x0A8,   "Unknown                    "},
  { 0x0A9,   "ImageOptimization          "},
  { 0x0AA,   "Saturation                 "},
  { 0x0AB,   "VariProgram                "},
  { 0x0FE,   "NewSubfileType             "},
  { 0x100,   "ImageWidth                 "},
  { 0x101,   "ImageLength                "},
  { 0x102,   "BitsPerSample              "},
  { 0x103,   "Compression                "},
  { 0x106,   "PhotometricInterpretation  "},
  { 0x10A,   "FillOrder                  "},
  { 0x10D,   "DocumentName               "},
  { 0x10E,   "ImageDescription           "},
  { 0x10F,   "Make                       "},
  { 0x110,   "Model                      "},
  { 0x111,   "StripOffsets               "},
  { 0x112,   "Orientation                "},
  { 0x115,   "SamplesPerPixel            "},
  { 0x116,   "RowsPerStrip               "},
  { 0x117,   "StripByteCounts            "},
  { 0x11A,   "XResolution                "},
  { 0x11B,   "YResolution                "},
  { 0x11C,   "PlanarConfiguration        "},
  { 0x128,   "ResolutionUnit             "},
  { 0x12D,   "TransferFunction           "},
  { 0x131,   "Software                   "},
  { 0x132,   "DateTime                   "},
  { 0x13B,   "Artist                     "},
  { 0x13E,   "WhitePoint                 "},
  { 0x13F,   "PrimaryChromaticities      "},
  { 0x14A,   "SubIFDs                    "},
  { 0x156,   "TransferRange              "},
  { 0x200,   "JPEGProc                   "},
  { 0x201,   "ThumbnailOffset            "},
  { 0x202,   "ThumbnailLength            "},
  { 0x211,   "YCbCrCoefficients          "},
  { 0x212,   "YCbCrSubSampling           "},
  { 0x213,   "YCbCrPositioning           "},
  { 0x214,   "ReferenceBlackWhite        "},
  { 0xE01,   "Unknown                    "},
  { 0xE05,   "Unknown                    "},
  { 0xE0E,   "Unknown                    "},
  { 0xE09,   "Unknown                    "},
  { 0xE10,   "Unknown                    "},
  { 0x1001,  "RelatedImageWidth          "},
  { 0x1002,  "RelatedImageLength         "},
  { 0x828D,  "CFARepeatPatternDim        "},
  { 0x828E,  "CFAPattern                 "},
  { 0x828F,  "BatteryLevel               "},
  { 0x8298,  "Copyright                  "},
  { 0x829A,  "ExposureTime               "},
  { 0x829D,  "FNumber                    "},
  { 0x83BB,  "IPTC/NAA                   "},
  { 0x8769,  "ExifOffset                 "},
  { 0x8773,  "InterColorProfile          "},
  { 0x8822,  "ExposureProgram            "},
  { 0x8824,  "SpectralSensitivity        "},
  { 0x8825,  "GPSInfo                    "},
  { 0x8827,  "ISOSpeedRatings            "},
  { 0x8828,  "OECF                       "},
  { 0x9000,  "ExifVersion                "},
  { 0x9003,  "DateTimeOriginal           "},
  { 0x9004,  "DateTimeDigitized          "},
  { 0x9101,  "ComponentsConfiguration    "},
  { 0x9102,  "CompressedBitsPerPixel     "},
  { 0x9201,  "ShutterSpeedValue          "},
  { 0x9202,  "ApertureValue              "},
  { 0x9203,  "BrightnessValue            "},
  { 0x9204,  "ExposureBiasValue          "},
  { 0x9205,  "MaxApertureValue           "},
  { 0x9206,  "SubjectDistance            "},
  { 0x9207,  "MeteringMode               "},
  { 0x9208,  "LightSource                "},
  { 0x9209,  "Flash                      "},
  { 0x920A,  "FocalLength                "},
  { 0x9216,  "TIFF_EPStandardId          "},
  { 0x9217,  "SensingMethod              "},
  { 0x927C,  "MakerNote                  "},
  { 0x9286,  "UserComment                "},
  { 0x9290,  "SubSecTime                 "},
  { 0x9291,  "SubSecTimeOriginal         "},
  { 0x9292,  "SubSecTimeDigitized        "},
  { 0xA000,  "FlashPixVersion            "},
  { 0xA001,  "ColorSpace                 "},
  { 0xA002,  "ExifImageWidth             "},
  { 0xA003,  "ExifImageLength            "},
  { 0xA004,  "RelatedAudioFile           "},
  { 0xA005,  "InteroperabilityOffset     "},
  { 0xA20B,  "FlashEnergy                "},
  { 0xA20C,  "SpatialFrequencyResponse   "},
  { 0xA20E,  "FocalPlaneXResolution      "},
  { 0xA20F,  "FocalPlaneYResolution      "},
  { 0xA210,  "FocalPlaneResolutionUnit   "},
  { 0xA214,  "SubjectLocation            "},
  { 0xA215,  "ExposureIndex              "},
  { 0xA217,  "SensingMethod              "},
  { 0xA300,  "FileSource                 "},
  { 0xA301,  "SceneType                  "},
  { 0xA302,  "CFA Pattern                "},
  { 0xa401,  "CustomRendered             "},
  { 0xa402,  "ExposureMode               "},
  { 0xa403,  "WhiteBalance               "},
  { 0xa404,  "DigitalZoomRatio           "},
  { 0xa405,  "FocalLengthIn35mmFilm      "},
  { 0xa406,  "SceneCaptureType           "},
  { 0xa407,  "GainControl                "},
  { 0xa408,  "Contrast                   "},
  { 0xa409,  "Saturation                 "},
  { 0xa40a,  "Sharpness                  "},
  { 0xa40c,  "SubjectDistanceRange       "},
  { 0xffff,  "XMP Data                   "}
} ;

const int SizeTagTable = sizeof( TagTable ) / sizeof( TagTable_t );

typedef unsigned char uchar;
char trace_buffer[256];

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
int main(argc, argv, env)
int argc;
char *argv[];
char* env[];
d143 2
a144 2
	int argn;
	char * arg;
d146 2
a147 1
	char *filename;
d178 4
d220 5
d226 1
a226 1
			printf("\n%s", env[ctr3]);
d228 1
a228 1
		if(!memcmp(upper_case(env[ctr3]), "PATH=", 5))
d230 7
a236 4
			if(memchr(env[ctr3],'\\', 20))
				iSystemType = 1;
			else
				iSystemType = 0;
d241 1
a241 2
			// if found, this should be windows:
			if(!memcmp(upper_case(env[ctr3]), "USERPROFILE=", 12))
d243 10
a252 6
				file_sys_dir_ptr = (char *) malloc(strlen(env[ctr3]) + 1);
				memset(file_sys_dir_ptr, (int) NULL, strlen(env[ctr3]) + 1);
				memcpy(file_sys_dir_ptr, &env[ctr3][12], strlen(env[ctr3]) - 12);

				if(iTrace)
					printf("\nfile_sys_dir_ptr: %s\n", file_sys_dir_ptr);
d255 1
a255 2
			// if found, this should be linux/unix:
			if(!memcmp(upper_case(env[ctr3]), "HOME=", 5))
d257 10
a266 6
				file_sys_dir_ptr = (char *) malloc(strlen(env[ctr3]) + 1);
				memset(file_sys_dir_ptr, (int) NULL, strlen(env[ctr3]) + 1);
				memcpy(file_sys_dir_ptr, &env[ctr3][5], strlen(env[ctr3]) - 5);

				if(iTrace)
					printf("\nfile_sys_dir_ptr: %s\n", file_sys_dir_ptr);
d269 1
a269 2
			// if found, this should be OS/2:
			if(!memcmp(upper_case(env[ctr3]), "OS2_SHELL=", 10))
d271 11
a281 7
				file_sys_dir_ptr = (char *) malloc(strlen(env[ctr3]) + 1);
				memset(file_sys_dir_ptr, (int) NULL, strlen(env[ctr3]) + 1);
				memcpy(file_sys_dir_ptr, &env[ctr3][10], 2);
				memcpy(&file_sys_dir_ptr[2], "\\OS2\\APPS", 9);

				if(iTrace)
					printf("\nfile_sys_dir_ptr: %s\n", file_sys_dir_ptr);
d292 1
a292 1
		file_sys_dir_ptr = (char *) malloc(5);
d303 2
a304 2
    while(filename = *++argv)
    {
d321 28
a348 1
    return 0;
d356 1
a356 1
    FILE *rfd;
d361 1
a361 1
    char buffer[256];
d363 3
a365 2
	unsigned long offset_ifd;
	long old_position;
d372 1
d420 1
d425 1
a425 1
	if((iHtml) || (iXml) || (iCsv) || (iJS))
d427 28
d458 1
a458 1
			debug_printf("%x %s %s", 0xFFFE, "Filename                   ", filename);
d463 1
a463 1
			my_printf("%s %s", 0xFFFE, "Filename                   ", filename);
d465 2
d545 4
d600 9
a608 1
		output_js();
d610 7
a616 1
	if((!iHtml) && (!iXml) && (!iCsv) && (!iJS))
d628 1
d639 1
d657 1
d666 1
a666 1
	struct all_wanted_tags *local_header_all_ptr;
d670 1
d718 1
d726 2
a727 2
	char *temp_ptr;
	char *token;
d730 1
d737 1
d749 1
d767 1
d779 1
d788 1
a788 1
		free(tmp2_header_start_ptr);
d791 1
a791 1
	free(temp_header_start_ptr);
d800 1
d811 1
d817 3
a819 1
		free(temp_header_ptr);
d822 3
a824 1
	free(header_ptr);
d826 1
d837 1
d845 1
a845 1
			free(temp_header_ptr);
d848 1
a848 1
		free(header_ptr);
d852 1
d860 4
a863 4
	int ctr1;
	int length;
	char *temp_ptr;
	char *final_ptr;
d866 1
d880 1
d890 4
a893 4
	int ctr1;
	int length;
	char *temp_ptr;
	char *final_ptr;
d896 1
d910 1
d920 3
a922 3
	char *temp_ptr;
	char *final_ptr;
	char *token;
d925 1
d941 1
d952 1
a952 1
	unsigned char *data_ptr;
d971 1
a971 1
	temp_ptr = (struct marker *) malloc(sizeof(struct marker));
d1001 2
a1002 2
		data_ptr = (unsigned char *) malloc(Get16u(&temp_ptr->length) + 1);
		memset(data_ptr, (int) NULL, Get16u(&temp_ptr->length) + 1);
d1022 2
a1023 2
		main_header_ptr->data_type = (char *) malloc(strlen("XMP") + 1);
		memset(main_header_ptr->data_type, (int) NULL, strlen("XMP") + 1);
d1028 2
d1037 2
a1038 2
	int ctr1;
	unsigned char *temp_ptr;
d1042 1
d1047 2
a1048 2
	temp_ptr = (unsigned char *) malloc(strlen(str_ptr) + length + 1);
	memset(temp_ptr, (int) NULL, strlen(str_ptr) + length + 1);
d1070 1
d1080 1
a1080 1
	int ctr1;
d1084 1
d1102 2
a1103 1
	local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
d1107 1
d1116 1
d1121 2
a1122 2
	local_ptr->Value = (char *) malloc(ByteCount + 1);
	memset(local_ptr->Value, (int) NULL, ByteCount + 1);
d1126 1
d1134 4
a1137 4
	int ctr1;
	char * temp_1_ptr;
	char * temp_2_ptr;
	unsigned char *buffer_ptr;
d1140 1
d1144 1
a1144 1
	buffer_ptr = (unsigned char*) malloc((2 * components * ByteCount) + 1);
d1160 2
a1161 1
	local_ptr->Value = (char *) malloc(strlen(buffer_ptr) + 1);
d1164 1
a1164 1
	free(buffer_ptr);
d1167 1
d1175 2
a1176 2
	int ctr1;
	char * temp_ptr;
d1180 1
d1200 2
a1201 1
	local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
d1205 1
a1205 12
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void my_error(FILE *rfd)
{
	if(ferror(rfd))
	{
		printf("Error number: %d", fileno(rfd));
		exit(1);
	}
d1230 10
a1239 9
        printf("\n\td70reader [-h|-v|-w|-x|-j|-c|-js] image_file_name\n");
        printf("\n\td70reader [-h|-v|-w|-x|-j|-c|-js] *.NEF *.JPG\n");
        printf("\n\t-h  = this screen");
        printf("\n\t-v  = verbose (raw data)");
        printf("\n\t-w  = generate HTML table");
        printf("\n\t-x  = generate XML tree");
        printf("\n\t-j  = extract JPG thumbnail image from NEF");
        printf("\n\t-c  = generate Comma Separated Values (CSV) data");
        printf("\n\t-js = generate JavaScript Array data\n\n");
d1314 1
a1314 1
	unsigned long mByte0;
d1324 2
a1325 1
static int Get32s(void * Long)
a1349 23
void my_fseek(FILE *rfd, long pos, int offset)
{
	long new_pos;

	trace("\n+my_fseek");

	if((new_pos = fseek(rfd, pos, offset)) != -1)
	{
		trace("\n-my_fseek");
		return;
	}
	else
	{
		my_error(rfd);
		exit(1);
	}

	trace("\n-my_fseek");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
d1355 13
a1367 13
	struct image_file_directory_entry *ifde_ptr;
	unsigned short count;
	unsigned short num_ifd;
	int a;
	unsigned long ctr1;
	unsigned long ctr2;
	unsigned long ctr3;
	long old_position;
	long temp_position;
	int ByteCount;
	unsigned long components;      		//count
	unsigned long value_offset;     	//value offset
	unsigned char *byte_ptr;
d1369 1
a1369 1
	unsigned long *long_byte_ptr;
d1371 9
a1379 9
	unsigned long numirator;
	unsigned long denominator;
	unsigned long numirator_cnvtd;
	unsigned long denominator_cnvtd;

	long snumirator;
	long sdenominator;
	long snumirator_cnvtd;
	long sdenominator_cnvtd;
d1381 2
a1382 2
	double num;
	double den;
d1384 1
a1384 1
	unsigned long maker_note_header_offset;
d1387 1
d1393 2
a1394 2
		main_header_ptr->data_type = (char *) malloc(strlen(type_ptr) + 1);
		memset(main_header_ptr->data_type, (int) NULL, strlen(type_ptr) + 1);
d1404 2
a1405 2
		main_header_ptr->data_type = (char *) malloc(strlen(type_ptr) + 1);
		memset(main_header_ptr->data_type, (int) NULL, strlen(type_ptr) + 1);
d1409 1
a1409 1
	ifde_ptr = (struct image_file_directory_entry *) malloc(sizeof(struct image_file_directory_entry));
d1451 2
a1452 1
				local_ptr->Desc = (char *) malloc(strlen(trace_buffer) + 1);
d1462 2
a1463 1
				local_ptr->Desc = (char *) malloc(strlen(trace_buffer) + 1);
d1502 2
a1503 1
				byte_ptr = (unsigned char *) malloc(ByteCount);
d1517 1
d1527 2
a1528 1
					buff_ptr = (char *) malloc(components + 1);
d1533 2
a1534 1
					local_ptr->Value = (char *) malloc(strlen(buff_ptr) + 1);
d1539 2
a1540 2
						make_ptr = (char *) malloc(components + 1);
						memset(make_ptr, (int) NULL, components + 1);
d1546 2
a1547 2
						model_ptr = (char *) malloc(components + 1);
						memset(model_ptr, (int) NULL, components + 1);
d1551 1
a1551 1
					free(buff_ptr);
d1580 1
a1580 1
						short_byte_ptr = (unsigned short *) malloc(sizeof(unsigned short));
d1599 1
a1599 1
						free(short_byte_ptr);
d1629 1
a1629 1
						long_byte_ptr = (unsigned long *) malloc(sizeof(unsigned long));
d1674 1
a1674 1
						free(long_byte_ptr);
d1788 2
a1789 1
				local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
d1835 2
a1836 1
				local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
d1927 2
a1928 1
					byte_ptr = (char *) malloc(Get32u(&ifde_ptr->count) + 1);
d1937 1
a1937 1
					free(byte_ptr);
d1962 2
a1963 2
					byte_ptr = (char *) malloc(Get32u(&ifde_ptr->count) + 1);
					memset(byte_ptr, (int) NULL, Get32u(&ifde_ptr->count) + 1);
d1970 2
a1971 1
					local_ptr->Value = (char *) malloc(strlen(byte_ptr) + 1);
d1974 1
a1974 1
					free(byte_ptr);
d1989 2
a1990 1
						local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
d2031 2
a2032 1
						local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
d2075 2
a2076 1
		local_ptr->next = (struct data_header *) malloc(sizeof(struct data_header));
d2084 1
d2092 2
a2093 2
	struct data_header_ptr *local_main_header_ptr;
	local_main_header_ptr = (struct data_header_ptr *) malloc(sizeof(struct data_header_ptr));
d2103 2
a2104 2
	struct data_header *local_header_ptr;
	local_header_ptr = (struct data_header *) malloc(sizeof(struct data_header));
d2114 2
a2115 2
	struct html_header *local_header_ptr;
	local_header_ptr = (struct html_header *) malloc(sizeof(struct html_header));
a2122 18
void trace(char *str)
{
	if(iTrace)
		printf("%s", str);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void trace_formatted(char *str)
{
	if(iTrace)
		printf("\n%s", str);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
d2127 1
a2127 1
	struct image_file_header *ifh_ptr;
d2138 1
a2138 1
	struct jpg_indicator_header *jpg_ind_hdr_ptr;
d2141 1
d2145 1
a2145 1
		ifh_ptr = (struct image_file_header *) malloc(sizeof(struct image_file_header));
d2187 2
d2192 1
a2192 1
		jpg_ind_hdr_ptr = (struct jpg_indicator_header *) malloc(sizeof(struct jpg_indicator_header));
d2232 2
d2237 1
d2246 4
a2249 4
        char buffer[256];
        static unsigned char ExifHeader[] = "Exif\0\0";
	unsigned long offset_ifd;
	struct jpg_image_file_header *jpg_ifh_ptr;
d2252 1
d2254 1
a2254 1
	jpg_ifh_ptr = (struct jpg_image_file_header *) malloc(sizeof(struct jpg_image_file_header));
d2315 2
d2318 1
d2335 1
a2335 1
	int iType;
a2358 20
void my_exit(char *text_ptr)
{
	printf("\n\n%s\n", text_ptr);
	printf("\n%s\n\n", "File is not a JPG/JPEG file");
	exit(1);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void my_jpg_exit(char *text_ptr)
{
	printf("\n\n%s\n", text_ptr);
	printf("\n%s\n\n", "File is not a NEF/RAW file");
	exit(1);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
d2361 4
d2523 22
d2549 4
d2590 1
a2590 1
					case 0x0084:		/* lens	*/
d2593 2
a2594 2
					case 0x920a:
						debug_printf("\n%#x: %s: %smm", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, precision(local_ptr->Value)));
d2596 2
a2597 2
					case 0xa405:
						debug_printf("\n%#x: %s: %smm", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
d2621 3
a2628 1
					case 0x829d:
a2646 2
					case 0xa002:
					case 0xa003:
d2811 22
d2837 7
d2881 1
a2881 1
					case 0x0084:		/* lens	*/
d2884 2
a2885 2
					case 0x920a:
						my_printf("\n%s: %smm", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, precision(local_ptr->Value)));
d2887 2
a2888 2
					case 0xa405:
						my_printf("\n%s: %smm", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
d2912 3
a2919 1
					case 0x829d:
a2937 2
					case 0xa002:
					case 0xa003:
d2953 53
d3013 1
a3013 1
	char *temp_ptr;
d3015 4
a3018 4
	char *token1;
	char *token2;
	char *token3;
	char *token4;
d3022 1
d3035 1
a3035 1
		sprintf(buffer, "%smm f/%s", truncate(token1, precision(token1)), truncate(token3, 2));
d3040 1
a3040 1
			sprintf(buffer, "%s-%smm f/%s", truncate(token1, precision(token1)), truncate(token2, 0), truncate(token3, 2));
d3042 1
a3042 1
			sprintf(buffer, "%s-%smm f/%s-%s", truncate(token1, precision(token1)), truncate(token2, 0), truncate(token3, 2), truncate(token4, 2));
d3045 7
a3051 3
	final_ptr = (char *) malloc(strlen(buffer) + 1);
	memset(final_ptr, (int) NULL, strlen(buffer) + 1);
	strcpy(final_ptr, buffer);
d3054 1
d3063 2
a3064 2
	char *temp_ptr;
	char *char_ptr;
d3086 2
a3087 2
		html_header_ptr->Desc = (char *) malloc(strlen(str_desc) + 1);
		memset(html_header_ptr->Desc, (int) NULL, strlen(str_desc) + 1);
d3090 2
a3091 2
		html_header_ptr->Value = (char *) malloc(strlen(str_value) + 1);
		memset(html_header_ptr->Value, (int) NULL, strlen(str_value) + 1);
d3103 2
a3104 2
		html_header_ptr->Desc = (char *) malloc(strlen(str_desc) + 1);
		memset(html_header_ptr->Desc, (int) NULL, strlen(str_desc) + 1);
d3107 2
a3108 2
		html_header_ptr->Value = (char *) malloc(strlen(str_value) + 1);
		memset(html_header_ptr->Value, (int) NULL, strlen(str_value) + 1);
d3114 1
a3114 1
	if((!iHtml) && (!iXml) && (!iCsv) && (!iJS))
d3127 2
a3128 2
		html_header_ptr->Desc = (char *) malloc(strlen(str_desc) + 1);
		memset(html_header_ptr->Desc, (int) NULL, strlen(str_desc) + 1);
d3131 2
a3132 2
		html_header_ptr->Value = (char *) malloc(strlen(str_value) + 1);
		memset(html_header_ptr->Value, (int) NULL, strlen(str_value) + 1);
d3144 2
a3145 2
		html_header_ptr->Desc = (char *) malloc(strlen(str_desc) + 1);
		memset(html_header_ptr->Desc, (int) NULL, strlen(str_desc) + 1);
d3148 2
a3149 2
		html_header_ptr->Value = (char *) malloc(strlen(str_value) + 1);
		memset(html_header_ptr->Value, (int) NULL, strlen(str_value) + 1);
d3155 1
a3155 1
	if((!iHtml) && (!iXml) && (!iCsv) && (!iJS))
d3164 8
a3171 8
	int ibyte_count;
	unsigned int ubyte1;
	unsigned int ubyte2;
	unsigned int ubyte3;
	unsigned int ubyte4;
	unsigned int ubyte5;
	unsigned int ubyte6;
	unsigned long ulong;
d3174 1
d3334 3
a3336 2
        local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
        strcpy(local_ptr->Value, trace_buffer);
d3342 1
d3353 12
a3364 12
	struct image_file_directory_entry *ifde_ptr;
	unsigned short count;
	unsigned short num_ifd;
	unsigned long ctr1;
	unsigned long ctr3;
	long old_position;
	long temp_position;
	int ByteCount;
	unsigned long components;      		//count
	unsigned long value_offset;     	//value offset
	unsigned char *byte_ptr;
	unsigned long *long_byte_ptr;
d3366 1
a3366 1
	unsigned long maker_note_header_offset;
d3369 1
d3374 1
a3374 1
	ifde_ptr = (struct image_file_directory_entry *) malloc(sizeof(struct image_file_directory_entry));
d3455 2
a3456 1
					byte_ptr = (unsigned char *) malloc(ByteCount);
d3472 2
a3473 1
					byte_ptr = (unsigned char *) malloc(ByteCount);
d3480 2
a3481 2
						make_ptr = (char *) malloc(components + 1);
						memset(make_ptr, (int) NULL, components + 1);
d3487 2
a3488 2
						model_ptr = (char *) malloc(components + 1);
						memset(model_ptr, (int) NULL, components + 1);
d3504 2
a3505 1
					byte_ptr = (unsigned char *) malloc(ByteCount);
d3536 1
a3536 1
							long_byte_ptr = (unsigned long *) malloc(sizeof(unsigned long));
d3562 2
a3563 1

d3579 1
a3579 1
						free(long_byte_ptr);
d3583 2
a3584 1
						byte_ptr = (unsigned char *) malloc(ByteCount);
d3664 2
a3665 1
				byte_ptr = (unsigned char *) malloc(ByteCount);
d3679 2
a3680 1
				byte_ptr = (unsigned char *) malloc(ByteCount);
d3693 2
a3694 1
				byte_ptr = (unsigned char *) malloc(ByteCount);
d3745 2
a3746 1
		jpg_header_ptr->next = (struct jpg_data_header *) malloc(sizeof(struct jpg_data_header));
d3755 1
d3763 2
a3764 2
	struct jpg_data_header *local_header_ptr;
	local_header_ptr = (struct jpg_data_header *) malloc(sizeof(struct jpg_data_header));
d3780 2
d3837 1
a3837 1
	FILE *ofd;
d3839 4
a3842 4
	unsigned long size;
	unsigned char *byte_ptr;
	unsigned char *file_ptr;
	unsigned char *file_tmp_ptr;
d3897 1
d3899 1
a3899 1
	exif_header_ptr = (struct exif_header *) malloc(sizeof(struct exif_header));
d3919 3
a3921 2
		printf("dir_count: %d\n", dir_count);
		printf("iTagCount: %d\n", iTagCount);
d3926 2
a3927 1
	dir_buffer_ptr = (unsigned char *) malloc((12 * dir_count) + 4);
d3929 2
a3930 1
	data_buffer_ptr = (unsigned char *) malloc(1024);
d3948 2
d4008 2
a4009 1
						type5_ptr = (struct type5 *) malloc(sizeof(struct type5));
d4015 1
a4015 1
						free(type5_ptr);
d4019 2
a4020 1
						lens_ptr = (struct lens *) malloc(sizeof(struct lens));
d4032 1
a4032 1
						free(lens_ptr);
d4104 2
d4164 2
a4165 1
					type5_ptr = (struct type5 *) malloc(sizeof(struct type5));
d4171 1
a4171 1
					free(type5_ptr);
d4175 2
a4176 1
					lens_ptr = (struct lens *) malloc(sizeof(struct lens));
d4188 1
a4188 1
					free(lens_ptr);
d4259 1
a4259 1
			file_tmp_ptr = (char *) malloc(strlen(filename) + strlen(".tmp") + strlen(".JPG") + 1);
d4269 1
a4269 1
	file_ptr = (char *) malloc(strlen(filename) + strlen(".JPG") + 1);
d4277 2
a4278 1
	byte_ptr = (char *) malloc(lThumbnailLength);
d4374 2
a4375 2
	free(byte_ptr);
	free(file_ptr);
d4377 6
a4382 3
	free(exif_header_ptr);
	free(dir_buffer_ptr);
	free(data_buffer_ptr);
d4385 1
d4396 1
d4402 1
a4402 1
		free(temp_header_ptr);
d4405 1
a4405 1
	free(header_ptr);
d4407 1
d4415 1
a4415 1
	FILE *rfd;
d4418 1
a4418 1
	unsigned long offset_ifd;
d4425 1
d4469 1
d4480 3
a4482 3
	long position;
	long old_position;
	int oldMotorolaOrder;
d4499 2
a4500 1
	temp_ptr = (struct marker *) malloc(sizeof(struct marker));
d4529 2
d4540 1
a4540 1
	unsigned long size;
d4545 4
a4548 4
	FILE *ofd;
	FILE *rfd;
	struct wanted_tags *local_header_ptr;
	struct all_wanted_tags *local_header_all_ptr;
d4551 1
d4555 2
a4556 2
		file_ptr = (char *) malloc(strlen(file_sys_dir_ptr) + strlen("\\d70reader.conf") + 1);
		memset(file_ptr, (int) NULL, strlen(file_sys_dir_ptr) + strlen("\\d70reader.conf") + 1);
d4562 2
a4563 2
		file_ptr = (char *) malloc(strlen(file_sys_dir_ptr) + strlen("/d70reader.conf") + 1);
		memset(file_ptr, (int) NULL, strlen(file_sys_dir_ptr) + strlen("/d70reader.conf") + 1);
d4616 2
d4623 2
a4624 2
					data_buffer_ptr = (char *) malloc(strlen(strip(TagTable[ctr1].Desc)) + 6);
					memset(data_buffer_ptr, (int) NULL, strlen(strip(TagTable[ctr1].Desc)) + 6);
d4635 1
a4635 1
					free(data_buffer_ptr);
d4700 4
a4703 1
	trace("\n+check_for_config");
d4711 1
a4711 1
	int ctr1;
d4715 1
d4743 1
d4750 1
d4758 1
a4758 1
	int ctr1;
d4762 1
d4788 1
d4794 1
d4802 2
a4803 2
	struct all_wanted_tags *local_header_ptr;
	local_header_ptr = (struct all_wanted_tags *) malloc(sizeof(struct all_wanted_tags));
d4813 2
a4814 2
	struct wanted_tags *local_header_ptr;
	local_header_ptr = (struct wanted_tags *) malloc(sizeof(struct wanted_tags));
d4825 3
a4827 3
	char *temp_ptr;
	char *final_ptr;
	char *token;
d4830 1
d4851 1
d4862 1
a4862 1
	struct wanted_tags *local_header_ptr;
d4865 1
d4893 1
d4902 2
a4903 2
	char *temp_ptr;
	char *token;
d4906 1
d4913 1
d4920 1
a4920 1
void output_js()
d4923 1
a4923 1
	struct all_wanted_tags *local_header_all_ptr;
d4927 1
d4929 1
a4929 1
	if(iJS_First_Time)
d4931 3
a4933 3
		printf("aExifData = new Array()");
		printf("\naExifDataHeader = new Array()");
		printf("\naExifDataHeader[0] = new Array(\"D70ReaderProgramVersion\",\"Filename\"");
d4942 1
a4942 1
					printf("\n%d - %x - \"%s\",", ctr1++, local_header_all_ptr->tag, get_description_label(local_header_all_ptr->tag, 1));
d4944 1
a4944 1
				printf(",\"%s\"", get_description_label(local_header_all_ptr->tag, 1));
d4951 1
a4951 1
		printf(")\n");
d4953 1
a4953 1
		iJS_First_Time = 0;
d4956 1
a4956 1
	printf("aExifData[%d] = new Array(\"%s\",\"%s\"", js_ctr1++, D70_VERSION, get_description_value(0xFFFE));
d4965 1
a4965 1
				printf("\n%d - %x - \"%s\",", ctr1++, local_header_all_ptr->tag, get_description_value(local_header_all_ptr->tag));
d4967 1
a4967 1
			printf(",\"%s\"", get_description_value(local_header_all_ptr->tag));
d4974 1
a4974 1
	printf(")\n");
d4977 1
d4983 1
a4983 1
char * get_description_label(unsigned short Tag, int iStrip)
d4987 1
d4997 2
a4998 2
			local_ptr = (char *) malloc(strlen(trace_buffer) + 1);
			memset(local_ptr, (int) NULL, strlen(trace_buffer) + 1);
d5008 2
a5009 2
			local_ptr = (char *) malloc(strlen(trace_buffer) + 1);
			memset(local_ptr, (int) NULL, strlen(trace_buffer) + 1);
d5020 1
a5020 1
		return(strip(local_ptr));
d5022 5
a5026 1
		return(local_ptr);
d5035 1
d5038 3
d5045 6
d5055 1
a5055 1
				local_ptr = (char *) malloc(3);
d5061 2
a5062 2
				local_ptr = (char *) malloc(strlen(local_header_start_ptr->Value) + 1);
				memset(local_ptr, (int) NULL, strlen(local_header_start_ptr->Value) + 1);
d5076 1
a5076 1
			local_ptr = (char *) malloc(3);
d5082 2
a5083 2
			local_ptr = (char *) malloc(strlen(local_header_start_ptr->Value) + 1);
			memset(local_ptr, (int) NULL, strlen(local_header_start_ptr->Value) + 1);
d5090 1
a5090 1
		local_ptr = (char *) malloc(3);
d5095 7
a5101 1
	return(local_ptr);
d5110 3
a5112 3
	char *temp_ptr;
	char *token1;
	char *token2;
d5115 1
d5128 1
d5143 4
a5146 4
	unsigned short length;
	long position;
	long old_position;
	int oldMotorolaOrder;
d5156 1
a5156 1
	struct marker *temp_ptr;
d5163 1
a5163 1
	temp_ptr = (struct marker *) malloc(sizeof(struct marker));
d5193 2
a5194 2
		data_ptr = (unsigned char *) malloc(Get16u(&temp_ptr->length) + 1);
		memset(data_ptr, (int) NULL, Get16u(&temp_ptr->length) + 1);
d5199 1
a5199 1
		xmp_ptr = (struct xmp_packet *) malloc(sizeof(struct xmp_packet));
d5210 69
@


1.26
log
@Added Adobe XMP info to instruct function.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.25 2005/03/04 16:16:03 joman Exp joman $	*/
d118 1
a118 1
static char rcsid[] = "$Id: d70reader.c,v 1.25 2005/03/04 16:16:03 joman Exp joman $";
d577 5
@


1.25
log
@See revision information in source for Version 0.18.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.24 2005/02/21 20:50:47 joman Exp joman $	*/
d118 1
a118 1
static char rcsid[] = "$Id: d70reader.c,v 1.24 2005/02/21 20:50:47 joman Exp joman $";
d1466 3
@


1.24
log
@See Version 0.17 description in code.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.23 2005/02/19 19:15:37 joman Exp joman $	*/
d77 9
d105 1
d115 2
a116 2
#define D70_VERSION "0.17"
#define D70_DATE "Mon Feb 21 20:49:20 UTC 2005"
d118 1
a118 1
static char rcsid[] = "$Id: d70reader.c,v 1.23 2005/02/19 19:15:37 joman Exp joman $";
d126 1
d134 2
d148 1
d219 14
d236 7
d246 1
d249 1
d260 1
d263 1
a263 1
void my_printf(char *str_format, char *str_desc, char *str_value);
d556 4
d670 3
d681 6
a686 2
        FILE *rfd;
        char buffer[256];
a696 6
	if((rfd = fopen(filename, "rb")) == NULL)
	{
		printf("\nFile not found: %s\n\n", filename);
		exit(1);
	}

d709 18
a726 2
		iJPG_Type = 99;
		iFile_Type = 1;
d729 1
a729 1
	if((!iHtml) && (!iXml) && (!iCsv))
d739 1
a739 1
			if(!iCsv)
d747 1
a747 1
	if((iHtml) || (iXml) || (iCsv))
d751 1
a751 1
			debug_printf("%x %s %s", 0xFFFE, "D70ReaderProgramVersion    ", D70_VERSION);
d756 2
a757 2
			my_printf("%s %s", "D70ReaderProgramVersion    ", D70_VERSION);
			my_printf("%s %s", "Filename                   ", filename);
d772 1
d775 16
a790 1
		get_xmp_data(rfd, get_new_data_header_ptr());
d792 1
d854 22
d887 4
a890 1
	if((!iHtml) && (!iXml) && (!iCsv))
d893 6
d936 2
a941 2
	local_header_start_ptr = html_header_start_ptr;

d944 5
a948 1
		while(local_header_start_ptr->next != NULL)
d950 4
a953 1
			printf("%s,", strip(local_header_start_ptr->Desc));
d955 4
a958 1
			local_header_start_ptr = local_header_start_ptr->next;
d960 1
d962 1
a962 1
		printf("%s\n", strip(local_header_start_ptr->Desc));
d967 3
a969 1
	local_header_start_ptr = html_header_start_ptr;
d971 1
a971 1
	while(local_header_start_ptr->next != NULL)
d973 7
a979 1
		printf("\"%s\",", local_header_start_ptr->Value);
d981 1
a981 1
		local_header_start_ptr = local_header_start_ptr->next;
d983 1
d985 1
a985 1
	printf("\"%s\"\n", local_header_start_ptr->Value);
d1095 1
a1095 1
	while(header_ptr->next != NULL)
d1097 8
a1104 3
		temp_header_ptr = header_ptr;
		header_ptr = header_ptr->next;
		free(temp_header_ptr);
a1106 1
	free(header_ptr);
d1250 2
a1251 2
		data_ptr = (unsigned char *) malloc(Get16u(&temp_ptr->length));
		memset(data_ptr, (int) NULL, Get16u(&temp_ptr->length));
d1466 1
a1466 1
        printf("\nThis program only works with Nikon D70/D100 image files.");
d1473 9
a1481 8
        printf("\n\td70reader [-h|-v|-w|-x|-j|-c] image_file_name\n");
        printf("\n\td70reader [-h|-v|-w|-x|-j|-c] *.NEF *.JPG\n");
        printf("\n\t-h = this screen");
        printf("\n\t-v = verbose (raw data)");
        printf("\n\t-w = generate HTML table");
        printf("\n\t-x = generate XML tree");
        printf("\n\t-j = extract JPG thumbnail image from NEF");
        printf("\n\t-c = generate Comma Separated Values (CSV) data\n\n");
d2841 1
a2841 1
						debug_printf("\n%#x: %s: %smm", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, 0));
d2905 1
a2905 1
		else
d2918 1
a2918 1
						my_printf("\n%s: %s seconds", local_ptr->Desc, buffer);
d2923 1
a2923 1
							my_printf("\n%s: %s", local_ptr->Desc, "No Flash");
d2927 1
a2927 1
							my_printf("\n%s: %s", local_ptr->Desc, "Fired");
d2931 1
a2931 1
							my_printf("\n%s: %s", local_ptr->Desc, "Fired, Return not detected");
d2935 1
a2935 1
							my_printf("\n%s: %s", local_ptr->Desc, "Fired, Return detected");
d2939 1
a2939 1
							my_printf("\n%s: %s", local_ptr->Desc, "On");
d2943 1
a2943 1
							my_printf("\n%s: %s", local_ptr->Desc, "On, Return not detected");
d2947 1
a2947 1
							my_printf("\n%s: %s", local_ptr->Desc, "On, Return detected");
d2951 1
a2951 1
							my_printf("\n%s: %s", local_ptr->Desc, "Off");
d2955 1
a2955 1
							my_printf("\n%s: %s", local_ptr->Desc, "Auto, Did not fire");
d2959 1
a2959 1
							my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired");
d2963 1
a2963 1
							my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Return not detected");
d2967 1
a2967 1
							my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Return detected");
d2971 1
a2971 1
							my_printf("\n%s: %s", local_ptr->Desc, "No flash function");
d2975 1
a2975 1
							my_printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction");
d2979 1
a2979 1
							my_printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction, Return not detected");
d2983 1
a2983 1
							my_printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction, Return detected");
d2987 1
a2987 1
							my_printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction");
d2991 1
a2991 1
							my_printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction, Return not detected");
d2995 1
a2995 1
							my_printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction, Return detected");
d2999 1
a2999 1
							my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction");
d3003 1
a3003 1
							my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return not detected");
d3007 1
a3007 1
							my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return detected");
d3011 1
a3011 1
							my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3017 1
a3017 1
							my_printf("\n%s: %s", local_ptr->Desc, "Program AE");
d3021 1
a3021 1
							my_printf("\n%s: %s", local_ptr->Desc, "Auto");
d3025 1
a3025 1
							my_printf("\n%s: %s", local_ptr->Desc, "Shutter speed priority AE");
d3029 1
a3029 1
							my_printf("\n%s: %s", local_ptr->Desc, "Aperture-priority AE");
d3033 1
a3033 1
							my_printf("\n%s: %s", local_ptr->Desc, "Manual");
d3037 1
a3037 1
							my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3043 1
a3043 1
							my_printf("\n%s: %s", local_ptr->Desc, "Multi-segment");
d3047 1
a3047 1
							my_printf("\n%s: %s", local_ptr->Desc, "Spot");
d3051 1
a3051 1
							my_printf("\n%s: %s", local_ptr->Desc, "Center-weighted average");
d3055 1
a3055 1
							my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3064 1
a3064 1
							my_printf("\n%s: %s", local_ptr->Desc, "Horizontal (normal)");
d3068 1
a3068 1
							my_printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal");
d3072 1
a3072 1
							my_printf("\n%s: %s", local_ptr->Desc, "Rotated 180");
d3076 1
a3076 1
							my_printf("\n%s: %s", local_ptr->Desc, "Mirrored vertical");
d3080 1
a3080 1
							my_printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal then rotated 90 CCW");
d3084 1
a3084 1
							my_printf("\n%s: %s", local_ptr->Desc, "Rotated 90 CW");
d3088 1
a3088 1
							my_printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal then rotated 90 CW");
d3092 1
a3092 1
							my_printf("\n%s: %s", local_ptr->Desc, "Rotated 90 CCW");
d3096 1
a3096 1
							my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3100 1
a3100 1
						my_printf("\n%s: %s", local_ptr->Desc, convert_lens(local_ptr->Value));
d3103 1
a3103 1
						my_printf("\n%s: %smm", local_ptr->Desc, truncate(local_ptr->Value, 0));
d3106 1
a3106 1
						my_printf("\n%s: %smm", local_ptr->Desc, local_ptr->Value);
d3111 1
a3111 1
							my_printf("\n%s: %s", local_ptr->Desc, "D");
d3115 1
a3115 1
							my_printf("\n%s: %s", local_ptr->Desc, "G");
d3119 1
a3119 1
							my_printf("\n%s: %s", local_ptr->Desc, "G-VR");
d3123 1
a3123 1
							my_printf("\n%s: %s", local_ptr->Desc, "D-VR");
d3127 1
a3127 1
							my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3160 1
a3160 1
						my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3199 1
a3199 1
		sprintf(buffer, "%smm f/%s", truncate(token1, 0), truncate(token3, 2));
d3204 1
a3204 1
			sprintf(buffer, "%s-%smm f/%s", truncate(token1, 0), truncate(token2, 0), truncate(token3, 2));
d3206 1
a3206 1
			sprintf(buffer, "%s-%smm f/%s-%s", truncate(token1, 0), truncate(token2, 0), truncate(token3, 2), truncate(token4, 2));
d3253 2
d3269 2
d3273 1
a3273 1
	if((!iHtml) && (!iXml) && (!iCsv))
d3280 1
a3280 1
void my_printf(char *str_format, char *str_desc, char *str_value)
d3294 2
d3310 2
d3314 1
a3314 1
	if((!iHtml) && (!iXml) && (!iCsv))
d4569 2
a4570 2
		printf("\nFile not found: %s\n\n", filename);
		exit(1);
d4667 1
d4750 1
d4782 1
d4788 2
d4796 1
a4796 1
				printf("\nTag: %x", local_header_ptr->tag);
d4800 13
d4866 52
d4976 1
a4976 1
	do
d4978 1
a4978 1
		if(local_header_ptr->tag == tag)
d4980 9
a4988 2
			iWanted = 1;
			break;
d4990 1
a4990 4
		else
			iWanted = 0;

		local_header_ptr = local_header_ptr->next;
a4991 1
	while(local_header_ptr != NULL); 
d5018 268
@


1.23
log
@Version 0.16 changes.  Read code for changes.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.22 2005/02/15 03:57:32 joman Exp joman $	*/
d73 4
d105 2
a106 2
#define D70_VERSION "0.16"
#define D70_DATE "Sat Feb 19 19:02:36 UTC 2005"
d108 1
a108 1
static char rcsid[] = "$Id: d70reader.c,v 1.22 2005/02/15 03:57:32 joman Exp joman $";
d126 2
d129 1
d258 1
d283 1
d309 1
a309 1
  { 0x005,   "WhilteBalance              "},
d646 1
a646 1
	trace("+ProcessFile\n");
d657 1
a657 1
	sprintf(trace_buffer, "File Extension: %s\n", temp_ptr);
d683 1
a708 3
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "old_position: %x\n", old_position);
	trace(trace_buffer);
a711 3
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "offset_ifd: %x\n", offset_ifd);
	trace(trace_buffer);
d794 1
a794 1
	trace("-ProcessFile\n");
d804 1
a804 1
	trace("+output_xml\n");
d821 1
a821 1
	trace("-output_xml\n");
d831 1
a831 1
	trace("+output_csv\n");
d860 1
a860 1
	trace("-output_csv\n");
d871 1
a871 1
	trace("+strip\n");
d877 1
a877 1
	trace("-strip\n");
d888 1
a888 1
	trace("+output_html\n");
d905 1
a905 1
	trace("-output_html\n");
d916 1
a916 1
	trace("+free_memory\n");
d936 1
a936 1
	trace("-free_memory\n");
d946 1
a946 1
	trace("+free_data_header_list\n");
d956 1
a956 1
	trace("-free_data_header_list\n");
d966 1
a966 1
	trace("+free_html_header_list\n");
d976 1
a976 1
	trace("-free_html_header_list\n");
d989 1
a989 1
	trace("+upper_case\n");
d1002 1
a1002 1
	trace("-upper_case\n");
d1017 1
a1017 1
	trace("+lower_case\n");
d1030 1
a1030 1
	trace("-lower_case\n");
d1044 1
a1044 1
	trace("+get_extension\n");
a1051 4
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "token: %s\n", token);
		trace(trace_buffer);

d1059 1
a1059 1
	trace("-get_extension\n");
d1157 1
a1157 13
	trace("+pad_field\n");

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "str_ptr: %s\n", str_ptr);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "length: %d\n", length);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "pad_char: %c\n", pad_char);
	trace(trace_buffer);
d1184 1
a1184 5
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "temp_ptr: %s\n", temp_ptr);
	trace(trace_buffer);

	trace("-pad_field\n");
d1197 1
a1197 1
	trace("\n+print_8bit_hex\n");
a1200 8
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "byte_ptr: %s\n", byte_ptr);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
	trace(trace_buffer);

a1206 1
		trace(trace_buffer);
d1212 2
a1213 2
	sprintf(trace_buffer, "%s ", buffer); 
	trace(trace_buffer);
d1218 1
a1218 1
	trace("\n-print_8bit_hex\n");
d1226 1
a1226 1
	trace("+print_8bit_bytes\n");
d1235 1
a1235 1
	trace("\n-print_8bit_bytes\n");
d1244 12
a1255 22
	char * temp_ptr;
	char buffer[256];

	trace("+print_16bit_hex\n");

	assert(ByteCount < 256);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "byte_ptr: %s\n", byte_ptr);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "components: %d\n", components);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
	trace(trace_buffer);

	temp_ptr = strdup(byte_ptr);

	memset(buffer, (int) NULL, 256);
d1259 2
a1260 9
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nctr1: %d\n", ctr1);
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
		strncpy(trace_buffer, temp_ptr, ByteCount);
		trace(trace_buffer);
		strcat(buffer, trace_buffer);
		strcat(buffer, " ");
d1262 2
a1263 1
		temp_ptr += ByteCount;
d1266 1
a1266 3
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "\nBUFFER: %s\n", buffer);
	trace(trace_buffer);
d1268 2
a1269 2
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "%s ", buffer); 
d1271 1
a1271 2
	local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
	strcpy(local_ptr->Value, trace_buffer);
d1273 1
a1273 1
	trace("\n-print_16bit_hex\n");
d1285 1
a1285 3
	trace("+print_16bit_bytes\n");

	assert(ByteCount < 256);
d1287 1
a1287 11
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "byte_ptr: %s\n", byte_ptr);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "components: %d\n", components);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
	trace(trace_buffer);
a1295 4
		sprintf(trace_buffer, "\nctr1: %d\n", ctr1);
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
a1296 1
		trace(trace_buffer);
a1302 4
	sprintf(trace_buffer, "\nBUFFER: %s\n", buffer);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
d1308 1
a1308 1
	trace("\n-print_16bit_bytes\n");
d1463 1
a1463 5
	trace("+my_fseek\n");

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "pos: %x\n", pos);
	trace(trace_buffer);
a1464 4
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "offset: %d\n", offset);
	trace(trace_buffer);
	
d1467 1
a1467 5
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "new_pos: %ld\n", new_pos);
		trace(trace_buffer);

		trace("-my_fseek\n");
d1476 1
a1476 1
	trace("-my_fseek\n");
d1518 1
a1518 1
	trace("+dump_image_file_directory\n");
d1549 1
a1549 1
		sprintf(trace_buffer, "Number of Image File Directories: %d\n", num_ifd);
d1560 1
a1560 1
		sprintf(trace_buffer, "\nctr1: %d\n", ctr1);
d1567 1
a1567 1
		sprintf(trace_buffer, "Tag: %x\n", Get16u(&ifde_ptr->tag));
a1590 1
				trace(trace_buffer);
d1594 4
d1603 1
a1603 1
		sprintf(trace_buffer, "Field Type: %x\n", Get16u(&ifde_ptr->field_type));
d1607 1
a1607 1
		sprintf(trace_buffer, "Number of Values: %x\n", Get32u(&ifde_ptr->count));
d1611 1
a1611 1
		sprintf(trace_buffer, "Value Offset: %x\n", Get32u(&ifde_ptr->value_offset));
d1618 1
a1618 1
		sprintf(trace_buffer, "components: %d\n", components);
d1628 1
a1628 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
a1653 8
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nvalue_offset: %x", Get32u(&ifde_ptr->value_offset)); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\noffset_base: %x\n", offset_base); 
					trace(trace_buffer);

d1657 1
a1657 1
					trace(buff_ptr);
d1669 6
d1687 1
a1687 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d1693 1
a1693 1
					sprintf(trace_buffer, "Value Offset: %x\n", Get32u(&ifde_ptr->value_offset));
d1700 1
a1700 1
					sprintf(trace_buffer, "temp_position: %x\n", temp_position);
d1712 1
a1712 1
						sprintf(trace_buffer, "get16u_short_byte_ptr: %x\n", Get16u(short_byte_ptr));
d1716 1
a1716 1
						sprintf(trace_buffer, "buffer: %s\n", buffer);
d1720 1
a1720 1
						sprintf(trace_buffer, "short_byte_ptr: %x\n", *short_byte_ptr);
d1736 1
a1736 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d1742 1
a1742 1
					sprintf(trace_buffer, "Value Offset: %x\n", Get32u(&ifde_ptr->value_offset));
d1749 1
a1749 1
					sprintf(trace_buffer, "temp_position: %x\n", temp_position);
d1762 1
a1762 1
							trace("------Start SubIFD------\n");
d1768 1
a1768 1
							sprintf(trace_buffer, "temp_position: %x\n", temp_position);
d1772 1
a1772 1
							sprintf(trace_buffer, "offset to count: %x\n", (Get32u(long_byte_ptr)));
d1783 1
a1783 1
							trace("------End SubIFD------\n");
d1787 1
a1787 1
						sprintf(trace_buffer, "get33u_long_byte_ptr: %x\n", Get32u(long_byte_ptr));
d1791 1
a1791 1
						sprintf(trace_buffer, "buffer: %s\n", buffer);
d1795 1
a1795 1
						sprintf(trace_buffer, "long_byte_ptr: %x\n", *long_byte_ptr);
d1806 25
d1836 1
a1836 1
						sprintf(trace_buffer, "lThumbnailOffset: %ld\n", lThumbnailOffset);
d1845 1
a1845 1
						sprintf(trace_buffer, "lThumbnailLength: %ld\n", lThumbnailLength);
d1851 1
a1851 1
						trace("------Start EXIF------\n");
d1856 1
a1856 1
						sprintf(trace_buffer, "temp_position: %x\n", temp_position);
d1867 1
a1867 1
						trace("------End EXIF------\n");
d1883 1
a1883 1
					sprintf(trace_buffer, "numirator: %x\n", numirator);
d1889 1
a1889 1
					sprintf(trace_buffer, "denominator: %x\n", denominator);
d1906 1
a1906 1
					trace(trace_buffer);
d1929 1
a1929 1
					sprintf(trace_buffer, "snumirator: %x\n", snumirator);
d1935 1
a1935 1
					sprintf(trace_buffer, "sdenominator: %x\n", sdenominator);
d1952 1
a1952 1
					trace(trace_buffer);
d1967 1
a1967 1
					trace("------Start FileSource/SceneType------\n");
d1977 1
a1977 1
					sprintf(trace_buffer, "\ncount: %d\n", Get32u(&ifde_ptr->count)); 
d1987 1
a1987 1
					trace("\n------End FileSource/SceneType------\n");
d2005 1
a2005 1
					trace("------Start print_16bit_hex Tags------\n");
d2015 1
a2015 5
					sprintf(trace_buffer, "\ncount: %d\n", Get32u(&ifde_ptr->count)); 
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%x", Get32u(&ifde_ptr->value_offset)); 
d2021 1
a2021 1
					trace("\n------End print_16bit_hex Tags------\n");
d2034 1
a2034 1
					trace("------Start print_8bit_hex Tags------\n");
d2043 1
a2043 1
					sprintf(trace_buffer, "\noffset_base: %x\n", offset_base); 
d2047 1
a2047 1
					sprintf(trace_buffer, "\ncount: %d\n", Get32u(&ifde_ptr->count)); 
d2061 1
a2061 1
					trace("\n------End print_8bit_hex Tags------\n");
d2068 1
a2068 1
					trace("------Start UserComment------\n");
d2077 1
a2077 1
					sprintf(trace_buffer, "\noffset_base: %x\n", offset_base); 
d2081 1
a2081 1
					sprintf(trace_buffer, "\ncount: %d\n", Get32u(&ifde_ptr->count)); 
d2084 10
a2093 4
					fread(buffer, Get32u(&ifde_ptr->count), 1, rfd);
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%s", buffer); 
					trace(trace_buffer);
d2095 1
a2095 2
					local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
					strcpy(local_ptr->Value, trace_buffer);
d2097 1
a2097 1
					trace("\n------End UserComment------\n");
d2104 39
a2142 2
					if(strncmp(upper_case(make_ptr), "NIKON", 5))
						break;
d2144 4
a2147 1
					trace("------Start Maker Notes------\n");
d2149 4
a2152 4
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%x", Get32u(&ifde_ptr->value_offset));
					local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
					strcpy(local_ptr->Value, trace_buffer);
d2154 2
a2155 2
					//save file ptr
					temp_position = ftell(rfd);
d2157 3
a2159 3
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "old_file_position: %x\n", temp_position);
					trace(trace_buffer);
d2161 1
a2161 1
					old_byte_order = MotorolaOrder;
d2163 1
a2163 1
					maker_note_header_offset = Get32u(&ifde_ptr->value_offset) + MAKER_NOTE_PRE_HEADER_LENGTH + jpg_type_offset();
d2165 3
a2167 3
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "maker_note_header_offset: %x\n", maker_note_header_offset);
					trace(trace_buffer);
d2169 1
a2169 1
					fseek(rfd, maker_note_header_offset, 0);
d2171 2
a2172 2
					memset(type_buffer, (int) NULL, 256);
					sprintf(type_buffer, "MAKER_NOTES");
d2174 2
a2175 2
					//call dump_.... with offset
					dump_image_file_directory(rfd, (maker_note_header_offset + inspect_image_file_header(rfd, 1)), maker_note_header_offset, get_new_data_header_ptr(), type_buffer);
d2177 1
a2177 1
					MotorolaOrder = old_byte_order;
d2179 5
a2183 3
					//restore file ptr
					fseek(rfd, temp_position, 0);
					trace("------End Maker Notes------\n");
d2189 1
a2189 1
				sprintf(trace_buffer, "Unknown Format: %x\n", Get16u(&ifde_ptr->field_type));
d2201 1
a2201 1
	trace("-dump_image_file_directory\n");
d2249 9
d2275 1
a2275 1
	trace("\n+inspect_image_file_header\n");
d2295 1
a2295 1
			sprintf(trace_buffer, "Byte Order: %s\n", buffer);
d2298 1
a2298 1
			sprintf(trace_buffer, "Image File Type: %x\n", Get16u(&ifh_ptr->image_file_type));
d2301 1
a2301 1
			sprintf(trace_buffer, "Offset To First IFD: %x\n", offset_ifd);
d2366 1
a2366 1
	trace("\n-inspect_image_file_header\n");
d2380 1
a2380 1
	trace("\n+get_jpg_type_and_offset\n");
d2403 1
a2403 1
		sprintf(trace_buffer, "Byte Order: %s\n", buffer);
d2406 1
a2406 1
		sprintf(trace_buffer, "Image File Type: %x\n", Get16u(&jpg_ifh_ptr->image_file_type));
d2409 1
a2409 1
		sprintf(trace_buffer, "Offset To First IFD: %x\n", offset_ifd);
d2443 1
a2443 1
	trace("\n-get_jpg_type_and_offset\n");
d2745 2
d3007 2
d3054 1
a3054 1
	trace("+convert_lens\n");
d3081 1
a3081 1
	trace("-convert_lens\n");
d3192 1
a3192 1
	trace("+extract_and_format_data\n");
d3203 1
d3225 1
d3356 1
a3356 1
		printf("\ntrace_buffer: %s\n", trace_buffer);
d3358 1
a3358 1
	trace("-extract_and_format_data\n");
d3384 1
a3384 1
	trace("+dump_jpg_image_file_directory\n");
d3387 1
a3387 1
		printf("type_ptr: %s\n", type_ptr);
d3398 1
a3398 1
		sprintf(trace_buffer, "Number of Image File Directories: %d\n", num_ifd);
d3409 1
a3409 1
		sprintf(trace_buffer, "\nctr1: %d\n", ctr1);
d3416 1
a3416 1
		sprintf(trace_buffer, "tag: %x\n", Get16u(&ifde_ptr->tag));
d3438 1
a3438 1
		sprintf(trace_buffer, "Field Type: %x\n", Get16u(&ifde_ptr->field_type));
d3442 1
a3442 1
		sprintf(trace_buffer, "Number of Values: %x\n", Get32u(&ifde_ptr->count));
d3446 1
a3446 1
		sprintf(trace_buffer, "Value Offset: %x\n", Get32u(&ifde_ptr->value_offset));
d3453 1
a3453 1
		sprintf(trace_buffer, "components: %d\n", components);
d3463 1
a3463 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d3480 1
a3480 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d3490 14
d3511 1
a3511 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d3527 1
a3527 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d3536 1
a3536 1
						sprintf(trace_buffer, "Value Offset: %x\n", Get32u(&ifde_ptr->value_offset));
d3543 1
a3543 1
						sprintf(trace_buffer, "temp_position: %x\n", temp_position);
d3554 1
a3554 1
							trace("------Start SubIFD------\n");
d3560 1
a3560 1
							sprintf(trace_buffer, "temp_position: %x\n", temp_position);
d3564 1
a3564 1
							sprintf(trace_buffer, "offset to count: %x\n", (Get32u(long_byte_ptr)));
d3575 1
a3575 1
							trace("------End SubIFD------\n");
d3579 1
a3579 1
						sprintf(trace_buffer, "get33u_long_byte_ptr: %x\n", Get32u(long_byte_ptr));
d3583 1
a3583 1
						sprintf(trace_buffer, "buffer: %s\n", buffer);
d3587 1
a3587 1
						sprintf(trace_buffer, "long_byte_ptr: %x\n", *long_byte_ptr);
d3602 25
d3632 1
a3632 1
						sprintf(trace_buffer, "lThumbnailOffset: %ld\n", lThumbnailOffset);
d3641 1
a3641 1
						sprintf(trace_buffer, "lThumbnailLength: %ld\n", lThumbnailLength);
d3647 1
a3647 1
						trace("------Start EXIF------\n");
d3652 1
a3652 1
						sprintf(trace_buffer, "temp_position: %x\n", temp_position);
d3663 1
a3663 1
						trace("------End EXIF------\n");
d3670 1
a3670 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d3684 1
a3684 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d3697 1
a3697 1
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
d3708 1
a3708 1
					trace("------Start Maker Notes------\n");
d3717 1
a3717 1
					sprintf(trace_buffer, "old_file_position: %x\n", temp_position);
d3723 1
d3726 1
a3726 1
					sprintf(trace_buffer, "maker_note_header_offset: %x\n", maker_note_header_offset);
d3741 1
a3741 1
					trace("------End Maker Notes------\n");
d3747 1
a3747 1
				sprintf(trace_buffer, "Unknown Format: %x\n", Get16u(&ifde_ptr->field_type));
d3760 1
a3760 1
	trace("-dump_jpg_image_file_directory\n");
d3805 2
d3899 1
a3899 1
	trace("+output_thumbnail\n");
d3967 2
d4119 2
d4270 10
a4279 1
	fseek(rfd, lThumbnailOffset + 2, 0);
d4371 1
a4371 1
	trace("-output_thumbnail\n");
d4381 1
a4381 1
	trace("+free_jpg_data_header_list\n");
d4391 1
a4391 1
	trace("-free_jpg_data_header_list\n");
d4408 1
a4408 1
	trace("+ProcessFileJPG\n");
d4413 1
a4413 1
	sprintf(trace_buffer, "File Extension: %s\n", temp_ptr);
d4451 1
a4451 1
	trace("-ProcessFileJPG\n");
d4579 2
a4639 3

			if(iTrace)
				printf("buffer: %s", buffer);
d4669 1
a4669 1
	trace("\n+store_tags\n");
a4674 3
	if(iTrace)
		printf("\nlocal_ptr: %s", temp_ptr);

a4680 3
				if(iTrace)
					printf("\nFound Tag: %x\n", TagTable[ctr1].Tag);

d4696 1
a4696 1
				trace("\n-store_tags\n");
d4702 1
a4702 1
	trace("\n-store_tags\n");
d4795 1
a4795 1
	trace("+get_description\n");
d4801 1
a4801 1
	trace("-get_description\n");
@


1.22
log
@Changed default location of the config file.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.21 2005/01/28 17:22:04 joman Exp joman $	*/
d66 7
d90 1
d101 2
a102 2
#define D70_VERSION "0.15"
#define D70_DATE "Tue Feb 15 03:52:19 UTC 2005"
d104 1
a104 1
static char rcsid[] = "$Id: d70reader.c,v 1.21 2005/01/28 17:22:04 joman Exp joman $";
d122 2
a236 2
char * get_data_from_long(unsigned long Long);
void long_to_asc( unsigned long Lf15a_long_value, char *Lf15b_str_ptr, int Lf15c_length, char Lf15d_blank);
a241 1
static int Get32sTest(void * Long);
d246 1
a246 1
void print_iso_tag(unsigned long value, struct data_header *local_ptr);
a247 1
unsigned int uGet16u(void * Short);
a250 1
void rev_memory( unsigned char *Lf07a_address, unsigned int Lf07b_length);
a557 2
				iSystemType = 1;

a568 2
				iSystemType = 0;

a580 2
				iSystemType = 1;

a1150 36
void rev_memory( unsigned char *Lf07a_address, unsigned int Lf07b_length)
{
	unsigned char Lf07c_hold_val;
	unsigned int Lf07d_offset;

	trace("+rev_memory\n");

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "Lf07a_address: %s\n", Lf07a_address);
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "Lf07b_length: %d\n", Lf07b_length);
	trace(trace_buffer);

	Lf07d_offset = 0;

	while (Lf07d_offset < Lf07b_length)
	{
		Lf07c_hold_val = Lf07a_address[Lf07d_offset];
		Lf07a_address[Lf07d_offset++] = Lf07a_address[--Lf07b_length];
		Lf07a_address[Lf07b_length] = Lf07c_hold_val;
	}

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "Lf07a_address: %s\n", Lf07a_address);
	trace(trace_buffer);

	trace("-rev_memory\n");

	return;
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
d1215 2
a1250 3
	int ctr1;
	char buffer[256];

d1253 2
a1254 17
	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "byte_ptr: %s\n", byte_ptr);
	trace(trace_buffer);

	memset(buffer, (int) NULL, 256);

	for(ctr1 = 0; ctr1 < ByteCount; ctr1++)
	{
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "%c ", *byte_ptr);
		trace(trace_buffer);
		strcat(buffer, trace_buffer);
		byte_ptr++;
	}

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "%s ", buffer); 
d1256 3
a1258 2
	local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
	strcpy(local_ptr->Value, trace_buffer);
d1274 2
d1331 2
a1378 36
void print_iso_tag(unsigned long value, struct data_header *local_ptr)
{
	char buffer[256];

	unsigned long val1 = value;
	unsigned long val2 = value;

	trace("+print_iso_tag\n");

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "value: %x\n", value);
	trace(trace_buffer);

	memset(buffer, (int) NULL, 256);

	if(MotorolaOrder)
		sprintf(buffer, "%ld", val1 );
	else
		sprintf(buffer, "%ld", rotate_right( val1 ) );

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "0x%8.8lx\n", rotate_right( val1) );
	trace(trace_buffer);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "%s ", buffer); 

	local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
	strcpy(local_ptr->Value, trace_buffer);

	trace("\n-print_iso_tag\n");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
a1483 15
// Convert a 16 bit unsigned value from file's native byte order
//--------------------------------------------------------------------------
unsigned int uGet16u(void * Short)
{
	if (MotorolaOrder)
	{
		return (((uchar *)Short)[0] << 8) | ((uchar *)Short)[1];
	}
	else
	{
		return (((uchar *)Short)[1] << 8) | ((uchar *)Short)[0];
	}
}

//--------------------------------------------------------------------------
d1744 8
d2056 1
a2056 1
					trace("------Start FileSource/SceneType------\n");
d2076 1
a2076 1
					trace("\n------End FileSource/SceneType------\n");
d2089 1
a2089 1
					trace("------Start CFA Pattern------\n");
d2116 1
a2116 1
					trace("\n------End CFA Pattern------\n");
d2154 3
a2247 67
void long_to_asc( unsigned long Lf15a_long_value, char *Lf15b_str_ptr, int Lf15c_length, char Lf15d_blank)
{
	int Lf15e_temp;

	// Pre-fill the string to all blanks or zeros depending on the blank
	// fill flag and check for the special case of a zero value.

	for (Lf15e_temp = 0; Lf15e_temp < Lf15c_length; Lf15e_temp++)
		Lf15b_str_ptr[Lf15e_temp] = (Lf15d_blank) ? ' ' : '0';

	if (Lf15a_long_value == 0)
		Lf15b_str_ptr[Lf15c_length - 1] = '0';

	// Loop through for the entire length or until zero value reached.

	while (Lf15a_long_value > 0 && Lf15c_length > 0)
	{
		Lf15b_str_ptr[--Lf15c_length] = (char) Lf15a_long_value % 10 + '0';
		Lf15a_long_value /= 10;
	}

	return;
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
char * get_data_from_long(unsigned long Long)
{
	int ctr1;
	char *ptr;
	char *ptr2;
	static char lbuffer[5];

	trace("\n+get_data_from_long\n");

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "Long: %x\n", Long);
	trace(trace_buffer);

	ptr = (char *) &Long;

	memset(lbuffer, (int) NULL, 5);

	for(ctr1 = 3; ctr1 >= 0; ctr1--)
	{
		lbuffer[ctr1] = ptr[ctr1];

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "lbuffer[%d]: %x\n", ctr1, lbuffer[ctr1]);
		trace(trace_buffer);
	}

	ptr2 = &lbuffer[0];

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "returned data: [%s], length: %d\n", ptr2, strlen(ptr2));
	trace(trace_buffer);

	trace("\n-get_data_from_long\n");

	return(ptr2);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
d2505 2
d2516 3
a2518 200
						if(!strncmp(local_ptr->Value, "0.000125", strlen("0.000125")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/8000");
						}
						else if(!strncmp(local_ptr->Value, "0.000156", strlen("0.000156")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/6400");
						}
						else if(!strncmp(local_ptr->Value, "0.000200", strlen("0.000200")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/5000");
						}
						else if(!strncmp(local_ptr->Value, "0.000250", strlen("0.000250")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/4000");
						}
						else if(!strncmp(local_ptr->Value, "0.000313", strlen("0.000313")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/3200");
						}
						else if(!strncmp(local_ptr->Value, "0.000400", strlen("0.000400")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/2500");
						}
						else if(!strncmp(local_ptr->Value, "0.000500", strlen("0.000500")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/2000");
						}
						else if(!strncmp(local_ptr->Value, "0.000625", strlen("0.000625")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1600");
						}
						else if(!strncmp(local_ptr->Value, "0.000800", strlen("0.000800")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1250");
						}
						else if(!strncmp(local_ptr->Value, "0.001000", strlen("0.001000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1000");
						}
						else if(!strncmp(local_ptr->Value, "0.001250", strlen("0.001250")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/800");
						}
						else if(!strncmp(local_ptr->Value, "0.001563", strlen("0.001563")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/640");
						}
						else if(!strncmp(local_ptr->Value, "0.002000", strlen("0.002000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/500");
						}
						else if(!strncmp(local_ptr->Value, "0.002500", strlen("0.002500")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/400");
						}
						else if(!strncmp(local_ptr->Value, "0.003125", strlen("0.003125")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/320");
						}
						else if(!strncmp(local_ptr->Value, "0.004000", strlen("0.004000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/250");
						}
						else if(!strncmp(local_ptr->Value, "0.005000", strlen("0.005000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/200");
						}
						else if(!strncmp(local_ptr->Value, "0.006250", strlen("0.006250")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/160");
						}
						else if(!strncmp(local_ptr->Value, "0.008000", strlen("0.008000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/125");
						}
						else if(!strncmp(local_ptr->Value, "0.010000", strlen("0.010000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/100");
						}
						else if(!strncmp(local_ptr->Value, "0.012500", strlen("0.012500")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/80");
						}
						else if(!strncmp(local_ptr->Value, "0.016667", strlen("0.016667")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/60");
						}
						else if(!strncmp(local_ptr->Value, "0.020000", strlen("0.020000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/50");
						}
						else if(!strncmp(local_ptr->Value, "0.025000", strlen("0.025000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/40");
						}
						else if(!strncmp(local_ptr->Value, "0.033333", strlen("0.033333")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/30");
						}
						else if(!strncmp(local_ptr->Value, "0.040000", strlen("0.040000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/25");
						}
						else if(!strncmp(local_ptr->Value, "0.050000", strlen("0.050000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/20");
						}
						else if(!strncmp(local_ptr->Value, "0.066667", strlen("0.066667")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/15");
						}
						else if(!strncmp(local_ptr->Value, "0.076923", strlen("0.076923")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/13");
						}
						else if(!strncmp(local_ptr->Value, "0.100000", strlen("0.100000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/10");
						}
						else if(!strncmp(local_ptr->Value, "0.125000", strlen("0.125000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/8");
						}
						else if(!strncmp(local_ptr->Value, "0.166667", strlen("0.166667")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/6");
						}
						else if(!strncmp(local_ptr->Value, "0.200000", strlen("0.200000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/5");
						}
						else if(!strncmp(local_ptr->Value, "0.250000", strlen("0.250000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/4");
						}
						else if(!strncmp(local_ptr->Value, "0.333333", strlen("0.333333")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/3");
						}
						else if(!strncmp(local_ptr->Value, "0.400000", strlen("0.400000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/2.5");
						}
						else if(!strncmp(local_ptr->Value, "0.500000", strlen("0.500000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/2");
						}
						else if(!strncmp(local_ptr->Value, "0.625000", strlen("0.625000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1.6");
						}
						else if(!strncmp(local_ptr->Value, "0.769231", strlen("0.769231")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1.3");
						}
						else if(!strncmp(local_ptr->Value, "1.000000", strlen("1.000000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1");
						}
						else if(!strncmp(local_ptr->Value, "1.300000", strlen("1.300000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1.3");
						}
						else if(!strncmp(local_ptr->Value, "1.600000", strlen("1.600000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1.6");
						}
						else if(!strncmp(local_ptr->Value, "2.000000", strlen("2.000000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "2");
						}
						else if(!strncmp(local_ptr->Value, "2.500000", strlen("2.500000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "2.5");
						}
						else if(!strncmp(local_ptr->Value, "3.000000", strlen("3.000000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "3");
						}
						else if(!strncmp(local_ptr->Value, "4.000000", strlen("4.000000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "4");
						}
						else if(!strncmp(local_ptr->Value, "5.000000", strlen("5.000000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "5");
						}
						else if(!strncmp(local_ptr->Value, "6.000000", strlen("6.000000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "6");
						}
						else if(!strncmp(local_ptr->Value, "8.000000", strlen("8.000000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "8");
						}
						else if(!strncmp(local_ptr->Value, "10.000000", strlen("10.000000")))
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "10");
						}
d2520 3
a2522 3
						{
							debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
						}
d2722 8
d2777 3
a2779 200
						if(!strncmp(local_ptr->Value, "0.000125", strlen("0.000125")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/8000");
						}
						else if(!strncmp(local_ptr->Value, "0.000156", strlen("0.000156")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/6400");
						}
						else if(!strncmp(local_ptr->Value, "0.000200", strlen("0.000200")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/5000");
						}
						else if(!strncmp(local_ptr->Value, "0.000250", strlen("0.000250")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/4000");
						}
						else if(!strncmp(local_ptr->Value, "0.000313", strlen("0.000313")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/3200");
						}
						else if(!strncmp(local_ptr->Value, "0.000400", strlen("0.000400")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/2500");
						}
						else if(!strncmp(local_ptr->Value, "0.000500", strlen("0.000500")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/2000");
						}
						else if(!strncmp(local_ptr->Value, "0.000625", strlen("0.000625")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1600");
						}
						else if(!strncmp(local_ptr->Value, "0.000800", strlen("0.000800")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1250");
						}
						else if(!strncmp(local_ptr->Value, "0.001000", strlen("0.001000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1000");
						}
						else if(!strncmp(local_ptr->Value, "0.001250", strlen("0.001250")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/800");
						}
						else if(!strncmp(local_ptr->Value, "0.001563", strlen("0.001563")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/640");
						}
						else if(!strncmp(local_ptr->Value, "0.002000", strlen("0.002000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/500");
						}
						else if(!strncmp(local_ptr->Value, "0.002500", strlen("0.002500")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/400");
						}
						else if(!strncmp(local_ptr->Value, "0.003125", strlen("0.003125")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/320");
						}
						else if(!strncmp(local_ptr->Value, "0.004000", strlen("0.004000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/250");
						}
						else if(!strncmp(local_ptr->Value, "0.005000", strlen("0.005000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/200");
						}
						else if(!strncmp(local_ptr->Value, "0.006250", strlen("0.006250")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/160");
						}
						else if(!strncmp(local_ptr->Value, "0.008000", strlen("0.008000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/125");
						}
						else if(!strncmp(local_ptr->Value, "0.010000", strlen("0.010000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/100");
						}
						else if(!strncmp(local_ptr->Value, "0.012500", strlen("0.012500")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/80");
						}
						else if(!strncmp(local_ptr->Value, "0.016667", strlen("0.016667")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/60");
						}
						else if(!strncmp(local_ptr->Value, "0.020000", strlen("0.020000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/50");
						}
						else if(!strncmp(local_ptr->Value, "0.025000", strlen("0.025000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/40");
						}
						else if(!strncmp(local_ptr->Value, "0.033333", strlen("0.033333")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/30");
						}
						else if(!strncmp(local_ptr->Value, "0.040000", strlen("0.040000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/25");
						}
						else if(!strncmp(local_ptr->Value, "0.050000", strlen("0.050000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/20");
						}
						else if(!strncmp(local_ptr->Value, "0.066667", strlen("0.066667")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/15");
						}
						else if(!strncmp(local_ptr->Value, "0.076923", strlen("0.076923")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/13");
						}
						else if(!strncmp(local_ptr->Value, "0.100000", strlen("0.100000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/10");
						}
						else if(!strncmp(local_ptr->Value, "0.125000", strlen("0.125000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/8");
						}
						else if(!strncmp(local_ptr->Value, "0.166667", strlen("0.166667")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/6");
						}
						else if(!strncmp(local_ptr->Value, "0.200000", strlen("0.200000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/5");
						}
						else if(!strncmp(local_ptr->Value, "0.250000", strlen("0.250000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/4");
						}
						else if(!strncmp(local_ptr->Value, "0.333333", strlen("0.333333")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/3");
						}
						else if(!strncmp(local_ptr->Value, "0.400000", strlen("0.400000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/2.5");
						}
						else if(!strncmp(local_ptr->Value, "0.500000", strlen("0.500000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/2");
						}
						else if(!strncmp(local_ptr->Value, "0.625000", strlen("0.625000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1.6");
						}
						else if(!strncmp(local_ptr->Value, "0.769231", strlen("0.769231")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1.3");
						}
						else if(!strncmp(local_ptr->Value, "1.000000", strlen("1.000000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1");
						}
						else if(!strncmp(local_ptr->Value, "1.300000", strlen("1.300000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1.3");
						}
						else if(!strncmp(local_ptr->Value, "1.600000", strlen("1.600000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "1.6");
						}
						else if(!strncmp(local_ptr->Value, "2.000000", strlen("2.000000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "2");
						}
						else if(!strncmp(local_ptr->Value, "2.500000", strlen("2.500000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "2.5");
						}
						else if(!strncmp(local_ptr->Value, "3.000000", strlen("3.000000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "3");
						}
						else if(!strncmp(local_ptr->Value, "4.000000", strlen("4.000000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "4");
						}
						else if(!strncmp(local_ptr->Value, "5.000000", strlen("5.000000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "5");
						}
						else if(!strncmp(local_ptr->Value, "6.000000", strlen("6.000000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "6");
						}
						else if(!strncmp(local_ptr->Value, "8.000000", strlen("8.000000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "8");
						}
						else if(!strncmp(local_ptr->Value, "10.000000", strlen("10.000000")))
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, "10");
						}
d2781 3
a2783 3
						{
							my_printf("\n%s: %s seconds", local_ptr->Desc, local_ptr->Value);
						}
d2982 8
@


1.21
log
@Added support for image rotation.  Also added
a configuration file.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.20 2005/01/26 22:48:18 joman Exp joman $	*/
d62 4
d84 2
d93 2
a94 2
#define D70_VERSION "0.14"
#define D70_DATE "Fri Jan 28 17:17:45 UTC 2005"
d96 1
a96 1
static char rcsid[] = "$Id: d70reader.c,v 1.20 2005/01/26 22:48:18 joman Exp joman $";
a113 2
char * file_sys_dir_ptr = NULL;

d475 4
d544 1
a544 1
		if(!memcmp(upper_case(env[ctr3]), "WINDIR=", 7))
d546 39
a584 3
			file_sys_dir_ptr = (char *) malloc(strlen(env[ctr3]) + 1);
			memset(file_sys_dir_ptr, (int) NULL, strlen(env[ctr3]) + 1);
			memcpy(file_sys_dir_ptr, &env[ctr3][7], strlen(env[ctr3]) - 7);
d591 2
a592 1
	if(!iSystemType)
d594 4
a597 3
		file_sys_dir_ptr = (char *) malloc(strlen("/etc") + 1);
		memset(file_sys_dir_ptr, (int) NULL, strlen("/etc") + 1);
		memcpy(file_sys_dir_ptr, "/etc", strlen("/etc"));
d605 2
a606 2
        while(filename = *++argv)
        {
d618 1
a618 1
        }
d620 1
a620 1
        return 0;
@


1.20
log
@Added rotation logic for option -j.
Now uses the IJG library.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.19 2005/01/22 21:03:18 joman Exp joman $	*/
d57 1
a57 1
/*	Version 0.14 - Wed Jan 26 17:42:58 EST 2005:			*/
d60 2
d88 1
a88 1
#define D70_DATE "Wed Jan 26 22:44:56 UTC 2005"
d90 1
a90 1
static char rcsid[] = "$Id: d70reader.c,v 1.19 2005/01/22 21:03:18 joman Exp joman $";
d106 3
d178 15
a289 1
  { 0x003,   "ColorMode                  "},
d303 1
a303 1
  { 0x013,   "ISO-2                      "},
d458 1
a458 1
int main(argc,argv)
d461 1
d465 1
d523 33
d626 3
a628 1
			printf("\nNo EXIF data found\n");
d1434 1
a1434 1
	printf("\nThis software makes use of \"The Independent JPEG Group's JPEG software\"");
d1436 1
a1436 1
	printf("\nPlease read their copywrite information, found in the jpeglib/README file.\n");
d2618 449
a3066 1
		switch(local_ptr->Tag)
d3068 3
a3070 2
			case 0x829a:		// shutter speed
				if(!strncmp(local_ptr->Value, "0.000125", strlen("0.000125")))
d3072 347
a3418 345
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/8000");
				}
				else if(!strncmp(local_ptr->Value, "0.000156", strlen("0.000156")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/6400");
				}
				else if(!strncmp(local_ptr->Value, "0.000200", strlen("0.000200")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/5000");
				}
				else if(!strncmp(local_ptr->Value, "0.000250", strlen("0.000250")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/4000");
				}
				else if(!strncmp(local_ptr->Value, "0.000313", strlen("0.000313")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/3200");
				}
				else if(!strncmp(local_ptr->Value, "0.000400", strlen("0.000400")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/2500");
				}
				else if(!strncmp(local_ptr->Value, "0.000500", strlen("0.000500")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/2000");
				}
				else if(!strncmp(local_ptr->Value, "0.000625", strlen("0.000625")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1600");
				}
				else if(!strncmp(local_ptr->Value, "0.000800", strlen("0.000800")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1250");
				}
				else if(!strncmp(local_ptr->Value, "0.001000", strlen("0.001000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1000");
				}
				else if(!strncmp(local_ptr->Value, "0.001250", strlen("0.001250")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/800");
				}
				else if(!strncmp(local_ptr->Value, "0.001563", strlen("0.001563")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/640");
				}
				else if(!strncmp(local_ptr->Value, "0.002000", strlen("0.002000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/500");
				}
				else if(!strncmp(local_ptr->Value, "0.002500", strlen("0.002500")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/400");
				}
				else if(!strncmp(local_ptr->Value, "0.003125", strlen("0.003125")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/320");
				}
				else if(!strncmp(local_ptr->Value, "0.004000", strlen("0.004000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/250");
				}
				else if(!strncmp(local_ptr->Value, "0.005000", strlen("0.005000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/200");
				}
				else if(!strncmp(local_ptr->Value, "0.006250", strlen("0.006250")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/160");
				}
				else if(!strncmp(local_ptr->Value, "0.008000", strlen("0.008000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/125");
				}
				else if(!strncmp(local_ptr->Value, "0.010000", strlen("0.010000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/100");
				}
				else if(!strncmp(local_ptr->Value, "0.012500", strlen("0.012500")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/80");
				}
				else if(!strncmp(local_ptr->Value, "0.016667", strlen("0.016667")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/60");
				}
				else if(!strncmp(local_ptr->Value, "0.020000", strlen("0.020000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/50");
				}
				else if(!strncmp(local_ptr->Value, "0.025000", strlen("0.025000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/40");
				}
				else if(!strncmp(local_ptr->Value, "0.033333", strlen("0.033333")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/30");
				}
				else if(!strncmp(local_ptr->Value, "0.040000", strlen("0.040000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/25");
				}
				else if(!strncmp(local_ptr->Value, "0.050000", strlen("0.050000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/20");
				}
				else if(!strncmp(local_ptr->Value, "0.066667", strlen("0.066667")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/15");
				}
				else if(!strncmp(local_ptr->Value, "0.076923", strlen("0.076923")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/13");
				}
				else if(!strncmp(local_ptr->Value, "0.100000", strlen("0.100000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/10");
				}
				else if(!strncmp(local_ptr->Value, "0.125000", strlen("0.125000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/8");
				}
				else if(!strncmp(local_ptr->Value, "0.166667", strlen("0.166667")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/6");
				}
				else if(!strncmp(local_ptr->Value, "0.200000", strlen("0.200000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/5");
				}
				else if(!strncmp(local_ptr->Value, "0.250000", strlen("0.250000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/4");
				}
				else if(!strncmp(local_ptr->Value, "0.333333", strlen("0.333333")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/3");
				}
				else if(!strncmp(local_ptr->Value, "0.400000", strlen("0.400000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/2.5");
				}
				else if(!strncmp(local_ptr->Value, "0.500000", strlen("0.500000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/2");
				}
				else if(!strncmp(local_ptr->Value, "0.625000", strlen("0.625000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1.6");
				}
				else if(!strncmp(local_ptr->Value, "0.769231", strlen("0.769231")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1/1.3");
				}
				else if(!strncmp(local_ptr->Value, "1.000000", strlen("1.000000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1");
				}
				else if(!strncmp(local_ptr->Value, "1.300000", strlen("1.300000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1.3");
				}
				else if(!strncmp(local_ptr->Value, "1.600000", strlen("1.600000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "1.6");
				}
				else if(!strncmp(local_ptr->Value, "2.000000", strlen("2.000000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "2");
				}
				else if(!strncmp(local_ptr->Value, "2.500000", strlen("2.500000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "2.5");
				}
				else if(!strncmp(local_ptr->Value, "3.000000", strlen("3.000000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "3");
				}
				else if(!strncmp(local_ptr->Value, "4.000000", strlen("4.000000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "4");
				}
				else if(!strncmp(local_ptr->Value, "5.000000", strlen("5.000000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "5");
				}
				else if(!strncmp(local_ptr->Value, "6.000000", strlen("6.000000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "6");
				}
				else if(!strncmp(local_ptr->Value, "8.000000", strlen("8.000000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "8");
				}
				else if(!strncmp(local_ptr->Value, "10.000000", strlen("10.000000")))
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, "10");
				}
				else
				{
					debug_printf("\n%#x: %s: %s seconds", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x9209:

				if(!strncmp(local_ptr->Value, "0", strlen("0")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "No Flash");
				}
				else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "1", strlen("1")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired");
				}
				else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "5", strlen("5")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Return not detected");
				}
				else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "7", strlen("7")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Return detected");
				}
				else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "9", strlen("9")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On");
				}
				else if(!strncmp(local_ptr->Value, "13", strlen("13")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "15", strlen("15")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Return detected");
				}
				else if(!strncmp(local_ptr->Value, "16", strlen("16")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Off");
				}
				else if(!strncmp(local_ptr->Value, "24", strlen("24")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Did not fire");
				}
				else if(!strncmp(local_ptr->Value, "25", strlen("25")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired");
				}
				else if(!strncmp(local_ptr->Value, "29", strlen("29")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "31", strlen("31")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Return detected");
				}
				else if(!strncmp(local_ptr->Value, "32", strlen("32")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "No flash function");
				}
				else if(!strncmp(local_ptr->Value, "65", strlen("65")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction");
				}
				else if(!strncmp(local_ptr->Value, "69", strlen("69")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "71", strlen("71")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction, Return detected");
				}
				else if(!strncmp(local_ptr->Value, "73", strlen("73")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction");
				}
				else if(!strncmp(local_ptr->Value, "77", strlen("77")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "79", strlen("79")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction, Return detected");
				}
				else if(!strncmp(local_ptr->Value, "89", strlen("89")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction");
				}
				else if(!strncmp(local_ptr->Value, "93", strlen("93")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "95", strlen("95")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return detected");
				}
				else
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x8822:
				if(!strncmp(local_ptr->Value, "2", strlen("2")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Program AE");
				}
				else if(!strncmp(local_ptr->Value, "0", strlen("0")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto");
				}
				else if(!strncmp(local_ptr->Value, "4", strlen("4")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Shutter speed priority AE");
				}
				else if(!strncmp(local_ptr->Value, "3", strlen("3")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Aperture-priority AE");
				}
				else if(!strncmp(local_ptr->Value, "1", strlen("1")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Manual");
				}
				else
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x9207:
				if(!strncmp(local_ptr->Value, "5", strlen("5")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Multi-segment");
				}
				else if(!strncmp(local_ptr->Value, "3", strlen("3")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Spot");
				}
				else if(!strncmp(local_ptr->Value, "2", strlen("2")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Center-weighted average");
				}
				else
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x0112:
				if(!strncmp(data_type, "SUB_IFD1", strlen("SUB_IFD1")))
					break;
d3420 94
a3513 539
				if(!strncmp(local_ptr->Value, "1", strlen("1")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Horizontal (normal)");
				}
				else if(!strncmp(local_ptr->Value, "2", strlen("2")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal");
				}
				else if(!strncmp(local_ptr->Value, "3", strlen("3")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 180");
				}
				else if(!strncmp(local_ptr->Value, "4", strlen("4")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored vertical");
				}
				else if(!strncmp(local_ptr->Value, "5", strlen("5")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal then rotated 90 CCW");
				}
				else if(!strncmp(local_ptr->Value, "6", strlen("6")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 90 CW");
				}
				else if(!strncmp(local_ptr->Value, "7", strlen("7")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal then rotated 90 CW");
				}
				else if(!strncmp(local_ptr->Value, "8", strlen("8")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 90 CCW");
				}
				else
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x0084:		/* lens	*/
				debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, convert_lens(local_ptr->Value));
				break;
			case 0x920a:
				debug_printf("\n%#x: %s: %smm", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, 0));
				break;
			case 0xa405:
				debug_printf("\n%#x: %s: %smm", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
				break;
			case 0x0083:
				if(!strncmp(local_ptr->Value, "2", strlen("2")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "D");
				}
				else if(!strncmp(local_ptr->Value, "6", strlen("6")))
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "G");
				}
				else
				{
					debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x8827:
			case 0x010f:
			case 0x0110:
			case 0x0131:
			case 0x9004:
			case 0x829d:
			case 0x0002:
			case 0x0013:
			case 0x0004:
			case 0x00a7:
			case 0x0007:
			case 0x0008:
			case 0x0009:
			case 0x0081:
			case 0x008b:
			case 0x008d:
			case 0x0090:
			case 0x0095:
//			case 0x00a0:
			case 0x00a9:
			case 0x00aa:
			case 0x00ab:
			case 0xa002:
			case 0xa003:
			case 0x9204:
			case 0x9286:
//			case 0x010E:
			case 0xffff:
				debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
				break;
			default:
				break;
		}
		}
		else
		{
		switch(local_ptr->Tag)
		{
			case 0x829a:		// shutter speed
				if(!strncmp(local_ptr->Value, "0.000125", strlen("0.000125")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/8000");
				}
				else if(!strncmp(local_ptr->Value, "0.000156", strlen("0.000156")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/6400");
				}
				else if(!strncmp(local_ptr->Value, "0.000200", strlen("0.000200")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/5000");
				}
				else if(!strncmp(local_ptr->Value, "0.000250", strlen("0.000250")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/4000");
				}
				else if(!strncmp(local_ptr->Value, "0.000313", strlen("0.000313")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/3200");
				}
				else if(!strncmp(local_ptr->Value, "0.000400", strlen("0.000400")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/2500");
				}
				else if(!strncmp(local_ptr->Value, "0.000500", strlen("0.000500")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/2000");
				}
				else if(!strncmp(local_ptr->Value, "0.000625", strlen("0.000625")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1600");
				}
				else if(!strncmp(local_ptr->Value, "0.000800", strlen("0.000800")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1250");
				}
				else if(!strncmp(local_ptr->Value, "0.001000", strlen("0.001000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1000");
				}
				else if(!strncmp(local_ptr->Value, "0.001250", strlen("0.001250")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/800");
				}
				else if(!strncmp(local_ptr->Value, "0.001563", strlen("0.001563")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/640");
				}
				else if(!strncmp(local_ptr->Value, "0.002000", strlen("0.002000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/500");
				}
				else if(!strncmp(local_ptr->Value, "0.002500", strlen("0.002500")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/400");
				}
				else if(!strncmp(local_ptr->Value, "0.003125", strlen("0.003125")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/320");
				}
				else if(!strncmp(local_ptr->Value, "0.004000", strlen("0.004000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/250");
				}
				else if(!strncmp(local_ptr->Value, "0.005000", strlen("0.005000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/200");
				}
				else if(!strncmp(local_ptr->Value, "0.006250", strlen("0.006250")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/160");
				}
				else if(!strncmp(local_ptr->Value, "0.008000", strlen("0.008000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/125");
				}
				else if(!strncmp(local_ptr->Value, "0.010000", strlen("0.010000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/100");
				}
				else if(!strncmp(local_ptr->Value, "0.012500", strlen("0.012500")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/80");
				}
				else if(!strncmp(local_ptr->Value, "0.016667", strlen("0.016667")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/60");
				}
				else if(!strncmp(local_ptr->Value, "0.020000", strlen("0.020000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/50");
				}
				else if(!strncmp(local_ptr->Value, "0.025000", strlen("0.025000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/40");
				}
				else if(!strncmp(local_ptr->Value, "0.033333", strlen("0.033333")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/30");
				}
				else if(!strncmp(local_ptr->Value, "0.040000", strlen("0.040000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/25");
				}
				else if(!strncmp(local_ptr->Value, "0.050000", strlen("0.050000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/20");
				}
				else if(!strncmp(local_ptr->Value, "0.066667", strlen("0.066667")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/15");
				}
				else if(!strncmp(local_ptr->Value, "0.076923", strlen("0.076923")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/13");
				}
				else if(!strncmp(local_ptr->Value, "0.100000", strlen("0.100000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/10");
				}
				else if(!strncmp(local_ptr->Value, "0.125000", strlen("0.125000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/8");
				}
				else if(!strncmp(local_ptr->Value, "0.166667", strlen("0.166667")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/6");
				}
				else if(!strncmp(local_ptr->Value, "0.200000", strlen("0.200000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/5");
				}
				else if(!strncmp(local_ptr->Value, "0.250000", strlen("0.250000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/4");
				}
				else if(!strncmp(local_ptr->Value, "0.333333", strlen("0.333333")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/3");
				}
				else if(!strncmp(local_ptr->Value, "0.400000", strlen("0.400000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/2.5");
				}
				else if(!strncmp(local_ptr->Value, "0.500000", strlen("0.500000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/2");
				}
				else if(!strncmp(local_ptr->Value, "0.625000", strlen("0.625000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1.6");
				}
				else if(!strncmp(local_ptr->Value, "0.769231", strlen("0.769231")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1/1.3");
				}
				else if(!strncmp(local_ptr->Value, "1.000000", strlen("1.000000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1");
				}
				else if(!strncmp(local_ptr->Value, "1.300000", strlen("1.300000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1.3");
				}
				else if(!strncmp(local_ptr->Value, "1.600000", strlen("1.600000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "1.6");
				}
				else if(!strncmp(local_ptr->Value, "2.000000", strlen("2.000000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "2");
				}
				else if(!strncmp(local_ptr->Value, "2.500000", strlen("2.500000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "2.5");
				}
				else if(!strncmp(local_ptr->Value, "3.000000", strlen("3.000000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "3");
				}
				else if(!strncmp(local_ptr->Value, "4.000000", strlen("4.000000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "4");
				}
				else if(!strncmp(local_ptr->Value, "5.000000", strlen("5.000000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "5");
				}
				else if(!strncmp(local_ptr->Value, "6.000000", strlen("6.000000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "6");
				}
				else if(!strncmp(local_ptr->Value, "8.000000", strlen("8.000000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "8");
				}
				else if(!strncmp(local_ptr->Value, "10.000000", strlen("10.000000")))
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, "10");
				}
				else
				{
					my_printf("\n%s: %s seconds", local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x9209:
				if(!strncmp(local_ptr->Value, "0", strlen("0")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "No Flash");
				}
				else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "1", strlen("1")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Fired");
				}
				else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "5", strlen("5")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Fired, Return not detected");
				}
				else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "7", strlen("7")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Fired, Return detected");
				}
				else if((strlen(local_ptr->Value) == 1) && !strncmp(local_ptr->Value, "9", strlen("9")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "On");
				}
				else if(!strncmp(local_ptr->Value, "13", strlen("13")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "On, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "15", strlen("15")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "On, Return detected");
				}
				else if(!strncmp(local_ptr->Value, "16", strlen("16")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Off");
				}
				else if(!strncmp(local_ptr->Value, "24", strlen("24")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Auto, Did not fire");
				}
				else if(!strncmp(local_ptr->Value, "25", strlen("25")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired");
				}
				else if(!strncmp(local_ptr->Value, "29", strlen("29")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "31", strlen("31")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Return detected");
				}
				else if(!strncmp(local_ptr->Value, "32", strlen("32")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "No flash function");
				}
				else if(!strncmp(local_ptr->Value, "65", strlen("65")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction");
				}
				else if(!strncmp(local_ptr->Value, "69", strlen("69")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "71", strlen("71")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction, Return detected");
				}
				else if(!strncmp(local_ptr->Value, "73", strlen("73")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction");
				}
				else if(!strncmp(local_ptr->Value, "77", strlen("77")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "79", strlen("79")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction, Return detected");
				}
				else if(!strncmp(local_ptr->Value, "89", strlen("89")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction");
				}
				else if(!strncmp(local_ptr->Value, "93", strlen("93")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return not detected");
				}
				else if(!strncmp(local_ptr->Value, "95", strlen("95")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return detected");
				}
				else
				{
					my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x8822:
				if(!strncmp(local_ptr->Value, "2", strlen("2")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Program AE");
				}
				else if(!strncmp(local_ptr->Value, "0", strlen("0")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Auto");
				}
				else if(!strncmp(local_ptr->Value, "4", strlen("4")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Shutter speed priority AE");
				}
				else if(!strncmp(local_ptr->Value, "3", strlen("3")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Aperture-priority AE");
				}
				else if(!strncmp(local_ptr->Value, "1", strlen("1")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Manual");
				}
				else
				{
					my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x9207:
				if(!strncmp(local_ptr->Value, "5", strlen("5")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Multi-segment");
				}
				else if(!strncmp(local_ptr->Value, "3", strlen("3")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Spot");
				}
				else if(!strncmp(local_ptr->Value, "2", strlen("2")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Center-weighted average");
				}
				else
				{
					my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x0112:
				if(!strncmp(data_type, "SUB_IFD1", strlen("SUB_IFD1")))
					break;

				if(!strncmp(local_ptr->Value, "1", strlen("1")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Horizontal (normal)");
				}
				else if(!strncmp(local_ptr->Value, "2", strlen("2")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal");
				}
				else if(!strncmp(local_ptr->Value, "3", strlen("3")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Rotated 180");
				}
				else if(!strncmp(local_ptr->Value, "4", strlen("4")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Mirrored vertical");
				}
				else if(!strncmp(local_ptr->Value, "5", strlen("5")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal then rotated 90 CCW");
				}
				else if(!strncmp(local_ptr->Value, "6", strlen("6")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Rotated 90 CW");
				}
				else if(!strncmp(local_ptr->Value, "7", strlen("7")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal then rotated 90 CW");
				}
				else if(!strncmp(local_ptr->Value, "8", strlen("8")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "Rotated 90 CCW");
				}
				else
				{
					my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x0084:		/* lens	*/
				my_printf("\n%s: %s", local_ptr->Desc, convert_lens(local_ptr->Value));
				break;
			case 0x920a:
				my_printf("\n%s: %smm", local_ptr->Desc, truncate(local_ptr->Value, 0));
				break;
			case 0xa405:
				my_printf("\n%s: %smm", local_ptr->Desc, local_ptr->Value);
				break;
			case 0x0083:
				if(!strncmp(local_ptr->Value, "2", strlen("2")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "D");
				}
				else if(!strncmp(local_ptr->Value, "6", strlen("6")))
				{
					my_printf("\n%s: %s", local_ptr->Desc, "G");
				}
				else
				{
					my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
				}
				break;
			case 0x8827:
			case 0x010f:
			case 0x0110:
			case 0x0131:
			case 0x9004:
			case 0x829d:
			case 0x0002:
			case 0x0013:
			case 0x0004:
			case 0x00a7:
			case 0x0007:
			case 0x0008:
			case 0x0009:
			case 0x0081:
			case 0x008b:
			case 0x008d:
			case 0x0090:
			case 0x0095:
//			case 0x00a0:
			case 0x00a9:
			case 0x00aa:
			case 0x00ab:
			case 0xa002:
			case 0xa003:
			case 0x9204:
			case 0x9286:
//			case 0x010E:
			case 0xffff:
				my_printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
				break;
			default:
				break;
		}
d4502 1
d4504 4
d4652 1
d4654 4
d4936 299
@


1.19
log
@See the source comments for version 0.13.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.18 2005/01/21 16:21:59 joman Exp joman $	*/
d57 3
d85 2
a86 2
#define D70_VERSION "0.13"
#define D70_DATE "Sat Jan 22 20:56:23 UTC 2005"
d88 1
a88 1
static char rcsid[] = "$Id: d70reader.c,v 1.18 2005/01/21 16:21:59 joman Exp joman $";
d173 1
d791 1
a791 1
		printf("<tr><td nowrap>%s</td><td>%s</td></tr>\n", local_header_start_ptr->Desc, local_header_start_ptr->Value);
d796 1
a796 1
	printf("<tr><td nowrap>%s</td><td>%s</td></tr>\n", local_header_start_ptr->Desc, local_header_start_ptr->Value);
d1378 4
d4219 3
d4271 1
d4438 3
d4583 3
d4606 14
d4624 4
a4627 1
	
d4633 1
a4633 1
	if((ofd = fopen(file_ptr, "wb")) == NULL)
d4635 24
a4658 2
		printf("\nFile not created: %s\n\n", file_ptr);
		exit(1);
d4690 25
@


1.18
log
@Removed some dead variables.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.17 2005/01/21 16:13:33 joman Exp joman $	*/
d51 6
d63 4
d82 2
a83 2
#define D70_VERSION "0.12"
#define D70_DATE "Fri Jan 21 14:34:12 UTC 2005"
d85 1
a85 1
static char rcsid[] = "$Id: d70reader.c,v 1.17 2005/01/21 16:13:33 joman Exp joman $";
d170 1
d564 9
d964 1
d967 1
d969 1
d981 3
d997 8
a1004 1
		if(strncmp(temp_ptr->test_data, "http:", strlen("http:")))
d1007 1
a1007 1
		if(ctr1 > 10)
d1012 1
a1012 1
	if(ctr1 < 11)
d1039 2
d2307 1
a2307 1
	unsigned long offset_ifd;
d4723 59
@


1.17
log
@Cleanup for release.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.16 2005/01/21 04:39:50 joman Exp joman $	*/
d75 1
a75 1
static char rcsid[] = "$Id: d70reader.c,v 1.16 2005/01/21 04:39:50 joman Exp joman $";
a4222 3
	unsigned int ubyte2;
	unsigned int ubyte3;
	unsigned int ubyte4;
a4223 1
	unsigned int ubyte6;
@


1.16
log
@First working version of embedding EXIF into extracted JPG.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.15 2005/01/19 21:24:43 joman Exp joman $	*/
d46 5
d72 2
a73 2
#define D70_VERSION "0.11"
#define D70_DATE "Thu Jan 13 17:04:52 UTC 2005"
d75 1
a75 1
static char rcsid[] = "$Id: d70reader.c,v 1.15 2005/01/19 21:24:43 joman Exp joman $";
d90 1
a90 1
int iTagCount = 0;
d109 12
a120 12
struct jpg_data_header
{
    unsigned short tag;                     
    unsigned short field_type;              
    unsigned long count;                    
    unsigned long value_offset;             
	unsigned char *data_at_offset;
	int record_type;
	int byte_count;
	struct jpg_data_header *next;
};

d175 1
a175 1
void ProcessFileJPG(int argc, char *filename);
d177 1
d183 1
a183 1
void my_exit(char *text_ptr);
d204 1
a204 1
void dump_jpg_image_file_directory(FILE *rfd, unsigned long offset_ifd, unsigned long offset_base, char *type_ptr);
d243 4
a246 4
struct jpg_data_header *jpg_header_ptr;
struct jpg_data_header *start_header_ptr;
struct jpg_data_header *current_header_ptr;

d432 2
a433 2
    struct stat buf;
    char *filename;
d492 11
a502 11
            if(stat(filename, &buf) == (-1))
			{
                perror(filename);
			}
            else
			{
				if(iThumbnail)
					ProcessFileJPG(argc, filename);
				else
					ProcessFile(argc, filename);
			}
d513 1
a513 1
        FILE *rfd;                      /*used as the file pointer      */
d547 1
a547 1
	if((!iHtml) && (!iXml) && (!iCsv) && (!iThumbnail))
d589 1
a589 7
	if(iThumbnail)
	{
		if(iFile_Type)
			output_thumbnail(filename, rfd);
	}

	fclose(rfd);                    /*close file                    */
d660 1
a660 1
	if((!iHtml) && (!iXml) && (!iCsv) && (!iThumbnail))
a666 42

/*
//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_thumbnail(char *filename, FILE *rfd)
{
	FILE *ofd;
	unsigned long size;
	unsigned char *byte_ptr;
	unsigned char *file_ptr;

	file_ptr = (char *) malloc(strlen(filename) + strlen(".JPG") + 1);
	memset(file_ptr, (int) NULL, (strlen(filename) + strlen(".JPG") + 1));
	strcat(file_ptr, filename);
	strcat(file_ptr, ".JPG");
	
	byte_ptr = (char *) malloc(lThumbnailLength);

	fseek(rfd, lThumbnailOffset, 0);
	fread(byte_ptr, lThumbnailLength, 1, rfd);

	if((ofd = fopen(file_ptr, "wb")) == NULL)
	{
		printf("\nFile not created: %s\n\n", file_ptr);
		exit(1);
	}

	if((size = fwrite(byte_ptr, lThumbnailLength, 1, ofd)) == 0)
	{
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
	}

	printf("Created file: %s\n", file_ptr);

	fclose(ofd);

	free(byte_ptr);
	free(file_ptr);
}
*/
d684 1
a684 1
		printf("<%s>%s</%s>\n", strip(local_header_start_ptr->Desc), local_header_start_ptr->Value, strip(local_header_start_ptr->Desc));
d689 1
a689 1
	printf("<%s>%s</%s>\n", strip(local_header_start_ptr->Desc), local_header_start_ptr->Value, strip(local_header_start_ptr->Desc));
d881 28
a1291 11
/*
	for(ctr1 = 0; ctr1 < 24; ctr1++)
	{
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "0x%8.8lx rotated left %d times is 0x%8.8lx\n", val1, (ctr1 + 1), _lrotl( val1, (ctr1 + 1) ) );
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "0x%8.8lx rotated right %d times is 0x%8.8lx\n", val1, (ctr1 + 1), _lrotr( val1, (ctr1 + 1) ) );
		trace(trace_buffer);
	}
a1292 2
	return;
*/
a1303 1
//		sprintf(buffer, "%ld", _lrotr( val1, 16 ) );
d1472 1
a1472 1
    return (unsigned)Get32s(Long) & 0xffffffff;
d1528 2
a1529 2
	unsigned long components;      		/*count               */
	unsigned long value_offset;     	/*value offset        */
a2020 1
//					print_16bit_hex(pad_field(byte_ptr, 2 * Get32u(&ifde_ptr->count), '0', 1), Get32u(&ifde_ptr->count), Get32u(&ifde_ptr->count), local_ptr);
d2193 1
a2193 1
  int Lf15e_temp;
d2195 2
a2196 6
/************************************************************************/
/*                                                                      */
/* Pre-fill the string to all blanks or zeros depending on the blank    */
/* fill flag and check for the special case of a zero value.            */
/*                                                                      */
/************************************************************************/
d2198 2
a2199 2
  for (Lf15e_temp = 0; Lf15e_temp < Lf15c_length; Lf15e_temp++)
    Lf15b_str_ptr[Lf15e_temp] = (Lf15d_blank) ? ' ' : '0';
d2201 2
a2202 2
  if (Lf15a_long_value == 0)
    Lf15b_str_ptr[Lf15c_length - 1] = '0';
d2204 1
a2204 5
/************************************************************************/
/*                                                                      */
/* Loop through for the entire length or until zero value reached.      */
/*                                                                      */
/************************************************************************/
d2206 5
a2210 5
  while (Lf15a_long_value > 0 && Lf15c_length > 0)
  {
    Lf15b_str_ptr[--Lf15c_length] = (char) Lf15a_long_value % 10 + '0';
    Lf15a_long_value /= 10;
  }
d2212 1
a2212 1
  return;
d2500 10
a2509 10
//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void my_jpg_exit(char *text_ptr)
{
	printf("\n\n%s\n", text_ptr);
	printf("\n%s\n\n", "File is not a NEF/RAW file");
	exit(1);
}

d3512 1
a3512 1
	if((!iHtml) && (!iXml) && (!iCsv) && (!iThumbnail))
d3549 1
a3549 1
	if((!iHtml) && (!iXml) && (!iCsv) && (!iThumbnail))
d3731 183
d3915 775
a4689 1
	trace("-extract_and_format_data\n");
a4691 983
//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void dump_jpg_image_file_directory(FILE *rfd, unsigned long offset_ifd, unsigned long offset_base, char *type_ptr)
{
	char *buff_ptr = NULL;
	char buffer[256];
	char type_buffer[256];
	struct image_file_directory_entry *ifde_ptr;
	unsigned short count;
	unsigned short num_ifd;
	unsigned long ctr1;
	unsigned long ctr3;
	long old_position;
	long temp_position;
	int ByteCount;
	unsigned long components;      		/*count               */
	unsigned long value_offset;     	/*value offset        */
	unsigned char *byte_ptr;
	unsigned long *long_byte_ptr;

	unsigned long maker_note_header_offset;

	trace("+dump_jpg_image_file_directory\n");

	if(iTrace)
		printf("type_ptr: %s\n", type_ptr);

	ifde_ptr = (struct image_file_directory_entry *) malloc(sizeof(struct image_file_directory_entry));
	memset(ifde_ptr, (int) NULL, sizeof(struct image_file_directory_entry));

	if(fseek(rfd, offset_ifd, 0) != -1)
	{
		fread(&count, sizeof(unsigned short), 1, rfd);
		num_ifd = Get16u(&count);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "Number of Image File Directories: %d\n", num_ifd);
		trace(trace_buffer);
	}
	else
	{
		my_error(rfd);
	}

	for(ctr1 = 0; ctr1 < num_ifd; ctr1++)
	{
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "\nctr1: %d\n", ctr1);
		trace(trace_buffer);

		memset(ifde_ptr, (int) NULL, sizeof(struct image_file_directory_entry));
		fread(ifde_ptr, sizeof(struct image_file_directory_entry), 1, rfd);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "tag: %x\n", Get16u(&ifde_ptr->tag));
		trace(trace_buffer);

//		if(Get16u(&ifde_ptr->tag) == 0x9217)
//			getchar();

		jpg_header_ptr->tag = Get16u(&ifde_ptr->tag);
		jpg_header_ptr->field_type = Get16u(&ifde_ptr->field_type);
		jpg_header_ptr->count = Get32u(&ifde_ptr->count);
		jpg_header_ptr->value_offset = Get32u(&ifde_ptr->value_offset);

		if(!strncmp(type_ptr, "IFD0", 4))
			jpg_header_ptr->record_type = 1;
		else if(!strncmp(type_ptr, "SUB_IFD0", 8))
			jpg_header_ptr->record_type = 3;
		else if(!strncmp(type_ptr, "SUB_IFD1", 8))
			jpg_header_ptr->record_type = 4;
		else if(!strncmp(type_ptr, "EXIF", 4))
			jpg_header_ptr->record_type = 5;
		else if(!strncmp(type_ptr, "MAKER_NOTES", 11))
			jpg_header_ptr->record_type = 6;
		else
			jpg_header_ptr->record_type = 99;

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "Field Type: %x\n", Get16u(&ifde_ptr->field_type));
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "Number of Values: %x\n", Get32u(&ifde_ptr->count));
		trace(trace_buffer);

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "Value Offset: %x\n", Get32u(&ifde_ptr->value_offset));
		trace(trace_buffer);

		components = Get32u(&ifde_ptr->count);
		value_offset = Get32u(&ifde_ptr->value_offset) + offset_base;

		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "components: %d\n", components);
		trace(trace_buffer);

		old_position = ftell(rfd);

		switch(Get16u(&ifde_ptr->field_type))
		{
			case 1:
				ByteCount = components * 1;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;


				if (ByteCount > 4)
				{
					byte_ptr = (unsigned char *) malloc(ByteCount);
					fseek(rfd, Get32u(&ifde_ptr->value_offset), 0);
					fread(byte_ptr, ByteCount, 1, rfd);
					jpg_header_ptr->data_at_offset = byte_ptr;
				}

				break;
			case 2:
				ByteCount = components * 1;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				if (ByteCount > 4)
				{
					byte_ptr = (unsigned char *) malloc(ByteCount);
					fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
					fread(byte_ptr, ByteCount, 1, rfd);
					jpg_header_ptr->data_at_offset = byte_ptr;
				}

				break;
			case 3:
			case 8:
				ByteCount = components * 2;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				if (ByteCount > 4)
				{
					byte_ptr = (unsigned char *) malloc(ByteCount);
					fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
					fread(byte_ptr, ByteCount, 1, rfd);
					jpg_header_ptr->data_at_offset = byte_ptr;
				}

				break;
			case 4:
				ByteCount = components * 4;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				if (ByteCount > 4)
				{
					if(Get16u(&ifde_ptr->tag) == TAG_SUBIFD_S)
					{
						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "Value Offset: %x\n", Get32u(&ifde_ptr->value_offset));
						trace(trace_buffer);

						my_fseek(rfd, Get32u(&ifde_ptr->value_offset), 0);
						temp_position = ftell(rfd);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "temp_position: %x\n", temp_position);
						trace(trace_buffer);

						for(ctr3 = 0; ctr3 < components; ctr3++)
						{
							long_byte_ptr = (unsigned long *) malloc(sizeof(unsigned long));
							*long_byte_ptr = 0;
							memset(buffer, (int) NULL, 256);
							fread(long_byte_ptr, sizeof(unsigned long), 1, rfd);
							sprintf(buffer, "%-04.4x", Get32u(long_byte_ptr));

							trace("------Start SubIFD------\n");

							//save file ptr
							temp_position = ftell(rfd);
		
							memset(trace_buffer, (int) NULL, 256);
							sprintf(trace_buffer, "temp_position: %x\n", temp_position);
							trace(trace_buffer);

							memset(trace_buffer, (int) NULL, 256);
							sprintf(trace_buffer, "offset to count: %x\n", (Get32u(long_byte_ptr)));
							trace(trace_buffer);

							memset(type_buffer, (int) NULL, 256);
							sprintf(type_buffer, "SUB_IFD%d", ctr3);

							dump_jpg_image_file_directory(rfd, (Get32u(long_byte_ptr)), 0, type_buffer);
		
							//restore file ptr
							fseek(rfd, temp_position, 0);

							trace("------End SubIFD------\n");
						}

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "get33u_long_byte_ptr: %x\n", Get32u(long_byte_ptr));
						trace(trace_buffer);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "buffer: %s\n", buffer);
						trace(trace_buffer);
	
						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "long_byte_ptr: %x\n", *long_byte_ptr);
						trace(trace_buffer);

						free(long_byte_ptr);
					}
					else
					{
						byte_ptr = (unsigned char *) malloc(ByteCount);
						fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
						fread(byte_ptr, ByteCount, 1, rfd);
						jpg_header_ptr->data_at_offset = byte_ptr;
					}
				}
				else
				{
					if(Get16u(&ifde_ptr->tag) == TAG_THUMBNAIL_OFFSET)
					{
						lThumbnailOffset = Get32u(&ifde_ptr->value_offset);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "lThumbnailOffset: %ld\n", lThumbnailOffset);
						trace(trace_buffer);
					}

					if(Get16u(&ifde_ptr->tag) == TAG_THUMBNAIL_LENGTH)
					{
						lThumbnailLength = Get32u(&ifde_ptr->value_offset);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "lThumbnailLength: %ld\n", lThumbnailLength);
						trace(trace_buffer);
					}

					if(Get16u(&ifde_ptr->tag) == TAG_EXIF_OFFSET)
					{
						trace("------Start EXIF------\n");
						//save file ptr
						temp_position = ftell(rfd);

						memset(trace_buffer, (int) NULL, 256);
						sprintf(trace_buffer, "temp_position: %x\n", temp_position);
						trace(trace_buffer);

						memset(type_buffer, (int) NULL, 256);
						sprintf(type_buffer, "EXIF");

						//call dump_.... with offset
						dump_jpg_image_file_directory(rfd, Get32u(&ifde_ptr->value_offset) + jpg_type_offset(), jpg_type_offset(), type_buffer);

						//restore file ptr
						fseek(rfd, temp_position, 0);
						trace("------End EXIF------\n");
					}
				}
				break;
			case 5:
				ByteCount = components * 8;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				byte_ptr = (unsigned char *) malloc(ByteCount);
				memset(byte_ptr, (int) 0xFF, ByteCount);
				fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
				fread(byte_ptr, ByteCount, 1, rfd);
				jpg_header_ptr->data_at_offset = byte_ptr;

				break;
			case 10:
				ByteCount = components * 8;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				byte_ptr = (unsigned char *) malloc(ByteCount);
				fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
				fread(byte_ptr, ByteCount, 1, rfd);
				jpg_header_ptr->data_at_offset = byte_ptr;

				break;
			case 7:
				ByteCount = components * 1;
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "ByteCount: %d\n", ByteCount);
				trace(trace_buffer);
				jpg_header_ptr->byte_count = ByteCount;

				byte_ptr = (unsigned char *) malloc(ByteCount);
				fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
				fread(byte_ptr, ByteCount, 1, rfd);
				jpg_header_ptr->data_at_offset = byte_ptr;

				if(Get16u(&ifde_ptr->tag) == TAG_MAKER_NOTE)
				{
					trace("------Start Maker Notes------\n");

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%x", Get32u(&ifde_ptr->value_offset));

					//save file ptr
					temp_position = ftell(rfd);

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "old_file_position: %x\n", temp_position);
					trace(trace_buffer);

					old_byte_order = MotorolaOrder;

					maker_note_header_offset = Get32u(&ifde_ptr->value_offset) + MAKER_NOTE_PRE_HEADER_LENGTH + jpg_type_offset();

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "maker_note_header_offset: %x\n", maker_note_header_offset);
					trace(trace_buffer);

					fseek(rfd, maker_note_header_offset, 0);

					memset(type_buffer, (int) NULL, 256);
					sprintf(type_buffer, "MAKER_NOTES");

					//call dump_.... with offset
					dump_jpg_image_file_directory(rfd, (maker_note_header_offset + inspect_image_file_header(rfd, 1)), maker_note_header_offset, type_buffer);

					MotorolaOrder = old_byte_order;

					//restore file ptr
					fseek(rfd, temp_position, 0);
					trace("------End Maker Notes------\n");
				}

				break;
			default:
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "Unknown Format: %x\n", Get16u(&ifde_ptr->field_type));
				trace(trace_buffer);
				break;
		}

		jpg_header_ptr->next = (struct jpg_data_header *) malloc(sizeof(struct jpg_data_header));
		jpg_header_ptr = jpg_header_ptr->next;
		memset(jpg_header_ptr, (int) NULL, sizeof(struct jpg_data_header));
		iTagCount++;

		fseek(rfd, old_position, 0);
	}

	trace("-dump_jpg_image_file_directory\n");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
struct jpg_data_header * get_new_jpg_data_header_ptr()
{
	struct jpg_data_header *local_header_ptr;
	local_header_ptr = (struct jpg_data_header *) malloc(sizeof(struct jpg_data_header));
	memset(local_header_ptr, (int) NULL, sizeof(struct jpg_data_header));
	return(local_header_ptr);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
unsigned short count_tags(struct jpg_data_header *local_ptr)
{
	unsigned short tag_count = 0;

	while(local_ptr->next != NULL)
	{
		switch(local_ptr->tag)
		{
			case 0x0112:
				if(local_ptr->record_type == 1)
					break;
			case 0x829a:
			case 0x9209:
			case 0x8822:
			case 0x9207:
			case 0x0084:
			case 0x920a:
			case 0xa405:
			case 0x0083:
			case 0x8827:
			case 0x010f:
			case 0x0110:
			case 0x0131:
			case 0x9004:
			case 0x829d:
			case 0x0002:
			case 0x0013:
			case 0x0004:
			case 0x00a7:
			case 0x0007:
			case 0x0008:
			case 0x0009:
			case 0x0081:
			case 0x008b:
			case 0x008d:
			case 0x0090:
			case 0x0095:
			case 0x00a9:
			case 0x00aa:
			case 0x00ab:
			case 0xa002:
			case 0xa003:
			case 0x9204:
			case 0x9286:
				tag_count++;
				break;
			default:
				break;
		}

		local_ptr = local_ptr->next;
	}

	return(tag_count);
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void output_thumbnail(char *filename, FILE *rfd)
{
	FILE *ofd;
	char buffer[256];
	unsigned long size;
	unsigned char *byte_ptr;
	unsigned char *file_ptr;

	struct image_file_directory_entry ifde;

	struct exif_header
	{
		unsigned char ff;
		unsigned char soi;
		unsigned char pad;
		unsigned char marker;
		unsigned short length;
		unsigned char exif[6];
		unsigned char byte_order[2];
		unsigned short flag;
		unsigned int offset;
		unsigned short dir_count;
	};

	struct type5
	{
		unsigned long numerator;
		unsigned long denominator;
	};

	struct type5 *type5_ptr;

	struct lens
	{
		struct type5 field_1;
		struct type5 field_2;
		struct type5 field_3;
		struct type5 field_4;
	};

	struct lens *lens_ptr;

	struct exif_header *exif_header_ptr;
	struct jpg_data_header *temp_start_ptr = NULL;
	unsigned char *dir_buffer_ptr = NULL;
	unsigned char *temp_dir_buffer_ptr = NULL;
	unsigned char *data_buffer_ptr = NULL;
	unsigned char *temp_data_buffer_ptr = NULL;

	unsigned short dir_count = 0;
	int iStructSize = 0;
	unsigned int data_offset = 0;
	unsigned short short_length = 0;
	unsigned int ubyte1;
	unsigned int ubyte2;
	unsigned int ubyte3;
	unsigned int ubyte4;
	unsigned int ubyte5;
	unsigned int ubyte6;
	unsigned long ulong;

	trace("+output_thumbnail\n");

	exif_header_ptr = (struct exif_header *) malloc(sizeof(struct exif_header));
	memset(exif_header_ptr, (int) 0xFF, sizeof(struct exif_header));
	iStructSize = sizeof(struct exif_header);

	exif_header_ptr->ff = 0xFF;
	exif_header_ptr->soi = 0xD8;
	exif_header_ptr->pad = 0xFF;
	exif_header_ptr->marker = 0xE1;
	exif_header_ptr->length = 0x00;		//set this later
	memcpy(exif_header_ptr->exif,"Exif\0\0", 6);
	memcpy(exif_header_ptr->byte_order,"II", 2);
	exif_header_ptr->flag = 0x002A;
	exif_header_ptr->offset = 0x0008;

	temp_start_ptr = start_header_ptr;

	dir_count += count_tags(temp_start_ptr);

	if(iTrace)
	{
		printf("dir_count: %d\n", dir_count);
		printf("iTagCount: %d\n", iTagCount);
	}

	exif_header_ptr->dir_count = dir_count;

	dir_buffer_ptr = (unsigned char *) malloc((12 * dir_count) + 4);
	temp_dir_buffer_ptr = dir_buffer_ptr;
	data_buffer_ptr = (unsigned char *) malloc(1024);

	data_offset = sizeof(struct exif_header) + ((12 * dir_count) + 4) - 14;

	memset(dir_buffer_ptr, (int) NULL, ((12 * dir_count) + 4));
	memset(data_buffer_ptr, (int) NULL, 1024);

	short_length = ((12 * dir_count) + 4) + sizeof(struct exif_header) + 1024 - 6;
	exif_header_ptr->length = Get16u(&short_length);

	temp_data_buffer_ptr = data_buffer_ptr;

	temp_start_ptr = start_header_ptr;

	while(temp_start_ptr->next != NULL)
	{
		switch(temp_start_ptr->tag)
		{
			case 0x0112:
				if(temp_start_ptr->record_type == 1)
					break;
			case 0x829a:
			case 0x9209:
			case 0x8822:
			case 0x9207:
			case 0x0084:
			case 0x920a:
			case 0xa405:
			case 0x0083:
			case 0x8827:
			case 0x010f:
			case 0x0110:
			case 0x0131:
			case 0x9004:
			case 0x829d:
			case 0x0002:
			case 0x0013:
			case 0x0004:
			case 0x00a7:
			case 0x0007:
			case 0x0008:
			case 0x0009:
			case 0x0081:
			case 0x008b:
			case 0x008d:
			case 0x0090:
			case 0x0095:
			case 0x00a9:
			case 0x00aa:
			case 0x00ab:
			case 0xa002:
			case 0xa003:
			case 0x9204:
			case 0x9286:
				if(iTrace)
				{
					printf("tag: %x\n", temp_start_ptr->tag);
					printf("Field_type: %d\n", temp_start_ptr->field_type);
					printf("count: %d\n", temp_start_ptr->count);
					printf("value_offset: %x\n", temp_start_ptr->value_offset);
					printf("record_type: %d\n", temp_start_ptr->record_type);
				}

				ifde.tag = temp_start_ptr->tag;
				ifde.field_type = temp_start_ptr->field_type;
				ifde.count = temp_start_ptr->count;

				if(temp_start_ptr->byte_count > 4)
				{
					if(temp_start_ptr->tag == 0x829a ||
						temp_start_ptr->tag == 0x829d ||
						temp_start_ptr->tag == 0x9204 ||
						temp_start_ptr->tag == 0x920a)
					{
						type5_ptr = (struct type5 *) malloc(sizeof(struct type5));

						type5_ptr->numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
						type5_ptr->denominator = (unsigned long) Get32u((temp_start_ptr->data_at_offset + 4));

						memcpy(temp_data_buffer_ptr, type5_ptr, temp_start_ptr->byte_count);
						free(type5_ptr);
					}
					else if(temp_start_ptr->tag == 0x0084)
					{
						lens_ptr = (struct lens *) malloc(sizeof(struct lens));

						lens_ptr->field_1.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
						lens_ptr->field_1.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 4);
						lens_ptr->field_2.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 8);
						lens_ptr->field_2.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 12);
						lens_ptr->field_3.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 16);
						lens_ptr->field_3.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 20);
						lens_ptr->field_4.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 24);
						lens_ptr->field_4.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 28);

						memcpy(temp_data_buffer_ptr, lens_ptr, temp_start_ptr->byte_count);
						free(lens_ptr);
					}
					else
					{
						if(temp_start_ptr->tag == 0x0004)
						{
							memcpy(temp_data_buffer_ptr, "BASIC\0", strlen("BASIC\0"));
							temp_start_ptr->byte_count = strlen("BASIC\0") + 1;
							ifde.count = strlen("BASIC\0") + 1;
						}
						else if(temp_start_ptr->tag == 0x0131)
						{
							memset(buffer, (int) NULL, 256);
							sprintf(buffer, "D70Reader - v%s\0", D70_VERSION);
							memcpy(temp_data_buffer_ptr, buffer, strlen(buffer));
							temp_start_ptr->byte_count = strlen(buffer) + 1;
							ifde.count = strlen(buffer) + 1;
						}
						else
							memcpy(temp_data_buffer_ptr, temp_start_ptr->data_at_offset, temp_start_ptr->byte_count);
					}

					temp_data_buffer_ptr += temp_start_ptr->byte_count;
					ifde.value_offset = data_offset;
					data_offset += temp_start_ptr->byte_count;
				}
				else
				{
					if(temp_start_ptr->tag == 0xa405 || 
						temp_start_ptr->tag == 0x0112 ||
						temp_start_ptr->tag == 0x8822 || 
						temp_start_ptr->tag == 0x9209 || 
						temp_start_ptr->tag == 0x9207)
					{
						ulong = temp_start_ptr->value_offset;

						ubyte1 = (ulong & 0xff000000) >> 24;
						ubyte2 = (ulong & 0x00ff0000) >> 16;
						ubyte3 = (ulong & 0x0000ff00) >> 8;
						ubyte4 = (ulong & 0x000000ff) >> 0;
						ubyte5 = (ulong & 0xffff0000) >> 16;
						ubyte6 = (ulong & 0x0000ffff) >> 0;

						ifde.value_offset = ubyte5;
					}
					else if(temp_start_ptr->tag == 0x0083)
					{
						ulong = temp_start_ptr->value_offset;

						ubyte1 = (ulong & 0xff000000) >> 24;
						ubyte2 = (ulong & 0x00ff0000) >> 16;
						ubyte3 = (ulong & 0x0000ff00) >> 8;
						ubyte4 = (ulong & 0x000000ff) >> 0;
						ubyte5 = (ulong & 0xffff0000) >> 16;
						ubyte6 = (ulong & 0x0000ffff) >> 0;

						ifde.value_offset = ubyte1;
					}
					else
						ifde.value_offset = temp_start_ptr->value_offset;
				}

				memcpy(temp_dir_buffer_ptr, &ifde, 12);
				temp_dir_buffer_ptr += 12;
				break;
			default:
				break;
		}
	
		temp_start_ptr = temp_start_ptr->next;
	}

	switch(temp_start_ptr->tag)
	{
		case 0x0112:
			if(temp_start_ptr->record_type == 1)
				break;
		case 0x829a:
		case 0x9209:
		case 0x8822:
		case 0x9207:
		case 0x0084:
		case 0x920a:
		case 0xa405:
		case 0x0083:
		case 0x8827:
		case 0x010f:
		case 0x0110:
		case 0x0131:
		case 0x9004:
		case 0x829d:
		case 0x0002:
		case 0x0013:
		case 0x0004:
		case 0x00a7:
		case 0x0007:
		case 0x0008:
		case 0x0009:
		case 0x0081:
		case 0x008b:
		case 0x008d:
		case 0x0090:
		case 0x0095:
		case 0x00a9:
		case 0x00aa:
		case 0x00ab:
		case 0xa002:
		case 0xa003:
		case 0x9204:
		case 0x9286:
			if(iTrace)
			{
				printf("tag: %x\n", temp_start_ptr->tag);
				printf("Field_type: %d\n", temp_start_ptr->field_type);
				printf("count: %d\n", temp_start_ptr->count);
				printf("value_offset: %x\n", temp_start_ptr->value_offset);
				printf("record_type: %d\n", temp_start_ptr->record_type);
			}

			ifde.tag = temp_start_ptr->tag;
			ifde.field_type = temp_start_ptr->field_type;
			ifde.count = temp_start_ptr->count;

			if(temp_start_ptr->byte_count > 4)
			{
				if(temp_start_ptr->tag == 0x829a ||
					temp_start_ptr->tag == 0x829d ||
					temp_start_ptr->tag == 0x9204 ||
					temp_start_ptr->tag == 0x920a)
				{
					type5_ptr = (struct type5 *) malloc(sizeof(struct type5));

					type5_ptr->numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
					type5_ptr->denominator = (unsigned long) Get32u((temp_start_ptr->data_at_offset + 4));

					memcpy(temp_data_buffer_ptr, type5_ptr, temp_start_ptr->byte_count);
					free(type5_ptr);
				}
				else if(temp_start_ptr->tag == 0x0084)
				{
					lens_ptr = (struct lens *) malloc(sizeof(struct lens));

					lens_ptr->field_1.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset);
					lens_ptr->field_1.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 4);
					lens_ptr->field_2.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 8);
					lens_ptr->field_2.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 12);
					lens_ptr->field_3.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 16);
					lens_ptr->field_3.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 20);
					lens_ptr->field_4.numerator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 24);
					lens_ptr->field_4.denominator = (unsigned long) Get32u(temp_start_ptr->data_at_offset + 28);

					memcpy(temp_data_buffer_ptr, lens_ptr, temp_start_ptr->byte_count);
					free(lens_ptr);
				}
				else
				{
					if(temp_start_ptr->tag == 0x0004)
					{
						memcpy(temp_data_buffer_ptr, "BASIC\0", strlen("BASIC\0"));
						temp_start_ptr->byte_count = strlen("BASIC\0") + 1;
						ifde.count = strlen("BASIC\0") + 1;
					}
					else if(temp_start_ptr->tag == 0x0131)
					{
						memset(buffer, (int) NULL, 256);
						sprintf(buffer, "D70Reader - v%s\0", D70_VERSION);
						memcpy(temp_data_buffer_ptr, buffer, strlen(buffer));
						temp_start_ptr->byte_count = strlen(buffer) + 1;
						ifde.count = strlen(buffer) + 1;
					}
					else
						memcpy(temp_data_buffer_ptr, temp_start_ptr->data_at_offset, temp_start_ptr->byte_count);
				}

				temp_data_buffer_ptr += temp_start_ptr->byte_count;
				ifde.value_offset = data_offset;
				data_offset += temp_start_ptr->byte_count;
			}
			else
			{
				if(temp_start_ptr->tag == 0xa405 || 
					temp_start_ptr->tag == 0x0112 ||
					temp_start_ptr->tag == 0x8822 || 
					temp_start_ptr->tag == 0x9209 || 
					temp_start_ptr->tag == 0x9207)
				{
					ulong = temp_start_ptr->value_offset;

					ubyte1 = (ulong & 0xff000000) >> 24;
					ubyte2 = (ulong & 0x00ff0000) >> 16;
					ubyte3 = (ulong & 0x0000ff00) >> 8;
					ubyte4 = (ulong & 0x000000ff) >> 0;
					ubyte5 = (ulong & 0xffff0000) >> 16;
					ubyte6 = (ulong & 0x0000ffff) >> 0;

					ifde.value_offset = ubyte5;
				}
				else if(temp_start_ptr->tag == 0x0083)
				{
					ulong = temp_start_ptr->value_offset;

					ubyte1 = (ulong & 0xff000000) >> 24;
					ubyte2 = (ulong & 0x00ff0000) >> 16;
					ubyte3 = (ulong & 0x0000ff00) >> 8;
					ubyte4 = (ulong & 0x000000ff) >> 0;
					ubyte5 = (ulong & 0xffff0000) >> 16;
					ubyte6 = (ulong & 0x0000ffff) >> 0;

					ifde.value_offset = ubyte1;
				}
				else
					ifde.value_offset = temp_start_ptr->value_offset;
			}

			memcpy(temp_dir_buffer_ptr, &ifde, 12);
			temp_dir_buffer_ptr += 12;
			break;
		default:
			break;
	}

	// working stuff follows

	file_ptr = (char *) malloc(strlen(filename) + strlen(".JPG") + 1);
	memset(file_ptr, (int) NULL, (strlen(filename) + strlen(".JPG") + 1));
	strcat(file_ptr, filename);
	strcat(file_ptr, ".JPG");
	
	byte_ptr = (char *) malloc(lThumbnailLength);

	fseek(rfd, lThumbnailOffset + 2, 0);
	fread(byte_ptr, lThumbnailLength, 1, rfd);

	if((ofd = fopen(file_ptr, "wb")) == NULL)
	{
		printf("\nFile not created: %s\n\n", file_ptr);
		exit(1);
	}

	if((size = fwrite(exif_header_ptr, (sizeof(struct exif_header) - 2), 1, ofd)) == 0)
	{
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
	}


	if((size = fwrite(dir_buffer_ptr, ((12 * dir_count) + 4), 1, ofd)) == 0)
	{
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
	}

	if((size = fwrite(data_buffer_ptr, 1024, 1, ofd)) == 0)
	{
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
	}

	if((size = fwrite(byte_ptr, lThumbnailLength, 1, ofd)) == 0)
	{
		printf("\nFile not written: %s\n\n", file_ptr);
		exit(1);
	}

	printf("Created file: %s\n", file_ptr);

	fclose(ofd);

	free(byte_ptr);
	free(file_ptr);
/*
	free(exif_header_ptr);
	free(dir_buffer_ptr);
	free(data_buffer_ptr);
*/
	trace("-output_thumbnail\n");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void free_jpg_data_header_list(struct jpg_data_header *header_ptr)
{
	struct jpg_data_header *temp_header_ptr = NULL;

	trace("+free_jpg_data_header_list\n");

	while(header_ptr->next != NULL)
	{
		temp_header_ptr = header_ptr;
		header_ptr = header_ptr->next;
		free(temp_header_ptr);
	}

	free(header_ptr);
	trace("-free_jpg_data_header_list\n");
}

//--------------------------------------------------------------------------
// 
//--------------------------------------------------------------------------
void ProcessFileJPG(int argc, char *filename)
{
    FILE *rfd;                      /*used as the file pointer      */
    char buffer[256];
	char *temp_ptr = NULL;
	unsigned long offset_ifd;
	int ctr1 = 0;
	struct data_header_ptr *temp_header_start_ptr = NULL;
	struct data_header_ptr *free_header_start_ptr = NULL;
	struct html_header *free_html_header_start_ptr = NULL;

	trace("+ProcessFileJPG\n");

	temp_ptr = get_extension(filename);

	memset(trace_buffer, (int) NULL, 256);
	sprintf(trace_buffer, "File Extension: %s\n", temp_ptr);
	trace(trace_buffer);

	if(!strncmp(upper_case(temp_ptr), "JPG", 3))
	{
		iFile_Type = 0;
		my_jpg_exit("Only files of type NEF can be processed using opton -j");
	}
	else
	{
		iJPG_Type = 99;
		iFile_Type = 1;
	}

	if((rfd = fopen(filename, "rb")) == NULL)
	{
		printf("\nFile not found: %s\n\n", filename);
		exit(1);
	}

	memset(buffer, (int) NULL, 256);
	sprintf(buffer, "IFD%d", ctr1++);

	offset_ifd = inspect_image_file_header(rfd, iFile_Type);
	jpg_header_ptr = get_new_jpg_data_header_ptr();
	start_header_ptr = jpg_header_ptr;
	dump_jpg_image_file_directory(rfd, offset_ifd, jpg_type_offset(), buffer);

	if(iThumbnail)
	{
		if(iFile_Type)
			output_thumbnail(filename, rfd);
	}

	fclose(rfd);                    /*close file                    */

	free_jpg_data_header_list(start_header_ptr);

	trace("-ProcessFileJPG\n");
}

@


1.15
log
@Added FreeBSD ifndef.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.14 2005/01/13 17:06:15 joman Exp joman $	*/
d70 1
a70 1
static char rcsid[] = "$Id: d70reader.c,v 1.14 2005/01/13 17:06:15 joman Exp joman $";
d85 1
d104 12
d170 1
d177 2
a178 1
void my_exit(char *text_ptr);
d198 1
d237 4
a335 1

a340 1
  
d418 1
a418 1
int main(argc,argv)                     /*main routine                 */
d426 2
a427 2
        struct stat buf;
        char *filename;
d486 11
a496 4
                if(stat(filename, &buf) == (-1))
                        perror(filename);
                else
			ProcessFile(argc, filename);
d667 2
a668 1

d708 1
d2537 10
d3772 983
@


1.14
log
@Fixed bug of not outputting file name for -c option.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.13 2005/01/13 02:16:30 joman Exp joman $	*/
d61 1
d64 2
d70 1
a70 1
static char rcsid[] = "$Id: d70reader.c,v 1.13 2005/01/13 02:16:30 joman Exp joman $";
@


1.13
log
@Removed return character from -c output.
Just output linefeed.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.12 2005/01/13 01:55:32 joman Exp joman $	*/
d42 4
d64 2
a65 2
#define D70_VERSION "0.10"
#define D70_DATE "Thu Jan 13 01:50:52 UTC 2005"
d67 1
a67 1
static char rcsid[] = "$Id: d70reader.c,v 1.12 2005/01/13 01:55:32 joman Exp joman $";
d513 1
a513 1
	if((!iHtml) && (!iXml) && (!iCsv))
d519 1
a519 1
	if((iHtml) || (iXml))
d631 2
a632 1
	else
d672 2
d736 1
a736 1
		printf("%s,", local_header_start_ptr->Value);
d741 1
a741 1
	printf("%s\n", local_header_start_ptr->Value);
d1351 1
a1351 1
        printf("\n\t-c = generate Comma Seperated Values (CSV) data\n\n");
d3509 1
a3509 1
	if((!iHtml) && (!iXml) && (!iCsv))
d3546 1
a3546 1
	if((!iHtml) && (!iXml) && (!iCsv))
@


1.12
log
@Added -c option to generate CSV data.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.11 2005/01/10 21:36:25 joman Exp joman $	*/
d63 1
a63 1
static char rcsid[] = "$Id: d70reader.c,v 1.11 2005/01/10 21:36:25 joman Exp joman $";
d720 1
a720 1
		printf("%s\r\n", strip(local_header_start_ptr->Desc));
d734 1
a734 1
	printf("%s\r\n", local_header_start_ptr->Value);
@


1.11
log
@Added -j option to extract JPG image from NEF image.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.10 2005/01/04 04:05:29 joman Exp joman $	*/
d40 2
d55 2
d58 1
d60 2
a61 2
#define D70_VERSION "0.09"
#define D70_DATE "Mon Jan 10 21:31:51 UTC 2005"
d63 1
a63 1
static char rcsid[] = "$Id: d70reader.c,v 1.10 2005/01/04 04:05:29 joman Exp joman $";
d70 1
d77 1
d141 1
d425 4
d509 1
a509 1
	if((!iHtml) && (!iXml))
d625 4
a628 1
	printf("\n\n");
d678 2
d682 2
d687 1
a687 1
	while(html_header_start_ptr->next != NULL)
d689 1
a689 1
		printf("<%s>%s</%s>\n", strip(html_header_start_ptr->Desc), html_header_start_ptr->Value, strip(html_header_start_ptr->Desc));
d691 1
a691 1
		html_header_start_ptr = html_header_start_ptr->next;
d694 1
a694 1
	printf("<%s>%s</%s>\n", strip(html_header_start_ptr->Desc), html_header_start_ptr->Value, strip(html_header_start_ptr->Desc));
d703 39
d762 2
d766 3
a768 1
	printf("\n\n<table border=1 width=\"450\" cellpadding=1 align=\"center\">\n");
d770 1
a770 1
	while(html_header_start_ptr->next != NULL)
d772 1
a772 1
		printf("<tr><td nowrap>%s</td><td>%s</td></tr>\n", html_header_start_ptr->Desc, html_header_start_ptr->Value);
d774 1
a774 1
		html_header_start_ptr = html_header_start_ptr->next;
d777 1
a777 1
	printf("<tr><td nowrap>%s</td><td>%s</td></tr>\n", html_header_start_ptr->Desc, html_header_start_ptr->Value);
d1337 2
a1338 2
        printf("\n\td70reader [-h|-v|-w|-x|-j] image_file_name\n");
        printf("\n\td70reader [-h|-v|-w|-x|-j] *.NEF *.JPG\n");
d1341 4
a1344 3
        printf("\n\t-w = generate html table");
        printf("\n\t-x = generate xml tree");
        printf("\n\t-j = extract JPG thumbnail image from NEF\n\n");
d3502 1
a3502 1
	if((!iHtml) && (!iXml))
d3539 1
a3539 1
	if((!iHtml) && (!iXml))
@


1.10
log
@Added version 0.08 comment and date.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.9 2005/01/04 04:00:15 joman Exp joman $	*/
d37 3
d55 2
a56 2
#define D70_VERSION "0.08"
#define D70_DATE "Tue Jan  4 04:04:57 UTC 2005"
d58 1
a58 1
static char rcsid[] = "$Id: d70reader.c,v 1.9 2005/01/04 04:00:15 joman Exp joman $";
d61 4
a64 3
int iVerbos = 0;
int iHtml = 0;
int iXml = 0;
d125 4
a160 1
void PrintFormatNumber(void * ValuePtr, int Format, int ByteCount);
d192 2
d421 4
d539 1
a539 2
/*
	while(offset_ifd != 0)
d541 3
a543 9
		memset(buffer, (int) NULL, 256);
		sprintf(buffer, "IFD%d", ctr1++);

		dump_image_file_directory(rfd, offset_ifd, jpg_type_offset(), get_new_data_header_ptr(), buffer);

		old_position = ftell(rfd);
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "old_position: %x\n", old_position);
		trace(trace_buffer);
a544 7
		fread(&offset_ifd, sizeof(unsigned long), 1, rfd);
		offset_ifd = Get32u(&offset_ifd);
		memset(trace_buffer, (int) NULL, 256);
		sprintf(trace_buffer, "offset_ifd: %x\n", offset_ifd);
		trace(trace_buffer);
	}
*/
d623 38
d689 1
a689 1
	trace("+get_extension\n");
d695 1
d742 2
d769 1
d1275 2
a1276 2
        printf("\n\td70reader [-h|-v|-w|-x] image_file_name\n");
        printf("\n\td70reader [-h|-v|-w|-x] *.NEF *.JPG\n");
d1280 2
a1281 1
        printf("\n\t-x = generate xml tree\n\n");
a1382 11
/*
	unsigned int mByte0 = (uchar *)Long)[0] << 24;
	unsigned int mByte1 = (uchar *)Long)[1] << 16;
	unsigned int mByte2 = (uchar *)Long)[2] << 8;
	unsigned int mByte3 = (uchar *)Long)[3] << 0;

	unsigned int iByte0 = ( char *)Long)[3] << 24;
	unsigned int iByte1 = ( uchar *)Long)[2] << 16;
	unsigned int iByte2 = ( uchar *)Long)[1] << 8;
	unsigned int iByte3 = ( uchar *)Long)[0] << 0;
*/
a1403 37
// Display a number as one of its many formats
//--------------------------------------------------------------------------
void PrintFormatNumber(void * ValuePtr, int Format, int ByteCount)
{
	switch(Format)
	{
	        case FMT_SBYTE:
	        case FMT_BYTE:      
			printf("%02x\n",*(uchar *)ValuePtr);            
			break;
	        case FMT_USHORT:    
			printf("%d\n",Get16u(ValuePtr));                
			break;
	        case FMT_ULONG:
	        case FMT_SLONG:     
			printf("%d\n",Get32s(ValuePtr));                
			break;
	        case FMT_SSHORT:    
			printf("%hd\n",(signed short)Get16u(ValuePtr)); 
			break;
	        case FMT_URATIONAL:
	        case FMT_SRATIONAL:
	           	printf("%d/%d\n",Get32s(ValuePtr), Get32s(4+(char *)ValuePtr)); 
			break;
	        case FMT_SINGLE:    
			printf("%f\n",(double)*(float *)ValuePtr);   
			break;
	        case FMT_DOUBLE:    
			printf("%f\n",*(double *)ValuePtr);          
			break;
	        default:
	            	printf("Unknown format %d:", Format);
			break;
	}
}

//--------------------------------------------------------------------------
d1443 1
d1618 7
a1624 4
					fread(buffer, 256, 1, rfd);
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%s", buffer); 
					trace(trace_buffer);
d1626 1
a1626 2
					local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
					strcpy(local_ptr->Value, trace_buffer);
d1756 18
a1888 4
				//look at Nikon.pm for processing Maker Notes.
				//it's a type B2 header
				//look in Exif.pm - FormattedValue for handling formats

d2031 5
d2883 1
d3329 1
@


1.9
log
@Added tag 8827 (ISO).  Modified to use right shift operators
for selected formats that are less than 4 bytes long.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.8 2005/01/04 01:18:39 joman Exp joman $	*/
d33 4
d52 2
a53 2
#define D70_VERSION "0.07"
#define D70_DATE "Sat Jan  1 17:04:36 UTC 2005"
d55 1
a55 1
static char rcsid[] = "$Id: d70reader.c,v 1.8 2005/01/04 01:18:39 joman Exp joman $";
@


1.8
log
@Save before making deletions.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.7 2005/01/01 17:08:34 joman Exp joman $	*/
d51 1
a51 1
static char rcsid[] = "$Id: d70reader.c,v 1.7 2005/01/01 17:08:34 joman Exp joman $";
a1598 8
/* JON JON JON
					memset(buffer, (int) NULL, 256);
					sprintf(buffer, "%x", Get32u(&ifde_ptr->value_offset));
					byte_ptr = &buffer[0];
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%d\n", Get32u(&ifde_ptr->value_offset));
					trace(trace_buffer);
JON JON JON */
a1629 16
/* JON JON JON
//					ptr = get_data_from_long(ifde_ptr->value_offset);
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "\nreturned string: [%s], length: %d", get_data_from_long(ifde_ptr->value_offset), strlen(get_data_from_long(ifde_ptr->value_offset))); 
					trace(trace_buffer);

					memset(buffer, (int) NULL, 256);
					sprintf(buffer, "%s", get_data_from_long(ifde_ptr->value_offset)); 
//					long_to_asc(ifde_ptr->value_offset, buffer, components, ' ');
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%s", buffer); 
					trace(trace_buffer);

					local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
					strcpy(local_ptr->Value, trace_buffer);
JON JON JON */
a1678 35
/* JON JON JON
					memset(buffer, (int) NULL, 256);

					if(Get16u(&ifde_ptr->tag) == 0x0099 || Get16u(&ifde_ptr->tag) == 0x828D)
					{
						sprintf(buffer, "%x", Get32u(&ifde_ptr->value_offset));
					}
					else
					{
						if(components >= 2)
							sprintf(buffer, "%d", Get32u(&ifde_ptr->value_offset));
						else
							sprintf(buffer, "%d", Get16u(&ifde_ptr->value_offset));
					}

					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "buffer: %s\n", buffer);
					trace(trace_buffer);

					memset(trace_buffer, (int) NULL, 256);

					if(components >= 2)
						sprintf(trace_buffer, "Value: %x\n", Get32u(&ifde_ptr->value_offset));
					else
						sprintf(trace_buffer, "Value: %x\n", Get16u(&ifde_ptr->value_offset));

					trace(trace_buffer);

					if((Get16u(&ifde_ptr->tag) == 0x0002) || (Get16u(&ifde_ptr->tag) == 0x0013))
						print_iso_tag(Get32u(&ifde_ptr->value_offset), local_ptr);
					else if(Get16u(&ifde_ptr->tag) == 0x0099 || Get16u(&ifde_ptr->tag) == 0x828D)
						print_16bit_hex(pad_field(buffer, 4 * Get32u(&ifde_ptr->count), '0', 1), components, ByteCount, local_ptr);
					else
						print_16bit_bytes(buffer, components, ByteCount, local_ptr);
JON JON JON*/
a1752 8
/* JON JON JON
					memset(trace_buffer, (int) NULL, 256);
					sprintf(trace_buffer, "%d", Get32u(&ifde_ptr->value_offset)); 
					trace(trace_buffer);

					local_ptr->Value = (char *) malloc(strlen(trace_buffer) + 1);
					strcpy(local_ptr->Value, trace_buffer);
JON JON JON */
d2818 4
a2821 1
				debug_printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, 0));
d2837 1
a2858 1
			case 0xa405:
d3263 4
a3266 1
				my_printf("\n%s: %s", local_ptr->Desc, truncate(local_ptr->Value, 0));
d3282 1
a3303 1
			case 0xa405:
d3485 5
d3494 1
d3496 2
a3497 1
		printf("\nubyte1: %x\n", ubyte1);
d3512 1
a3512 1
			if(ibyte_count == 1)
d3514 16
a3529 1
				sprintf(trace_buffer, "%x", ubyte1);
d3531 1
a3531 1
			else if(ibyte_count == 2)
d3533 16
a3548 9
				sprintf(trace_buffer, "%x %x", ubyte1, ubyte2);
			}
			else if(ibyte_count == 3)
			{
				sprintf(trace_buffer, "%x %x %x", ubyte1, ubyte2, ubyte3);
			}
			else if(ibyte_count == 4)
			{
				sprintf(trace_buffer, "%x %x %x %x", ubyte1, ubyte2, ubyte3, ubyte4);
d3564 4
a3567 1
				sprintf(trace_buffer, "%c%c%c", ubyte1, ubyte2, ubyte3);
d3600 4
a3603 1
				sprintf(trace_buffer, "%d", ubyte6);
d3609 4
a3612 1
					sprintf(trace_buffer, "%d", ubyte5);
@


1.7
log
@Fixed spelling of 'seconds'.  Fixed UserComment.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.6 2004/12/30 22:05:52 joman Exp joman $	*/
d8 1
a8 1
/*      This may be compiled under Linux GCC like this:  cc jpgexif.c   */
d51 1
a51 1
static char rcsid[] = "$Id: d70reader.c,v 1.6 2004/12/30 22:05:52 joman Exp joman $";
d89 29
a184 28
struct image_file_header
{
        char byte_order[2];                     /*byte order indicator 'II' or 'MM' */
        unsigned short image_file_type;         /*image file type                   */
        unsigned long offset_to_first_ifd;      /*offset to first IFD               */
};

struct jpg_image_file_header
{
	unsigned char start;
	unsigned char soi;
	unsigned char pad;
	unsigned char exif_ind;
	unsigned short length;
	char exif_header_text[6];
        char byte_order[2];                     /*byte order indicator 'II' or 'MM' */
        unsigned short image_file_type;         /*image file type                   */
        unsigned long offset_to_first_ifd;      /*offset to first IFD               */
};

struct image_file_directory_entry
{
        unsigned short tag;         		/*tag                 */
        unsigned short field_type;         	/*field type          */
        unsigned long count;      		/*count               */
        unsigned long value_offset;     	/*value offset        */
};

d625 1
d635 1
d1223 1
a1223 1
        printf("\nThis program only works with Nikon D70 image files.");
d1597 3
d1606 1
a1608 4
				memset(trace_buffer, (int) NULL, 256);
				sprintf(trace_buffer, "JON - 003\n");
				trace(trace_buffer);

d1637 2
d1653 1
d1702 2
d1737 1
a1737 1

d1812 1
d1819 2
d3412 4
a3415 1
		sprintf(buffer, "%s-%smm f/%s-f/%s", truncate(token1, 0), truncate(token2, 0), truncate(token3, 2), truncate(token4, 2));
d3519 144
@


1.6
log
@Fixed message in instruct() function.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.5 2004/12/30 21:33:40 joman Exp joman $	*/
d30 3
d35 4
d48 2
a49 2
#define D70_VERSION "0.06"
#define D70_DATE "Thu Dec 30 21:20:09 UTC 2004"
d51 1
a51 1
static char rcsid[] = "$Id: d70reader.c,v 1.5 2004/12/30 21:33:40 joman Exp joman $";
d154 1
d241 1
d245 2
d2041 1
a2041 1
					fseek(rfd, Get32u(&ifde_ptr->value_offset) + offset_base, 0);
d2487 1
a2487 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/8000");
d2491 1
a2491 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/6400");
d2495 1
a2495 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/5000");
d2499 1
a2499 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/4000");
d2503 1
a2503 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/3200");
d2507 1
a2507 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/2500");
d2511 1
a2511 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/2000");
d2515 1
a2515 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1600");
d2519 1
a2519 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1250");
d2523 1
a2523 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1000");
d2527 1
a2527 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/800");
d2531 1
a2531 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/640");
d2535 1
a2535 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/500");
d2539 1
a2539 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/400");
d2543 1
a2543 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/320");
d2547 1
a2547 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/250");
d2551 1
a2551 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/200");
d2555 1
a2555 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/160");
d2559 1
a2559 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/125");
d2563 1
a2563 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/100");
d2567 1
a2567 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/80");
d2571 1
a2571 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/60");
d2575 1
a2575 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/50");
d2579 1
a2579 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/40");
d2583 1
a2583 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/30");
d2587 1
a2587 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/25");
d2591 1
a2591 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/20");
d2595 1
a2595 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/15");
d2599 1
a2599 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/13");
d2603 1
a2603 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/10");
d2607 1
a2607 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/8");
d2611 1
a2611 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/6");
d2615 1
a2615 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/5");
d2619 1
a2619 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/4");
d2623 1
a2623 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/3");
d2627 1
a2627 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/2.5");
d2631 1
a2631 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/2");
d2635 1
a2635 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1.6");
d2639 1
a2639 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1.3");
d2643 1
a2643 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1");
d2647 1
a2647 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1.3");
d2651 1
a2651 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1.6");
d2655 1
a2655 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "2");
d2659 1
a2659 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "2.5");
d2663 1
a2663 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "3");
d2667 1
a2667 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "4");
d2671 1
a2671 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "5");
d2675 1
a2675 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "6");
d2679 1
a2679 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "8");
d2683 1
a2683 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "10");
d2687 1
a2687 1
					debug_printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
a2898 1
			case 0x00a6:
d2930 1
a2930 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/8000");
d2934 1
a2934 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/6400");
d2938 1
a2938 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/5000");
d2942 1
a2942 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/4000");
d2946 1
a2946 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/3200");
d2950 1
a2950 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/2500");
d2954 1
a2954 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/2000");
d2958 1
a2958 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/1600");
d2962 1
a2962 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/1250");
d2966 1
a2966 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/1000");
d2970 1
a2970 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/800");
d2974 1
a2974 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/640");
d2978 1
a2978 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/500");
d2982 1
a2982 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/400");
d2986 1
a2986 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/320");
d2990 1
a2990 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/250");
d2994 1
a2994 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/200");
d2998 1
a2998 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/160");
d3002 1
a3002 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/125");
d3006 1
a3006 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/100");
d3010 1
a3010 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/80");
d3014 1
a3014 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/60");
d3018 1
a3018 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/50");
d3022 1
a3022 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/40");
d3026 1
a3026 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/30");
d3030 1
a3030 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/25");
d3034 1
a3034 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/20");
d3038 1
a3038 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/15");
d3042 1
a3042 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/13");
d3046 1
a3046 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/10");
d3050 1
a3050 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/8");
d3054 1
a3054 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/6");
d3058 1
a3058 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/5");
d3062 1
a3062 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/4");
d3066 1
a3066 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/3");
d3070 1
a3070 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/2.5");
d3074 1
a3074 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/2");
d3078 1
a3078 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/1.6");
d3082 1
a3082 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1/1.3");
d3086 1
a3086 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1");
d3090 1
a3090 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1.3");
d3094 1
a3094 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "1.6");
d3098 1
a3098 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "2");
d3102 1
a3102 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "2.5");
d3106 1
a3106 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "3");
d3110 1
a3110 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "4");
d3114 1
a3114 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "5");
d3118 1
a3118 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "6");
d3122 1
a3122 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "8");
d3126 1
a3126 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, "10");
d3130 1
a3130 1
					my_printf("\n%s: %s secounds", local_ptr->Desc, local_ptr->Value);
a3340 1
			case 0x00a6:
@


1.5
log
@Added -x option for XML output.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.4 2004/12/29 21:36:42 joman Exp joman $	*/
d44 1
a44 1
static char rcsid[] = "$Id: d70reader.c,v 1.4 2004/12/29 21:36:42 joman Exp joman $";
d1216 2
a1217 2
        printf("\n\td70reader [-h|-v|-w] image_file_name\n");
        printf("\n\td70reader [-h|-v|-w] *.NEF *.JPG\n");
d1220 1
a1220 1
        printf("\n\t-w = generate html table\n\n");
@


1.4
log
@Added -w option to generate HTML tables of EXIF data.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.3 2004/12/27 21:23:08 joman Exp $	*/
d28 2
d41 2
a42 2
#define D70_VERSION "0.05"
#define D70_DATE "Wed Dec 29 21:06:35 UTC 2004"
d44 1
a44 1
static char rcsid[] = "$Id: d70reader.c,v 1.3 2004/12/27 21:23:08 joman Exp $";
d49 1
d82 1
d85 1
d206 1
a206 1
  { 0x013,   "ISO (2)                    "},
d392 4
d468 5
a472 2
	printf("\nD70Reader Program Version  : %s", D70_VERSION);
	printf("\nFilename                   : %s", filename);
d474 1
a474 1
	if(iHtml)
d478 1
a478 1
			debug_printf("%x %s %s", 0xFFFE, "D70Reader Program Version  ", D70_VERSION);
d483 1
a483 1
			my_printf("%s %s", "D70Reader Program Version  ", D70_VERSION);
d590 2
a591 2
	free_html_header_start_ptr = html_header_start_ptr;

d595 3
d608 38
a670 10
/*
struct data_header_ptr
{
	char *data_type;
	struct data_header *header_ptr;
	struct data_header_ptr *prev;
	struct data_header_ptr *next;
};

*/
d1221 1
a2679 24
/*
0           0x00 => 'No Flash',
1           0x01 => 'Fired',
5           0x05 => 'Fired, Return not detected',
7           0x07 => 'Fired, Return detected',
9           0x09 => 'On',
13          0x0d => 'On, Return not detected',
15          0x0f => 'On, Return detected',
16          0x10 => 'Off',
24          0x18 => 'Auto, Did not fire',
25          0x19 => 'Auto, Fired',
29          0x1d => 'Auto, Fired, Return not detected',
31          0x1f => 'Auto, Fired, Return detected',
32          0x20 => 'No flash function',
65          0x41 => 'Fired, Red-eye reduction',
69          0x45 => 'Fired, Red-eye reduction, Return not detected',
71          0x47 => 'Fired, Red-eye reduction, Return detected',
73          0x49 => 'On, Red-eye reduction',
77          0x4d => 'On, Red-eye reduction, Return not detected',
79          0x4f => 'On, Red-eye reduction, Return detected',
89          0x59 => 'Auto, Fired, Red-eye reduction',
93          0x5d => 'Auto, Fired, Red-eye reduction, Return not detected',
95          0x5f => 'Auto, Fired, Red-eye reduction, Return detected',
*/
a2818 10
/*
            1 => 'Horizontal (normal)',
            2 => 'Mirrored horizontal',
            3 => 'Rotated 180',
            4 => 'Mirrored vertical',
            5 => 'Mirrored horizontal then rotated 90 CCW',
            6 => 'Rotated 90 CW',
            7 => 'Mirrored horizontal then rotated 90 CW',
            8 => 'Rotated 90 CCW',
*/
a3394 4
//	memset(trace_buffer, (int) NULL, 256);
//	sprintf(trace_buffer, "token: %s\n", token);
//	trace(trace_buffer);

a3426 8
/*
struct html_header
{
	char * Desc;
	char * Value;
	struct html_header *next;
};
*/
d3455 1
a3455 1
	if(!iHtml)
d3492 1
a3492 1
	if(!iHtml)
@


1.3
log
@Reformat lens display.  Added LensInfo.
Truncate decimal part of focal length.
@
text
@d2 1
a2 1
/*	$Id: d70reader.c,v 1.2 2004/12/27 15:29:56 joman Exp joman $	*/
d24 4
d39 2
a40 1
static char rcsid[] = "$Id: d70reader.c,v 1.2 2004/12/27 15:29:56 joman Exp joman $";
d42 3
a44 1
int iTrace = 0;		// set this to '1', to turn on trace/debug
d46 1
d54 7
d79 5
d87 1
a87 1
void free_memory(struct data_header_ptr *free_header_start_ptr);
d172 2
d383 4
d433 1
d459 1
a459 1
	printf("\nD70Reader Program Version  : 0.04");
d462 14
d578 5
d585 1
a585 1
	free_memory(free_header_start_ptr);
d593 24
a616 1
void free_memory(struct data_header_ptr *free_header_start_ptr)
d646 3
a656 11
/*
struct data_header
{
	unsigned short Tag;
        unsigned short field_type;
        unsigned long count;    
	char * Desc;
	char * Value;
	struct data_header *next;
};
*/
d674 20
d1163 1
a1163 1
        printf("\nD70Reader - Version 0.04 - Mon Dec 27 16:19:25 EST 2004\n"); 
d1173 2
a1174 2
        printf("\n\td70reader [-h|-v] image_file_name\n");
        printf("\n\td70reader [-h|-v] *.NEF *.JPG\n");
d1176 36
a1211 1
        printf("\n\t-v = verbose (raw data)\n\n");
d1426 1
a1426 1
		main_header_ptr->data_type = (char *) malloc(strlen(type_ptr) + 1);
d1438 1
a1438 1
		memset(main_header_ptr->data_type, (int) NULL, strlen(type_ptr) + 1);
d2090 11
d2432 1
a2432 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/8000");
d2436 1
a2436 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/6400");
d2440 1
a2440 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/5000");
d2444 1
a2444 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/4000");
d2448 1
a2448 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/3200");
d2452 1
a2452 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/2500");
d2456 1
a2456 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/2000");
d2460 1
a2460 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1600");
d2464 1
a2464 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1250");
d2468 1
a2468 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1000");
d2472 1
a2472 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/800");
d2476 1
a2476 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/640");
d2480 1
a2480 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/500");
d2484 1
a2484 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/400");
d2488 1
a2488 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/320");
d2492 1
a2492 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/250");
d2496 1
a2496 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/200");
d2500 1
a2500 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/160");
d2504 1
a2504 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/125");
d2508 1
a2508 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/100");
d2512 1
a2512 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/80");
d2516 1
a2516 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/60");
d2520 1
a2520 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/50");
d2524 1
a2524 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/40");
d2528 1
a2528 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/30");
d2532 1
a2532 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/25");
d2536 1
a2536 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/20");
d2540 1
a2540 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/15");
d2544 1
a2544 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/13");
d2548 1
a2548 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/10");
d2552 1
a2552 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/8");
d2556 1
a2556 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/6");
d2560 1
a2560 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/5");
d2564 1
a2564 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/4");
d2568 1
a2568 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/3");
d2572 1
a2572 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/2.5");
d2576 1
a2576 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/2");
d2580 1
a2580 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1.6");
d2584 1
a2584 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1/1.3");
d2588 1
a2588 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1");
d2592 1
a2592 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1.3");
d2596 1
a2596 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "1.6");
d2600 1
a2600 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "2");
d2604 1
a2604 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "2.5");
d2608 1
a2608 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "3");
d2612 1
a2612 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "4");
d2616 1
a2616 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "5");
d2620 1
a2620 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "6");
d2624 1
a2624 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "8");
d2628 1
a2628 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, "10");
d2632 1
a2632 1
					printf("\n%#x: %s: %s secounds", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
d2663 1
a2663 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "No Flash");
d2667 1
a2667 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired");
d2671 1
a2671 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Return not detected");
d2675 1
a2675 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Return detected");
d2679 1
a2679 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On");
d2683 1
a2683 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Return not detected");
d2687 1
a2687 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Return detected");
d2691 1
a2691 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Off");
d2695 1
a2695 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Did not fire");
d2699 1
a2699 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired");
d2703 1
a2703 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Return not detected");
d2707 1
a2707 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Return detected");
d2711 1
a2711 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "No flash function");
d2715 1
a2715 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction");
d2719 1
a2719 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction, Return not detected");
d2723 1
a2723 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Fired, Red-eye reduction, Return detected");
d2727 1
a2727 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction");
d2731 1
a2731 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction, Return not detected");
d2735 1
a2735 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "On, Red-eye reduction, Return detected");
d2739 1
a2739 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction");
d2743 1
a2743 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return not detected");
d2747 1
a2747 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return detected");
d2751 1
a2751 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
d2757 1
a2757 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Program AE");
d2761 1
a2761 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Auto");
d2765 1
a2765 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Shutter speed priority AE");
d2769 1
a2769 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Aperture-priority AE");
d2773 1
a2773 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Manual");
d2777 1
a2777 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
d2783 1
a2783 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Multi-segment");
d2787 1
a2787 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Spot");
d2791 1
a2791 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Center-weighted average");
d2795 1
a2795 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
d2814 1
a2814 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Horizontal (normal)");
d2818 1
a2818 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal");
d2822 1
a2822 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 180");
d2826 1
a2826 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored vertical");
d2830 1
a2830 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal then rotated 90 CCW");
d2834 1
a2834 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 90 CW");
d2838 1
a2838 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Mirrored horizontal then rotated 90 CW");
d2842 1
a2842 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, "Rotated 90 CCW");
d2846 1
a2846 1
					printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
d2850 1
a2850 1
				printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, convert_lens(local_ptr->Value));
d2853 15
a2867 1
				printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, truncate(local_ptr->Value, 0));
a2875 1
			case 0x0083:
d2897 1
a2897 1
				printf("\n%#x: %s: %s", local_ptr->Tag, local_ptr->Desc, local_ptr->Value);
d2910 1
a2910 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/8000");
d2914 1
a2914 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/6400");
d2918 1
a2918 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/5000");
d2922 1
a2922 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/4000");
d2926 1
a2926 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/3200");
d2930 1
a2930 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/2500");
d2934 1
a2934 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/2000");
d2938 1
a2938 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/1600");
d2942 1
a2942 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/1250");
d2946 1
a2946 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/1000");
d2950 1
a2950 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/800");
d2954 1
a2954 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/640");
d2958 1
a2958 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/500");
d2962 1
a2962 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/400");
d2966 1
a2966 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/320");
d2970 1
a2970 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/250");
d2974 1
a2974 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/200");
d2978 1
a2978 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/160");
d2982 1
a2982 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/125");
d2986 1
a2986 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/100");
d2990 1
a2990 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/80");
d2994 1
a2994 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/60");
d2998 1
a2998 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/50");
d3002 1
a3002 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/40");
d3006 1
a3006 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/30");
d3010 1
a3010 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/25");
d3014 1
a3014 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/20");
d3018 1
a3018 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/15");
d3022 1
a3022 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/13");
d3026 1
a3026 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/10");
d3030 1
a3030 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/8");
d3034 1
a3034 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/6");
d3038 1
a3038 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/5");
d3042 1
a3042 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/4");
d3046 1
a3046 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/3");
d3050 1
a3050 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/2.5");
d3054 1
a3054 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/2");
d3058 1
a3058 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/1.6");
d3062 1
a3062 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1/1.3");
d3066 1
a3066 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1");
d3070 1
a3070 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1.3");
d3074 1
a3074 1
					printf("\n%s: %s secounds", local_ptr->Desc, "1.6");
d3078 1
a3078 1
					printf("\n%s: %s secounds", local_ptr->Desc, "2");
d3082 1
a3082 1
					printf("\n%s: %s secounds", local_ptr->Desc, "2.5");
d3086 1
a3086 1
					printf("\n%s: %s secounds", local_ptr->Desc, "3");
d3090 1
a3090 1
					printf("\n%s: %s secounds", local_ptr->Desc, "4");
d3094 1
a3094 1
					printf("\n%s: %s secounds", local_ptr->Desc, "5");
d3098 1
a3098 1
					printf("\n%s: %s secounds", local_ptr->Desc, "6");
d3102 1
a3102 1
					printf("\n%s: %s secounds", local_ptr->Desc, "8");
d3106 1
a3106 1
					printf("\n%s: %s secounds", local_ptr->Desc, "10");
d3110 1
a3110 1
					printf("\n%s: %s secounds", local_ptr->Desc, local_ptr->Value);
d3116 1
a3116 1
					printf("\n%s: %s", local_ptr->Desc, "No Flash");
d3120 1
a3120 1
					printf("\n%s: %s", local_ptr->Desc, "Fired");
d3124 1
a3124 1
					printf("\n%s: %s", local_ptr->Desc, "Fired, Return not detected");
d3128 1
a3128 1
					printf("\n%s: %s", local_ptr->Desc, "Fired, Return detected");
d3132 1
a3132 1
					printf("\n%s: %s", local_ptr->Desc, "On");
d3136 1
a3136 1
					printf("\n%s: %s", local_ptr->Desc, "On, Return not detected");
d3140 1
a3140 1
					printf("\n%s: %s", local_ptr->Desc, "On, Return detected");
d3144 1
a3144 1
					printf("\n%s: %s", local_ptr->Desc, "Off");
d3148 1
a3148 1
					printf("\n%s: %s", local_ptr->Desc, "Auto, Did not fire");
d3152 1
a3152 1
					printf("\n%s: %s", local_ptr->Desc, "Auto, Fired");
d3156 1
a3156 1
					printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Return not detected");
d3160 1
a3160 1
					printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Return detected");
d3164 1
a3164 1
					printf("\n%s: %s", local_ptr->Desc, "No flash function");
d3168 1
a3168 1
					printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction");
d3172 1
a3172 1
					printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction, Return not detected");
d3176 1
a3176 1
					printf("\n%s: %s", local_ptr->Desc, "Fired, Red-eye reduction, Return detected");
d3180 1
a3180 1
					printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction");
d3184 1
a3184 1
					printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction, Return not detected");
d3188 1
a3188 1
					printf("\n%s: %s", local_ptr->Desc, "On, Red-eye reduction, Return detected");
d3192 1
a3192 1
					printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction");
d3196 1
a3196 1
					printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return not detected");
d3200 1
a3200 1
					printf("\n%s: %s", local_ptr->Desc, "Auto, Fired, Red-eye reduction, Return detected");
d3204 1
a3204 1
					printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3210 1
a3210 1
					printf("\n%s: %s", local_ptr->Desc, "Program AE");
d3214 1
a3214 1
					printf("\n%s: %s", local_ptr->Desc, "Auto");
d3218 1
a3218 1
					printf("\n%s: %s", local_ptr->Desc, "Shutter speed priority AE");
d3222 1
a3222 1
					printf("\n%s: %s", local_ptr->Desc, "Aperture-priority AE");
d3226 1
a3226 1
					printf("\n%s: %s", local_ptr->Desc, "Manual");
d3230 1
a3230 1
					printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3236 1
a3236 1
					printf("\n%s: %s", local_ptr->Desc, "Multi-segment");
d3240 1
a3240 1
					printf("\n%s: %s", local_ptr->Desc, "Spot");
d3244 1
a3244 1
					printf("\n%s: %s", local_ptr->Desc, "Center-weighted average");
d3248 1
a3248 1
					printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3257 1
a3257 1
					printf("\n%s: %s", local_ptr->Desc, "Horizontal (normal)");
d3261 1
a3261 1
					printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal");
d3265 1
a3265 1
					printf("\n%s: %s", local_ptr->Desc, "Rotated 180");
d3269 1
a3269 1
					printf("\n%s: %s", local_ptr->Desc, "Mirrored vertical");
d3273 1
a3273 1
					printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal then rotated 90 CCW");
d3277 1
a3277 1
					printf("\n%s: %s", local_ptr->Desc, "Rotated 90 CW");
d3281 1
a3281 1
					printf("\n%s: %s", local_ptr->Desc, "Mirrored horizontal then rotated 90 CW");
d3285 1
a3285 1
					printf("\n%s: %s", local_ptr->Desc, "Rotated 90 CCW");
d3289 1
a3289 1
					printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3293 1
a3293 1
				printf("\n%s: %s", local_ptr->Desc, convert_lens(local_ptr->Value));
d3296 15
a3310 1
				printf("\n%s: %s", local_ptr->Desc, truncate(local_ptr->Value, 0));
a3318 1
			case 0x0083:
d3340 1
a3340 1
				printf("\n%s: %s", local_ptr->Desc, local_ptr->Value);
d3416 82
@


1.2
log
@Added RCS identification tags.
@
text
@d2 2
a3 1
/*	$Id$								*/
d20 4
d35 1
a35 1
static char rcsid[] = "$Id$";
d64 2
d191 1
a191 1
  { 0x08B,   "Unknown                    "},
d432 1
a432 1
	printf("\nD70Reader Program Version  : 0.03");
d1082 1
a1082 1
        printf("\nD70Reader - Version 0.03 - Sun Dec 26 11:19:15 EST 2004\n"); 
d2722 6
a2735 1
			case 0x0084:
a2736 1
			case 0x920a:
d2743 1
d3152 6
a3165 1
			case 0x0084:
a3166 1
			case 0x920a:
d3173 1
d3198 65
@


1.1
log
@Initial revision
@
text
@d2 1
d30 1
@
